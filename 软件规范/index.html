<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>【规范】C &amp; MCU 编写规范和其他 - 折耳根</title><meta name="Description" content="比较详细、全名的介绍了C &amp; MCU 编写规范和其他"><meta property="og:title" content="【规范】C &amp; MCU 编写规范和其他" />
<meta property="og:description" content="比较详细、全名的介绍了C &amp; MCU 编写规范和其他" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://Staok.github.io/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-10T16:15:14+08:00" />
<meta property="article:modified_time" content="2021-07-02T16:17:18+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="【规范】C &amp; MCU 编写规范和其他"/>
<meta name="twitter:description" content="比较详细、全名的介绍了C &amp; MCU 编写规范和其他"/>
<meta name="application-name" content="Staok - 瞰百易">
<meta name="apple-mobile-web-app-title" content="Staok - 瞰百易"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://Staok.github.io/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/" /><link rel="prev" href="http://Staok.github.io/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/" /><link rel="next" href="http://Staok.github.io/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "【规范】C \u0026 MCU 编写规范和其他",
        "inLanguage": "",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/Staok.github.io\/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "http:\/\/Staok.github.io\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048
                        }],"genre": "posts","keywords": "规范, 软件","wordcount":  16599 ,
        "url": "http:\/\/Staok.github.io\/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83\/","datePublished": "2021-02-10T16:15:14+08:00","dateModified": "2021-07-02T16:17:18+08:00","publisher": {
            "@type": "Organization",
            "name": "Staok","logo": {
                    "@type": "ImageObject",
                    "url": "http:\/\/Staok.github.io\/images\/avatar.png",
                    "width":  404 ,
                    "height":  392
                }},"author": {
                "@type": "Person",
                "name": "Staok"
            },"description": "比较详细、全名的介绍了C \u0026 MCU 编写规范和其他"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="折耳根"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>回家</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="折耳根"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>回家</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">【规范】C &amp; MCU 编写规范和其他</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/Staok" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Staok</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E8%A7%84%E8%8C%83/"><i class="far fa-folder fa-fw"></i>规范</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-02-10">2021-02-10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 16599 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 34 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#o-目录">O 目录</a></li>
    <li><a href="#1-日常素养">1 日常素养</a></li>
    <li><a href="#2-程序框架要点">2 程序框架要点</a></li>
    <li><a href="#3-代码格式化工具列举">3 代码格式化工具列举</a></li>
    <li><a href="#35-数据结构简述">3.5 数据结构简述</a></li>
    <li><a href="#4-普适规则general-rules">4 普适规则（General rules）</a></li>
    <li><a href="#5-具体各部分的规范形式">5 具体各部分的规范形式</a>
      <ul>
        <li><a href="#关于函数定义形式functions">关于函数定义形式（Functions）</a></li>
        <li><a href="#关于变量定义形式variables">关于变量定义形式（Variables）</a></li>
        <li><a href="#关于结构体枚举和类型定义形式structures-enumerations-typedefs">关于结构体、枚举和类型定义形式（Structures, enumerations, typedefs）</a></li>
        <li><a href="#关于宏定义和预编译指令定义形式macros-and-preprocessor-directives">关于宏定义和预编译指令定义形式（Macros and preprocessor directives）</a></li>
        <li><a href="#关于注释的形式comments">关于注释的形式（Comments）</a></li>
        <li><a href="#其他常用写法汇集不定期更新">其他常用写法汇集（不定期更新）</a>
          <ul>
            <li><a href="#实用技巧">实用技巧</a></li>
            <li><a href="#奇技淫巧的黑魔法">奇技淫巧的黑魔法</a></li>
            <li><a href="#用-c-实现高阶特性">用 C 实现高阶特性</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#6-常用宏定义">6 常用宏定义</a></li>
    <li><a href="#7-c-标准库的使用">7 C 标准库的使用</a></li>
    <li><a href="#8-st-hal-的编写形式">8 ST HAL 的编写形式</a></li>
    <li><a href="#9-本文参考源">9 本文参考源</a></li>
    <li><a href="#10-大厂规范和名设计模式">10 大厂规范和名设计模式</a>
      <ul>
        <li><a href="#大厂规范">大厂规范</a></li>
        <li><a href="#设计定律原则和模式">设计定律、原则和模式</a></li>
        <li><a href="#提高代码运行效率">提高代码运行效率</a></li>
      </ul>
    </li>
    <li><a href="#11-尾记">11 尾记</a>
      <ul>
        <li><a href="#开光保护">开光保护</a></li>
      </ul>
    </li>
    <li><a href="#署名">署名</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a></p>
<p>本文的源文在<a href="https://github.com/Staok/coding-style-and-more" target="_blank" rel="noopener noreffer">Staok/coding-style-and-more: C 编写规范和其他。永远地不定期更新。CC-BY-NC-SA 4.0。 (github.com)</a>。今后只在上面的链接里，这里不会跟进。</p>
<p>本文系广泛撷取、借鉴和整理，侵删。本文适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！</p>
<hr>
<p>按：引用观视频工作室视频<a href="https://www.bilibili.com/video/BV1BA411K7FJ" target="_blank" rel="noopener noreffer">【大师计划·林宝军03】北斗三号总师：我来跟你说说，&hellip;</a>里面总师受访时所说的话：</p>
<p>5:48：“&hellip;所以我经常讲，要把一个产品做好，其实有三方面，一个是<strong>技术</strong>，一个是<strong>质量</strong>，一个是<strong>管理</strong>，这三方面；技术水平，质量保障能力和管理能力，三条腿哪个都少不了，少一个，这个东西（航天）也做不上去，其实技术只是一方面，&hellip;”。</p>
<p>6:44：“&hellip;光是技术上去了，不见得能做出一个系统。对我们工程来讲，就是（需要）<strong>规范的文化</strong>，什么意思呢，比如我们几十年的航天经验，我把这个经验总结成文字，总结成规范，不管是谁做，只要有一定的经验，按这个规范做出来，做得卫星出来，打到天上去就能好用，这就是规范文化。包括匠人文化和规范文化，最后都是按规矩去做，它强调的是解决了怎么做的问题，但它有一个缺点，没强调为什么，其实我认为在做的过程中，<strong>加个为什么可能更好</strong>。”</p>
<hr>
<h2 id="o-目录">O 目录</h2>
<p>[TOC]</p>
<hr>
<h2 id="1-日常素养">1 日常素养</h2>
<ul>
<li>
<p>维护干净整洁的编程环境（保持愉悦的心情，干净整洁的桌面，友好和蔼的同事等等）。</p>
</li>
<li>
<p>身体坐直，按时走走，保证睡眠，计划运动。</p>
</li>
<li>
<p>要学习或使用新东西，全网搜集到好的手册和资料，就已经成功了一半（所谓好的资料不一定是官方教程或手册，可以是别人总结的入门系列文章或视频，适合自己快速摄入的才是好的）。</p>
</li>
<li>
<p>循序渐进，由浅入深。对什么也不感兴趣、不深入是浮躁，而且不经过深入全面的了解就硬扛大型项目也是一种浮躁。</p>
</li>
<li>
<p>习惯去看源代码（熏陶优秀代码风格，有时还能发现新东西）。</p>
</li>
<li>
<p>先搞清楚需求，再构思，再开发，顺序不能错。</p>
</li>
<li>
<p>不要重复造轮子，时常逛开源网站，有新想法可以先去找轮子，也许比自己写的更好，相信前人的智慧和同行们雪亮的眼光。</p>
</li>
<li>
<p>编译错误，如果不明白哪错了，直接无脑复制编译器的错误信息扔到搜索引擎框，然后点“搜索”按钮（大部分报错都是语法错误）。</p>
</li>
<li>
<p>关于提问，是一门艺术：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/133763900" target="_blank" rel="noopener noreffer">谈谈提问的艺术 | How To Ask Questions The Smart Way</a></li>
<li><a href="https://blog.csdn.net/ajian005/article/details/81006663" target="_blank" rel="noopener noreffer">《提问的艺术：如何快速获得答案》（精读版）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/95536926" target="_blank" rel="noopener noreffer">如何问出一个好问题？| 提问的艺术</a></li>
</ul>
</li>
<li>
<p>有结对编程，协作开发的能力。</p>
</li>
<li>
<p>有写文档的习惯（对项目写文档，或者日常写博客，或者没事就画一画流程图梳理想法）（不要在技术文章里写“日记”、写“小说”。），条理清晰，简化描述（Keep it stupid simple），并且一定要写上用例，写上例子，写上实例（重要的事情讲三遍）！</p>
</li>
<li>
<p>做好版本管理，有备份的意识（打压缩包写上时间也好，使用git工具也好，放到U盘里也好，传到私人网盘也好）。</p>
</li>
<li>
<p>时常看书，时常看看同行的文章，常读常新。</p>
</li>
<li>
<p>不止技术，不想当将军的士兵不是好士兵（有的人领导能力强，有的人能开发有竞争力的产品，有的人能把知识讲地透彻，有的人理论功底强），时常把视角拉远看一看。</p>
</li>
</ul>
<hr>
<h2 id="2-程序框架要点">2 程序框架要点</h2>
<ul>
<li>
<p>软件工程结构的分层思想永不灭。</p>
<p><img src="assets/分层思想.png" alt="分层思想" style="zoom:50%;" /></p>
</li>
<li>
<p>标准化、通用化和可靠性设计高于功能设计。</p>
</li>
<li>
<p>划分好文件、功能函数和所需变量。函数 &ldquo;低耦合，可重用，参数化，注释全&rdquo;，变量尽量用结构体打包；可重用意味着直接复制代码或者直接复制文件到另一个项目上直接就用。</p>
</li>
<li>
<p>功能增加裁剪的灵活性：做好预编译设置。方便于切换调试版本和执行版本，方便于切换行为模式，方便于剪裁功能块；功能剪裁用一个名字带&quot;_config&quot;的文件集中管理，供用户修改各种剪裁用的宏定义，就像总控台。</p>
</li>
<li>
<p>参数化设计的适应性：对比如协议解析、模块/功能数量增减、数据范围的变化适应等地方尽量写的通用，通过参数设定来改变运行时/编译时的功能灵活变化。</p>
</li>
<li>
<p>关于 MCU 的编写框架，我目前大抵就认我自己的开源项目 &ldquo;<a href="https://github.com/Staok/stm32_framework" target="_blank" rel="noopener noreffer">stm32_framework</a>&rdquo; 的吧，规范都对齐这个项目。</p>
<p>MCU C 的一些规范：</p>
<p><em>p.s 以下为项目 &ldquo;stm32_framework&rdquo; 编写时由经验形成的一部分规范，具体形式以此项目的源码和架构为准！</em></p>
<ul>
<li>
<p>本&quot;C 编写规范&quot;的全部规则都适用。</p>
</li>
<li>
<p>尽量利用硬件资源和外设资源，减少 cpu 负担。</p>
</li>
<li>
<p>系统外设功能的启用与否均用宏定义 SYSTEM_SUPPORT_XX 来管理剪裁。</p>
</li>
<li>
<p>RTOS任务函数均使用 os_task_xx_xx() 命名，属于&quot;os_task&quot;。</p>
</li>
<li>
<p>中断优先级分组选用分组4，即16级抢占优先级，不用0级响应优先级。</p>
</li>
<li>
<p>IO的低电平为有效电平，高电平截止或者无效；按键IO尽量都使用外部中断。</p>
</li>
<li>
<p>至少用一个定时器提供1ms或者10ms的时基，再用软件分频为 50ms/100ms/300ms/1s 等。</p>
</li>
<li>
<p>外设（Periph）和设备（Devices）分别初始化，外设的启停<strong>成对</strong>编写，命名统一。</p>
</li>
<li>
<p>通讯外设的发送和接收都使用中断，并尽量使用上DMA，以串口为例如下：</p>
<p>接收：（依时间间隔区分帧为例）</p>
<p>接收中断-&gt;打接收标志位，记当前时间（定时器计数器），比较上次接收的时间，启动DMA-&gt;接收缓冲区（足够大，大于2帧）-&gt;送解析函数。</p>
<p>发送：（类 lwip 的发送逻辑，事件驱动）</p>
<p>要发送的串放入 发送缓冲区，检查发送启动标志位是否就绪，若就绪就打 发送启动标志位-&gt;发送中断中，检测发送启动标志位，判断是否发送 发送缓冲区 的串，发完清此标志位，即设为就绪态。</p>
</li>
<li>
<p>等等等等。</p>
</li>
</ul>
</li>
<li>
<p>通讯尽量使用成熟的协议来封装数据。</p>
<p>以打包、解包形式进行通讯。鉴于见识有限，协议选择还需要广泛调研和商榷，以下仅为举例</p>
<ul>
<li>串口通讯协议可以上 Modbus。</li>
<li>CAN 通讯协议可以上 CANOpen。</li>
<li>TCP 通讯协议还有待确定，需要选择一个支持大带宽的。 可以用 json 格式封装数据。</li>
</ul>
<p>如果要自定串口等接口的通信协议，要考虑的点：</p>
<ul>
<li>一帧有确定的长度；</li>
<li>一帧有确定的帧头和帧尾，帧头和帧尾可以适当多加几个位增加容错；</li>
<li>保证一帧尽量连续传输，没有中断；</li>
<li>在有限确定的时间内完成发送；</li>
<li>数据的发送接收相关的函数与数据的打包和解析的相关函数，编写规范上应相互解耦，可重用；</li>
<li>接收完成标志位的置位大抵有两种方式：一个是判断有帧头和等待帧尾来判断为一帧，一个是从接收字节开始计时并在一定时间间隔没有接收数据后判断为一帧。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-代码格式化工具列举">3 代码格式化工具列举</h2>
<p><em>p.s 针对较乱的&quot;祖传代码&quot;做初步治疗使用。代码格式化工具还可以把代码中的 tab 符变成四个空格，这样，当代码在不同的编辑器中打开时不会产生格式错误，所以可以用 AStyle 自己定制一份配置文件，在每次码完代码之后顺手运行一下 AStyle 即可。</em></p>
<p>(TODO)下面部分条目尚未补全。</p>
<p>(TODO)查一查astyle配置文件的用法，按照自己的规范形式，写一个配置文件</p>
<ul>
<li>
<p>通用工具 AStyle：</p>
<p>​	配置文件：  <a href="https://github.com/MaJerle/c-code-style" target="_blank" rel="noopener noreffer">c-code-style仓库</a>中的 astyle-code-format.cfg 文件
​	AStyle官网：<a href="http://astyle.sourceforge.net/" target="_blank" rel="noopener noreffer">AStyle官网</a>
​	AStyle is a great piece of software that can help with formatting the code based on input configuration.
​	This repository contains <code>astyle-code-format.cfg</code> file which can be used with <code>AStyle</code> software as command line below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">astyle --options<span class="o">=</span><span class="s2">&#34;astyle-code-format.cfg&#34;</span> <span class="s2">&#34;input_path/*.c,*.h&#34;</span> <span class="s2">&#34;input_path2/*.c,*.h&#34;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>VS Code：在 VS Code 中搜索 AStyle 插件 即可。</p>
</li>
<li>
<p>MDK：关于“把代码中的 tab 符变成四个空格”，在 MDK 的 Edit 的 Configuration 中，把 “Insert spaces for tab” 都勾上即可。</p>
</li>
<li>
<p>IAR：</p>
</li>
<li>
<p>Eclipse：</p>
<p>​	配置文件：  <a href="https://github.com/MaJerle/c-code-style" target="_blank" rel="noopener noreffer">c-code-style仓库</a>中的 eclipse-ext-kr-format.xml
​	Repository contains <code>eclipse-ext-kr-format.xml</code> file that can be used with eclipse-based toolchains to set formatter options.
​	It is based on K&amp;R formatter with modifications to respect above rules.
​	You can import it within eclipse settings, <code>Preferences -&gt; LANGUAGE -&gt; Code Style -&gt; Formatter</code> tab.</p>
</li>
<li>
<p>Source Insight：</p>
</li>
<li>
<p>Notepad：关于“把代码中的 tab 符变成四个空格”，在 Notepad 的 设置 的 语言 中，把制表符框的 “替换为空格” 勾上即可。</p>
</li>
</ul>
<hr>
<h2 id="35-数据结构简述">3.5 数据结构简述</h2>
<p>数据结构 + 算法 = 程序；数据结构：现实问题的符合计算机存储的建模；算法：解决现实问题的步骤（符合有穷性，确定性，可行性等）。</p>
<p>一个软件项目，数据结构整理、设计的好，调用、修改和查询会特别方便，达到事半功倍的效果。</p>
<p>数据结构：</p>
<ul>
<li>
<p>按照逻辑关系：表示元素的连接关系</p>
<p>集合，线性（线性表，队，栈等），树状（一对多），图状（多对多）。</p>
</li>
<li>
<p>按照存储关系：</p>
<ul>
<li>顺序存储：如数组；位置连续，要提前申请空间；但会产生内存碎片，改动时前后要跟着变。</li>
</ul>
</li>
<li>
<p>链式结构：如链表，链式、离散、节点化，空间可动态分配，改动方便（改节点的指向）；但空间占用大，查找不便。</p>
<ul>
<li>索引存储：索引-数据 的结构。</li>
</ul>
</li>
<li>
<p>散列存储：暂略。</p>
</li>
</ul>
<p>数据运算：</p>
<ul>
<li>
<p>每个数据结构要实现的基本运算：增、删、改、查、判（判空，判满）、排（排序）、复（复位）。</p>
</li>
<li>
<p>更复杂的运算可用以上基本运算实现。</p>
</li>
</ul>
<hr>
<h2 id="4-普适规则general-rules">4 普适规则（General rules）</h2>
<ol>
<li>
<p>第一条，请您重视编写规范！可以有代码洁癖。</p>
</li>
<li>
<p>使用 C99 标准。</p>
</li>
<li>
<p>一个 tab 四个空格。</p>
</li>
<li>
<p>运算符前后空一格，给函数传递的多个变量之间在逗号后空一格，一元操作符后不要加空格，下面为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>    <span class="cm">/* i 永远滴神 */</span>
<span class="n">tempNum</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int32_t</span> <span class="n">tempNum</span> <span class="o">=</span> <span class="n">sys_example_sum</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">sys_example_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_data_struct</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">is_time_show</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>注释里，字母和数字的两边空一格，尽量用<code>/* ……… */</code>注释，而非<code>//...</code>，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 用 3 这个数字代替洋文 three 了解了吗 */</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>关于命名：</p>
<ul>
<li>
<p>变量和函数的命名都只用小写（尽量），宏定义使用全大写（尽量），并遵循 &ldquo;属什么 _ 是什么 _ 做什么&rdquo; 的命名形式，如：sys_irq_disable()，属于 sys 级别函数，是 irq 管理，做 dsiable 的功能。不要用晦涩的英文缩写甚至拼音就不用讲了吧。</p>
</li>
<li>
<p>具有互斥意义的变量或者动作相反的函数应该是用互斥词组命名，如：</p>
<blockquote>
<p>add/remove      begin/end             create/destroy               insert/delete
first/last            get/release            increment/decrement    put/get add/delete
lock/unlock      open/close             min/max                        old/new
start/stop         next/previous         source/target                 show/hide
send/receive   source/destination  copy/paste                    up/down</p>
</blockquote>
</li>
<li>
<p>不要使用单字节命名变量，但是允许使用 i， j， k 这样的作为局部循环变量。</p>
</li>
<li>
<p>文件统一采用小写命名。</p>
</li>
<li>
<p>关于函数、变量、宏定义等的命名看 <code>5 具体各部分的规范形式</code>章节。</p>
</li>
</ul>
</li>
<li>
<p>控制语句总加括号（即使分支执行语句只有一句），括号在竖方向对齐，用 tab 把层次分地清清楚楚，例如：（为了节省空间，下面示例用横向写~）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span><span class="p">(</span> <span class="p">)</span>             <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>    <span class="k">do</span>                <span class="k">switch</span> <span class="p">(</span><span class="n">check</span><span class="p">())</span>
<span class="p">{</span>                 <span class="p">{</span>                          <span class="p">{</span>                 <span class="p">{</span>
                                                                      <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
<span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">)</span>       <span class="p">}</span>                          <span class="p">}</span><span class="k">while</span><span class="p">(</span> <span class="p">);</span>                   <span class="n">fsm_do_a</span><span class="p">();</span>
<span class="p">{</span>                                                                         <span class="k">break</span><span class="p">;</span>
                                                                      <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
<span class="p">}</span><span class="k">else</span>                                                                     <span class="n">fsm_do_b</span><span class="p">();</span>
<span class="p">{</span>                                                                         <span class="k">break</span><span class="p">;</span>
                                                                      <span class="k">default</span><span class="o">:</span>
<span class="p">}</span>                                                                         <span class="k">break</span><span class="p">;</span>
                                                                <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>层次分明，多用 tab 划分层次关系（预编译代码也不例外），例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifdef _DEBUG
</span><span class="cp"></span>    <span class="cp">#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
</span><span class="cp">#else
</span><span class="cp"></span>    <span class="cp">#define DEBUGMSG(msg,date)
</span><span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>用 <code>if (check_func()) { ... }</code> 代替 <code>if (check_func() == 1)</code>，判断是否为 &lsquo;0&rsquo; 可以用后者的写法（或者用 <code>!check_func()</code>），判断 &lsquo;1&rsquo; 用前者写法。</p>
</li>
<li>
<p>判断指针是否为空只用 &ldquo;NULL&rdquo;，即 <code>void* ptr; if (ptr == NULL || ptr != NULL) { ... }</code>。</p>
</li>
<li>
<p>不用变长数组，用内存分配释放函数 <code>malloc()</code> 和 <code>free()</code>。</p>
</li>
<li>
<p>循环尽量用 <code>for(;;)</code> 替代 <code>while(1)</code> 等，无论有限次循环还是无限次循环，条件循环语句用后者。</p>
</li>
<li>
<p>长运算语句尽量多的用括号（每一步运算都用括号括起来），并做好空格增加可读性，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">temp</span> <span class="o">=</span> <span class="p">(</span> <span class="mh">0x7F</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">xByte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="p">);</span>
<span class="cp">#define MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>尽量减少数据传输过程中的拷贝。</p>
</li>
<li>
<p>大块内存使用请用内存管理（自实现的 malloc 和 free）。</p>
</li>
<li>
<p>每一个文件在最后留有至少一个空行。</p>
</li>
<li>
<p>对于 c 语言的文件，其 .h 文件的主体文件包含在下面的括号之内（标有 &ldquo;&hellip;&rdquo; 的位置）：</p>
<ul>
<li>
<p>私有变量不要放在 .h 里面声明，公有变量的声明（加 extern 修饰符）放在 .h 文件里面以供其他文件调用。</p>
</li>
<li>
<p>在 .c 文件中 include 自己对应的 .h 文件和需要用到的 .h 文件，不要引用多余的 .h 文件；.h 文件中同样只引用用到的头文件，但是头文件尽量写成无依赖的，这就考验整个系统的规划和设计。</p>
</li>
<li>
<p>如果一个模块包含了多个 .c 源文件，那么将它们放入同一个文件夹并用模块名命名，然后只用一个 .h 头文件声明接口。</p>
</li>
</ul>
<p>Every file (header or source) must include license (opening comment includes single asterisk as this must be ignored by doxygen).
Use the same license as already used by project/library.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifndef TEMPLATE_H
</span><span class="cp">#define TEMPLATE_H
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;all_other_custom_file.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 当 C 和 C++ 代码混合编译的时候，在下面两个 __cplusplus 标识的中间放 C 部分的声明代码 */</span>
<span class="cp">#ifdef __cplusplus
</span><span class="cp"></span>	<span class="k">extern</span> <span class="s">&#34;C&#34;</span>
	<span class="p">{</span>
<span class="cp">#endif </span><span class="cm">/* __cplusplus */</span><span class="cp">
</span><span class="cp"></span>
<span class="p">...</span> <span class="cm">/* C 部分的声明代码 */</span>

<span class="cp">#ifdef __cplusplus
</span><span class="cp"></span>	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __cplusplus */</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* TEMPLATE_H */</span><span class="cp">
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>&hellip;</p>
<p>更多网友总结的杂类细节规范、规则：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/auLsbmr7SKgoO05HykXpzQ" target="_blank" rel="noopener noreffer">学C/C++语言，32个必备修养！ (qq.com)</a>；</li>
<li></li>
<li>etc&hellip;</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-具体各部分的规范形式">5 具体各部分的规范形式</h2>
<h3 id="关于函数定义形式functions">关于函数定义形式（Functions）</h3>
<ul>
<li>
<p>小写；星号 * 靠近类型名一端；用&quot; _ &ldquo;分割语义；对齐以保持良好阅读性；</p>
</li>
<li>
<p>命名遵循 <code>属什么 _ 是什么 _ 做什么</code> 的形式；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span>            <span class="nf">sys_example_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span>     <span class="nf">sys_string_generater</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">my_struct_t</span><span class="o">*</span>    <span class="nf">sys_example_func</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">para1</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">para2</span><span class="p">);</span>
<span class="kt">void</span>            <span class="nf">fsm_state_set</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">fsm_ID</span><span class="p">);</span>
<span class="n">my_type_t</span>       <span class="nf">fsm_state_get</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">my_ptr_t</span><span class="o">*</span>       <span class="nf">menu_get_current_ptr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>函数的局部变量数量最好不超过 5-10 个，并且不要占用太多的内存/栈资源；</p>
</li>
<li>
<p>一个函数尽量只做一件事，否则划分为多个更小的函数；不要重复，保持各个代码块的独特性；</p>
</li>
<li>
<p><strong>低耦合，可重用，参数化，注释全！</strong></p>
</li>
<li>
<p>对函数的错误返回要做全面的处理；一般 返回 0 表示正确，返回其他表示错误，具体的值表示错误代号，可用定义了所有错误类型的枚举变量作为函数返回值类型，或者返回值 0 表示成功，正数表示失败，此正数可以表示错误代码；并设计专门的机制对错误标识做处理。</p>
</li>
<li>
<p>对函数的参数做合法性检查；检查指针；检查变量范围，变量有大小限制的，在注释里写明；在其他地方调用此变量的时候要进行检查或限幅：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 幅值系数，范围 0~1 */</span>
<span class="kt">float</span> <span class="n">wave_point_A</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>

<span class="cm">/* 检查：*/</span>
<span class="k">if</span><span class="p">(</span> <span class="n">wave_point_A</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="n">wave_point_A</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span> <span class="n">wave_point_A</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">wave_point_A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* 限幅：*/</span>
<span class="n">wave_point_A</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="mf">1.0f</span> <span class="o">:</span> <span class="n">wave_point_A</span><span class="p">;</span>
<span class="n">wave_point_A</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span>   <span class="o">:</span> <span class="n">wave_point_A</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>对于函数可能传入的参数是不定的任意类型，定义形参用 <code>void*</code> 修饰。</p>
</li>
<li>
<p>函数的嵌套不要过多，一般控制在最多 4 层。</p>
</li>
</ul>
<h3 id="关于变量定义形式variables">关于变量定义形式（Variables）</h3>
<ul>
<li>
<p>同类型的变量声明放在一行，变量定义时避免用函数返回值；</p>
</li>
<li>
<p>小写，星号 * 靠近类型名一端（除了一行多变量定义的情况），对齐以保持良好阅读性；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>用&rdquo; _ &ldquo;分割语义，命名遵循 &ldquo;<strong>属什么 _ 是什么 _ 做什么</strong>&rdquo; 的形式，意义明确，也不容易重名；</p>
</li>
<li>
<p>避免使用 stdbool.h 里的 &ldquo;true&rdquo; 或 &ldquo;false&rdquo;，用 &ldquo;1&rdquo; 或 &ldquo;0&rdquo; 代替；</p>
</li>
<li>
<p>数据类型，除了char、float 和 double，都使用 stdint.h 库里面的，统一起来；</p>
</li>
<li>
<p>合理的常用 const 修饰符，防止变量或指针在层层传递过程中被篡改，或者在定义的时候永远加上 const 修饰符，例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xByte</span><span class="p">;</span>      <span class="cm">/* xByte 的内容不能变 */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>   <span class="cm">/* 二者一样，都是 p 所指向的内容不能变 */</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span>                  <span class="cm">/* const 修饰的是 p ， p 不能修改，即地址不能修改，其指向的内容可以修改 */</span>
<span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span>            <span class="cm">/* p 所指向的内容和 p 地址本身都不能改变 */</span>
<span class="cm">/*
</span><span class="cm">p.s    char* c 与 char *c 没有任何区别
</span><span class="cm">       signed int 和 unsigned int 区别很大，前者是可以表达正负数的源码，后者是从 0 开始的正数或是一串参与逻辑运算的二进制
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>变量如果是低有效，变量名加尾缀&rdquo;_n&quot;，比如使能 en 是低有效（en 上面有一横），则命名为&quot;en_n&quot;；</p>
</li>
<li>
<p>明确全局变量的初始化顺序，系统启动阶段，使用全局变量前，要考虑到全局变量该在什么地方初始化，使用全局变量和初始化全局变量之间的时序关系一定要分析清楚；</p>
</li>
<li>
<p>明确变量的作用域，防止在预想的作用域外能够调用到具体的某个变量，降低模块间耦合度。</p>
</li>
<li>
<p>尽量减少不必要的数据类型转换。</p>
</li>
</ul>
<h3 id="关于结构体枚举和类型定义形式structures-enumerations-typedefs">关于结构体、枚举和类型定义形式（Structures, enumerations, typedefs）</h3>
<ul>
<li>
<p>适用 &ldquo;关于变量定义形式（Variables）&ldquo;里面的所有内容；</p>
</li>
<li>
<p>结构体和枚举可以用 typedef 修饰；</p>
</li>
<li>
<p>结构体里的成员小写，枚举里的所有成员大写；</p>
</li>
<li>
<p>结构体定义和类型定义后加 &ldquo;_t&rdquo; ；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">MY_ENUM_OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">MY_ENUM_TESTA</span><span class="p">,</span>
    <span class="n">MY_ENUM_TESTB</span><span class="p">,</span>
<span class="p">}</span><span class="n">my_enum_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">SIMPLE_struct_t</span>      <span class="k">struct</span> <span class="cm">/* 只用一次的结构体 */</span>        <span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>                           <span class="p">{</span>                                  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>                        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>                            <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>                       <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>                           <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">c</span><span class="p">;</span>                     <span class="kt">double</span> <span class="n">c</span><span class="p">;</span>                         <span class="kt">double</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>                          <span class="p">}</span><span class="n">abc</span><span class="p">;</span>                              <span class="p">}</span><span class="n">Simple_struct_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>结构体的实例化尽量用&quot;表格&quot;形式，并在每列头部写好注释，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">fsm_states_struct_t</span> <span class="n">fsm_XXX1_state</span><span class="p">[</span><span class="n">XXX1_State_MAX</span><span class="p">]</span> <span class="o">=</span> 	<span class="cm">/*定义描述名为‘fsm_XXX1’的状态机的状态图*/</span>
<span class="p">{</span>                                                 	      <span class="cm">/*跳转条件都初始化为0*/</span>
    <span class="cm">/*               状态               执行函数         跳转条件数量     各个条件跳转后的状态（注：根据跳转条件的优先级从高到低往下写）*/</span>
    <span class="p">{(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">XXX1_State_1</span><span class="p">,</span>   <span class="n">fsm_XXX1_state_1_Fun</span><span class="p">,</span>    <span class="mi">2</span><span class="p">,{</span>     <span class="p">{</span><span class="mi">0</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">XXX1_State_5</span>    <span class="p">},</span>
                                                                    <span class="p">{</span><span class="mi">0</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">XXX1_State_2</span>    <span class="p">},</span>    <span class="p">}},</span>

    <span class="p">{(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">XXX1_State_4</span><span class="p">,</span>   <span class="n">fsm_XXX1_state_4_Fun</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,{</span>     <span class="p">{</span><span class="mi">0</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">XXX1_State_5</span>    <span class="p">},</span>    <span class="p">}},</span>
<span class="p">};</span>
<span class="cm">/*或者*/</span>
<span class="n">Simple_struct_t</span> <span class="n">simple</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>函数指针定义（的类型定义）的写法形式如下，函数指针名加后缀 &ldquo;_ fn&rdquo;，类型定义函数指针加后缀 &ldquo;_ typedef _ fn&rdquo;：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 函数指针定义写法举例 */</span>
<span class="kt">unsigned</span> <span class="nf">char</span> <span class="p">(</span><span class="o">*</span><span class="n">sys_print_compile_time_fn</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">uint8_t</span> <span class="p">(</span><span class="o">*</span><span class="n">my_func_typedef_fn</span><span class="p">)(</span><span class="kt">uint8_t</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p2</span><span class="p">);</span>

<span class="cm">/* 用法 */</span>
<span class="kt">unsigned</span> <span class="nf">char</span> <span class="p">(</span><span class="o">*</span><span class="n">sys_print_compile_time_fn</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="nf">char</span> <span class="p">(</span><span class="o">*</span><span class="n">sys_print_compile_time_typedef_fn</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">is_print_compile_time</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">print_compile_time</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">is_print</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">is_print</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__TIME__</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">print_compile_date</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">is_print</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">is_print</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__DATE__</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* 用法1，给函数指针赋值 */</span>
    <span class="n">sys_print_compile_time_fn</span> <span class="o">=</span> <span class="n">print_compile_time</span><span class="p">;</span>

    <span class="cm">/* 用法2，定义一个函数指针变量，并赋值 */</span>
    <span class="n">sys_print_compile_time_typedef_fn</span> <span class="n">print_compile_time_fn</span><span class="p">;</span>
    <span class="n">print_compile_time_fn</span> <span class="o">=</span> <span class="n">print_compile_time</span><span class="p">;</span>

    <span class="cm">/* 调用 */</span>
    <span class="p">(</span><span class="o">*</span><span class="n">sys_print_compile_time_fn</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="n">print_compile_time_fn</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">print_compile_time_fn</span> <span class="o">=</span> <span class="n">print_compile_date</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">print_compile_time_fn</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="关于宏定义和预编译指令定义形式macros-and-preprocessor-directives">关于宏定义和预编译指令定义形式（Macros and preprocessor directives）</h3>
<ul>
<li>
<p>宏定义使用全大写（尽量），并遵循 &ldquo;属什么 _ 是什么 _ 做什么&rdquo; 的命名形式；</p>
</li>
<li>
<p>尽量把常数数字用宏定义代替；常量建议使用 const 定义来代替宏；前面这两句话实际是矛盾的，因地制宜吧，优化速度用前者，优化空间用后者；</p>
</li>
<li>
<p>对宏定义中的所有输入和输出（整个结果语句）用括号保护起来，长句用 <code>do{...}while(0)</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MY_MACRO(x)         ((x) * (x))
</span><span class="cp">#define MIN(x, y)           ((x) &lt; (y) ? (x) : (y))
</span><span class="cp"></span>
<span class="cp">#define SET_POINT(p, x, y)  do{ (p)-&gt;px = (x); (p)-&gt;py = (y); }while(0)
</span><span class="cp"></span><span class="cm">/*或者下句更好：*/</span>
<span class="cp">#define SET_POINT(p, x, y)  do{        \   </span><span class="cm">/* Backslash indicates statement continues in new line */</span><span class="cp">
</span><span class="cp"></span>        <span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">px</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>                 \
        <span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">py</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">);</span>                 \
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                             <span class="cm">/* 2 statements. No semicolon after while loop */</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>预编译指令语句使用 tab 标识好层次：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#if defined(XYZ)
</span><span class="cp"></span>    <span class="cm">/* Do when XYZ defined */</span>
    <span class="cp">#if defined(ABC)
</span><span class="cp"></span>        <span class="cm">/* do when ABC defined */</span>
    <span class="cp">#endif
</span><span class="cp">#else
</span><span class="cp"></span>    <span class="cm">/* Do when XYZ not defined */</span>
<span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="关于注释的形式comments">关于注释的形式（Comments）</h3>
<ol>
<li>
<p>注释里<strong>尽量写为什么</strong>，而不是把重点放在做了什么，虽然后者也很重要。</p>
</li>
<li>
<p>尽量使用 Doxygen 的注释语法，然后可以使用 Doxygen 这个软件从源码工程的注释中自动化生成软件工程的说明文档，注释写的全（包括文件和API等的描述等等）那么生成的文档也会很全。Documented code allows doxygen to parse and general html/pdf/latex output, thus it is very important to do it properly。目测目前我见过的用源文件产生手册的大型项目有：LWIP、FreeRTOS、ST HAL、CMSIS等，关于 ST HAL 库里面的注释形式的详细情况请看 “8 ST HAL 的编写形式” 章节！</p>
<ul>
<li>
<p>Doxygen 的注释语法规范。网上很多，这里列举几个：</p>
<ul>
<li><a href="https://www.cnblogs.com/schips/p/12200388.html" target="_blank" rel="noopener noreffer">Doxygen 注释语法规范 - 黄树超 - 博客园 (cnblogs.com)</a>。</li>
<li><a href="https://blog.csdn.net/u013178472/article/details/107164902" target="_blank" rel="noopener noreffer">C语言中的Doxygen注释模板_胡图图-CSDN博客_c语言函数注释模板</a>。</li>
</ul>
<p>需要注意的是，Doxygen 并不处理所有的注释，其重点关注与程序结构有关的注释，比如：文件、类、结构、函数、全局变量、宏等注释，而忽略函数内局部变量、代码等的注释。先从文件开始注释，然后是所在文件的全局函数、结构体、枚举变量、命名空间→命名空间中的类→成员函数和成员变量。</p>
</li>
<li>
<p>使用 Doxygen 生成文档的教程（这几个教程里面也包含有 Doxygen 的语法介绍）：</p>
<ul>
<li><a href="https://www.cnblogs.com/fkpj/p/4537145.html" target="_blank" rel="noopener noreffer">Doxygen给C程序生成注释文档 - on_the_road - 博客园 (cnblogs.com)</a>。</li>
<li><a href="https://blog.csdn.net/tuwenqi2013/article/details/70050849" target="_blank" rel="noopener noreffer">Doxygen生成注释文档_destiny的专栏-CSDN博客_doxygen生成文档</a>。</li>
<li><a href="https://www.cnblogs.com/silencehuan/p/11169084.html" target="_blank" rel="noopener noreffer">代码注释规范之Doxygen - silencehuan - 博客园 (cnblogs.com)</a>。</li>
</ul>
</li>
<li>
<p>Vs Code Doxygen 格式注释生成插件：<a href="https://blog.csdn.net/wang0huan/article/details/103107472/" target="_blank" rel="noopener noreffer">Vs code自动生成Doxygen格式注释_wang0huan的博客-CSDN博客</a>。</p>
<p><em>p.s 关于 Doxygen 文档的更多具体写法用时再详看进行手写，或者使用生成插件</em></p>
</li>
</ul>
</li>
<li>
<p>下面列举几种花哨的，其中有我自己“创造”的。函数定义的注释，主任务函数的注释，用于显眼！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*__________函数简述_____________*/</span>
<span class="cm">/********************************
</span><span class="cm">* 描述：函数详细描述
</span><span class="cm">* 参数：   1、第一个形参名 描述
</span><span class="cm">          2、第二个形参名 描述
</span><span class="cm">      ...
</span><span class="cm">* 返回：  返回值类型    描述
</span><span class="cm">********************************/</span>

<span class="cm">/*____________运行错误提示和打印______________________________*/</span>
<span class="cm">/********************************
</span><span class="cm">* 描述：表示某步骤运行有问题，串口提示，灯提示，声提示
</span><span class="cm">* 参数：   1、errmsg    错误或者警告信息
</span><span class="cm">          2、errid     故障代号
</span><span class="cm">          3、err_flag  错误类别（可选flag_Fault或flag_Warning）
</span><span class="cm">* 返回：   NULL
</span><span class="cm">********************************/</span>

<span class="cm">/*************\
</span><span class="cm">* Multi-line  *
</span><span class="cm">* comment     *
</span><span class="cm">\*************/</span>

<span class="cm">/*______________________\\\                               ///__________________________*
</span><span class="cm">*___________________________________外设初始化函数_______________________________________*
</span><span class="cm">*_______________________///                               \\\__________________________*/</span>
</code></pre></td></tr></table>
</div>
</div><p>文件说明注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*************************************************
</span><span class="cm">             开头这里放开源协议的描述源文
</span><span class="cm">Copyright © xxx Co., Ltd. 1998-2018. All rights reserved.
</span><span class="cm">File name:   文件名
</span><span class="cm">Author：     作者
</span><span class="cm">Version:     版本号
</span><span class="cm">Description: 用于详细说明此程序文件完成的主要功能，与其他模块
</span><span class="cm">或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系
</span><span class="cm">Others:      其它内容的说明
</span><span class="cm">Log:         修改日志，包括修改内容，日期，修改人等
</span><span class="cm">*************************************************/</span>


<span class="c1">// Doxygen 格式
</span><span class="c1"></span><span class="cm">/**
</span><span class="cm"> * @file main.c
</span><span class="cm"> * @author your name (you@domain.com)
</span><span class="cm"> * @version 0.1
</span><span class="cm"> * @date 2021-06-30
</span><span class="cm"> * @license GNU General Public License (GPL)
</span><span class="cm"> * @brief
</span><span class="cm"> * @attention
</span><span class="cm"> *
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>程序文件开头的版权信息写法列举：</p>
<blockquote>
<p>引用自<a href="https://download.csdn.net/download/UltraCoder/841110" target="_blank" rel="noopener noreffer">软件中声明版权的写法-专业指导文档类资源-CSDN下载</a>，侵删。</p>
<p>正确的格式应该是：Copyright [dates] by [author/owner]</p>
<p>© 通常可以代替Copyright, 但是不可以用(c)。 All Rights Reserved 在某些国家曾经是必须的，但是现在在大多数国家，都不是法律上必须有的字样。</p>
<p>参见下面几个正确的格式：</p>
<p>©1995-2004 Macromedia, Inc. All rights reserved.</p>
<p>©2004 Microsoft Corporation. All rights reserved.</p>
<p>Copyright © 2004 Adobe Systems Incorporated. All rights reserved.</p>
<p>©1995-2004 Eric A. and Kathryn S. Meyer. All Rights Reserved.</p>
<p>请注意标点符号和大小写的用法，这也是专业精神的一种体现。</p>
<p>现在流行some rights reserved：creativecommons.org</p>
<p>some rights reserved 和copyright 本身并不矛盾，但是其中的界限更多是一个道德问题，真正的保留一部分权力，是指给浏览者fair use 的权利，fair use的界定也决不是随便乱用，或者抄袭。</p>
<p>甚至说，除了copyright, 还有copyleft,它的定义是为了程序员开发能够共享源代码的一个方式，英文里free, 并不仅仅是免费。 而且这种的源码公开免费使用，和版权也一点都不冲突。请大家不要误解。</p>
</blockquote>
</li>
</ol>
<h3 id="其他常用写法汇集不定期更新">其他常用写法汇集（不定期更新）</h3>
<p>将一些少见的并且技巧性、灵活性较高的写法进行罗列。</p>
<h4 id="实用技巧">实用技巧</h4>
<ul>
<li>
<p>置位和清位，常用于嵌入式开发。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">reg_temp</span> <span class="o">=</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="mh">0x20E0084</span><span class="p">);</span>

<span class="cm">/* 置位的标准写法 */</span>
<span class="cm">/* 下句表示把 内存中 0x20E0084 位置的 第1、2、5、14位进行置1，其他位不变 */</span>
<span class="o">*</span><span class="n">reg_temp</span> <span class="o">|=</span> <span class="p">(</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>

<span class="cm">/* 清位的标准写法 */</span>
<span class="cm">/* 下句表示把 内存中 0x20E0084 位置的 第0、3位进行清0，其他位不变 */</span>
<span class="o">*</span><span class="n">reg_temp</span> <span class="o">&amp;=</span> <span class="p">(</span> <span class="o">~</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

 <span class="cm">/* 读寄存器 */</span>
<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">reg_temp</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>创建内存地址上连续区域的结构体，常用于嵌入式开发。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">URXD</span><span class="p">;</span>            <span class="cm">/**&lt; UART Receiver Register, offset: 0x00 */</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">RESERVED_0</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">UTXD</span><span class="p">;</span>            <span class="cm">/**&lt; UART Transmitter Register, offset: 0x40 */</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">UCR1</span><span class="p">;</span>            <span class="cm">/**&lt; UART Transmitter Register, offset: 0x44 */</span>
<span class="p">}</span> <span class="n">Periph_x_Type</span><span class="p">;</span>

<span class="cm">/* Periph_x 这个外设的寄存器的基地址为 0x2020000 */</span>
<span class="cp">#define Periph_x_BASE      (0x2020000u)
</span><span class="cp"></span>
<span class="cm">/* 设置结构体 Periph_x 的地址为 Periph_x_BASE */</span>
<span class="cp">#define Periph_x           ((Periph_x_Type *)Periph_x_BASE)
</span><span class="cp"></span>
<span class="cm">/* 读取和设置寄存器（这里以置位举例） */</span>
<span class="n">Periph_x</span><span class="o">-&gt;</span><span class="n">UCR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>关于连接符 “#” 和 “##” 的使用说明，这两个都是预处理命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*  ## 左右语句原样连接符（concatenator）
</span><span class="cm">    hello##world 就是 helloworld，直接原样拼接，这并不是字符串，而是预编译时候的字符的替换和拼接 */</span>
<span class="cm">/* 例1： */</span>
<span class="cp">#define A(x)  T_##x
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* 等效于int T_1 = 10; */</span>

<span class="cm">/*  # 转字符串符，字符串化操作（Stringfication） */</span>
<span class="cm">/* 例2： */</span>
<span class="cp">#define WARN_IF(EXP)               \
</span><span class="cp">    do{                            \
</span><span class="cp">       printf(&#34;Waring:&#34;#EXP&#34;\n&#34;);  \
</span><span class="cp">      }while(0)
</span><span class="cp"></span><span class="n">WARN_IF</span><span class="p">(</span><span class="kt">int</span> <span class="n">devide</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;);</span>
<span class="cm">/* 会打印：Waring:int devide = 0; */</span>

<span class="cm">/* 例3： */</span>
<span class="cp">#define paster( n ) printf( &#34;token&#34; #n &#34; = %d&#34;, token##n )
</span><span class="cp"></span><span class="n">paster</span><span class="p">(</span> <span class="mi">9</span> <span class="p">)</span>   <span class="cm">/* 即 printf( &#34;token&#34; &#34;9&#34; &#34; = %d&#34;, token9 ); */</span>

<span class="cm">/* 字符串连接，多个双引号的字符串放在一块就是了 */</span>
<span class="n">printf</span><span class="p">(</span> <span class="s">&#34;token&#34;</span> <span class="s">&#34;9&#34;</span> <span class="s">&#34; = %d&#34;</span><span class="p">,</span> <span class="n">token9</span> <span class="p">);</span>
 <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="n">PATH</span> <span class="s">&#34;/file&#34;</span><span class="p">,</span><span class="n">flags</span> <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>变长参数函数定义的使用说明。变长参数函数性能比较低而且难维护，非必要不建议使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 参考 https://blog.csdn.net/ericbar/article/details/79558827 */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;    /* 用于支持变长参数函数 */</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 定义的函数必须至少有一个固定参数。这个函数包含了两个固定参数，和指示变长参数开始的省略号 */</span>
<span class="kt">void</span> <span class="nf">variable_argument</span><span class="p">(</span><span class="kt">int</span> <span class="n">fix_argument1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fix_argument2</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="cm">/* 先定义一个 va_list 类型的变量，比如 ptr，它指向参数列表的首地址； */</span>
    <span class="n">va_list</span> <span class="n">va_ptr</span><span class="p">;</span>
    <span class="cm">/* 用 va_start() 宏初始化ptr，va_start()的第二个参数是variable_argument()的第一个可变参数的前一个参数，其实就是最后一个固定参数； */</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">va_ptr</span><span class="p">,</span> <span class="n">fix_argument2</span><span class="p">);</span>
    <span class="cm">/* 用 va_arg() 依次地 返回可变的参数，它的第二个参数是指定要获取的变参类型； */</span>
    <span class="kt">int</span> <span class="n">first</span>  <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">va_ptr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">va_ptr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">third</span>  <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">va_ptr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">four</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">va_ptr</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">five</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">va_ptr</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span> <span class="cm">/* 对于浮点数类型这里必须是 double 类型，否则编译器警告 */</span>
    <span class="cm">/* 最后用 va_end() 宏结束可变参数的获取，便可以在下面使用获取到的各个参数； */</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">va_ptr</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;first is %d, second is %d, third is %d, four is %s, five is %f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span><span class="p">,</span> <span class="n">four</span><span class="p">,</span> <span class="n">five</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">variable_argument</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="mf">3.14159</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 会打印：first is 5, second is 2, third is -5, four is Hello, five is 3.141590 */</span>

<span class="cm">/* C99 以及之后可以在宏定义中使用变长参数 */</span>
<span class="cp">#define debug(...) printf(__VA_ARGS__)
</span><span class="cp">#define debug(format, ...) fprintf(stdout, format, __VA_ARGS__)
</span><span class="cp">#define debug(format, args...) fprintf(stdout, format, args)
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>若要修改函数的形参的值那么请用一级指针，若要修改形参一级指针的值那么用二级指针，以此类推。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 引用自：https://blog.csdn.net/c243311364/article/details/109619361 */</span>
<span class="cm">/* 正确的 */</span>
<span class="kt">void</span> <span class="nf">GetMemery</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*申请1024个int大小*/</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;malloc failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">GetMemery</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;address of p is %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 错误的 */</span>
<span class="cp">#define SIZE 10
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">EncryptUpdata</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">SIZE</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">EncryptUpdata</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">UseCTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>C 有一个鲜为人知的运算符叫 ”趋向于”（ “&ndash;&gt;” ）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 引自 https://www.zhihu.com/question/27417946/answer/36591120 */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 会打印出：9 8 7 6 5 4 3 2 1 0 */</span>

<span class="cm">/* while (x --&gt; 0) 可以理解为 while (x-- &gt; 0) */</span>

<span class="cm">/* 或者这样写更快速递减，两个自减符号 &#34;--&#34;，即每次减 2，下面语句会打印出：8 6 4 2 */</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;----</span> <span class="n">x</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* stackoverflow 上面对这个操作符的讨论：
</span><span class="cm">https://stackoverflow.com/questions/1642028/what-is-the-operator-in-c-c/1642035#1642035 */</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/147039093" target="_blank" rel="noopener noreffer">快速范围判断：再来一种新写法 - 知乎 (zhihu.com)</a>。</p>
</li>
<li>
<p>scanf 的正则表达式用法举例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">scanf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="p">[</span><span class="o">^</span><span class="p">,]</span><span class="err">”</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// This doesn’t scrap the comma 这个不去掉逗号
</span><span class="c1"></span><span class="n">scanf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="p">[</span><span class="o">^</span><span class="p">,],</span><span class="err">”</span><span class="p">,</span><span class="n">a</span><span class="p">);</span> <span class="c1">// This one scraps the comma
</span><span class="c1"></span><span class="n">scanf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="p">[</span><span class="o">^</span><span class="err">\</span><span class="n">n</span><span class="p">]</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// It will read until you meet  &#39;\n&#39;, then trashes the &#39;\n&#39;
</span><span class="c1"></span><span class="n">scanf</span><span class="p">(</span><span class="err">“</span><span class="o">%*</span><span class="n">s</span> <span class="o">%</span><span class="n">s</span><span class="err">”</span><span class="p">,</span> <span class="n">last_name</span><span class="p">);</span> <span class="c1">// last_name is a variable
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="奇技淫巧的黑魔法">奇技淫巧的黑魔法</h4>
<p>OS Kernel，游戏引擎，编译器之类的，会用到不少 C 语言的黑魔法。你会惊叹于各种人类智慧的精华！！！前方高能预警！！！</p>
<ul>
<li>
<p>从结构体成员的地址获取结构体地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 引自 https://blog.csdn.net/c243311364/article/details/110129208 ，其中有详解 */</span>
<span class="cm">/* 示例程序 */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* offsetof，获取结构体元素 MEMBER 在 结构体 TYPE 中的偏移量，字节为单位 */</span>
<span class="cp">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</span><span class="cp"></span><span class="cm">/**
</span><span class="cm"> * container_of - cast a member of a structure out to the containing structure
</span><span class="cm"> * @ptr:        the pointer to the member.
</span><span class="cm"> * @type:       the type of the container struct this is embedded in.
</span><span class="cm"> * @member:     the name of the member within the struct.
</span><span class="cm"> *
</span><span class="cm"> */</span>
<span class="cp">#define container_of(ptr, type, member) ({                      \
</span><span class="cp">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
</span><span class="cp">        (type *)( (char *)__mptr - offsetof(type,member) );})
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">test_struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">f1</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">test_struct</span> <span class="o">*</span><span class="n">test_struct</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">test_struct</span> <span class="n">init_struct</span> <span class="o">=</span><span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="mf">12.3</span><span class="p">};</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr_ch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_struct</span><span class="p">.</span><span class="n">ch</span><span class="p">;</span>
    <span class="n">test_struct</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ptr_ch</span><span class="p">,</span><span class="k">struct</span> <span class="n">test_struct</span><span class="p">,</span><span class="n">ch</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;test_struct-&gt;num =%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">test_struct</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;test_struct-&gt;ch =%c</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">test_struct</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;test_struct-&gt;ch =%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">test_struct</span><span class="o">-&gt;</span><span class="n">f1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">执行结果：</span>
<span class="n">test_struct</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span><span class="mi">12</span>
<span class="n">test_struct</span><span class="o">-&gt;</span><span class="n">ch</span> <span class="o">=</span><span class="n">a</span>
<span class="n">test_struct</span><span class="o">-&gt;</span><span class="n">ch</span> <span class="o">=</span><span class="mf">12.300000</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>代码增殖（黑魔法，慎用）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 源文：https://github.com/geekan/cowry/blob/master/code/c/darkmagic/x_macro_simple.c */</span>
<span class="cm">/* 它定义了一个字段 OFPACT(...)，然后再通过宏 OFPACTS 来批量生成此字段，替换其中每个输入，狂拽酷炫！ */</span>
<span class="cm">/* 引用网友一句：学名叫做x macro，是节省冗余代码利器，好处是非常好用，跟机关枪一样；坏处是懂的人不多，大家看到一个没有被索引的ofpact_get_GROUP很容易就进入痴呆状态。 */</span>

<span class="cp">#define OFPACTS                                                         \
</span><span class="cp">    </span><span class="cm">/* Output. */</span><span class="cp">                                                       \
</span><span class="cp">    OFPACT(OUTPUT,          ofpact_output,      ofpact, &#34;output&#34;)       \
</span><span class="cp">    OFPACT(GROUP,           ofpact_group,       ofpact, &#34;group&#34;)
</span><span class="cp"></span>
<span class="cp">#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                              \
</span><span class="cp">    BUILD_ASSERT_DECL(offsetof(struct STRUCT, ofpact) == 0);            \
</span><span class="cp">                                                                        \
</span><span class="cp">    enum { OFPACT_##ENUM##_RAW_SIZE                                     \
</span><span class="cp">           = (offsetof(struct STRUCT, MEMBER)                           \
</span><span class="cp">              ? offsetof(struct STRUCT, MEMBER)                         \
</span><span class="cp">              : sizeof(struct STRUCT)) };                               \
</span><span class="cp">                                                                        \
</span><span class="cp">    static inline struct STRUCT *                                       \
</span><span class="cp">    ofpact_get_##ENUM(const struct ofpact *ofpact)                      \
</span><span class="cp">    {                                                                   \
</span><span class="cp">        ovs_assert(ofpact-&gt;type == OFPACT_##ENUM);                      \
</span><span class="cp">        return ALIGNED_CAST(struct STRUCT *, ofpact);                   \
</span><span class="cp">    }
</span><span class="cp"></span><span class="n">OFPACTS</span>
<span class="cp">#undef OFPACT
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>达夫设备（Duff&rsquo;s Device）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*这个回答 https://www.zhihu.com/question/27417946/answer/36572141
</span><span class="cm">  如是说到：
</span><span class="cm">  看以为不能通过编译，后来以为是滥用编译器，但其实是完全符合C标准的，而且真实项目里有用。Google 上搜“duff&#39;s device filetype:c”和“duff&#39;s device filetype:h”都能找到很多。LLVM 还专门有个用例测试对 Duff&#39;s device 的支持：SingleSource/Regression/C/DuffsDevice.c，还很开心哒地说“Guess what, it does.  :)”
</span><span class="cm">
</span><span class="cm">  另有：https://blog.csdn.net/kingmax26/article/details/5252657 达夫设备（Duff&#39;s Device）的详细说明
</span><span class="cm">  这篇文章内说，达夫设备的拷贝数据运行效率的编译体积虽大，但是比循环拷贝写法效率高的多（至少 8 倍）。
</span><span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">7</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">count</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">do</span><span class="p">{</span>   <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">7</span> <span class="o">:</span>       <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">6</span> <span class="o">:</span>       <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">5</span> <span class="o">:</span>       <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">4</span> <span class="o">:</span>       <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span> <span class="o">:</span>       <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span> <span class="o">:</span>       <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">1</span> <span class="o">:</span>       <span class="o">*</span> <span class="n">to</span> <span class="o">++</span> <span class="o">=</span> <span class="o">*</span> <span class="n">from</span> <span class="o">++</span><span class="p">;</span>
                   <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>用字符画表述 1 6位的 16 进制数组，<a href="https://www.zhihu.com/question/27417946/answer/36585519" target="_blank" rel="noopener noreffer">C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)</a>，要注意在最后加上下面三句，再也用不到的宏定义要及时清理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#undef X
</span><span class="cp">#undef _
</span><span class="cp">#undef s
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>大段数据单独放一个文件，用预编译命令引用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 引自 https://www.zhihu.com/question/27417946/answer/37339776 */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&#34;values.txt&#34;</span><span class="cp">
</span><span class="cp"></span><span class="p">};</span>
<span class="cm">/* values.txt 中的内容为：
</span><span class="cm">1,2,3,4,5,
</span><span class="cm">6,7,8,9,0, */</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>两数交换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>求取对数 和 判断一个数是否 2 的幂。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 实现取 2 为底的对数，计算以 2 为底，x 的对数，即 2 ^ Log_2(x) = x */</span>
<span class="cp">#define LOG2(x) (((x &amp; 0xaaaaaaaa) ? 1 : 0) + ((x &amp; 0xcccccccc) ? 2 : 0) + \
</span><span class="cp">                ((x &amp; 0xf0f0f0f0) ?  4 : 0) + ((x &amp; 0xff00ff00) ? 8 : 0) + \
</span><span class="cp">                ((x &amp; 0xffff0000) ? 16 : 0))
</span><span class="cp"></span>
<span class="cm">/* 实现取 10 为底的对数，计算以 10 为底，x 的对数，即 10 ^ Log_10(x) = x */</span>
<span class="kt">int</span> <span class="nf">log10</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mh">0xffff0000</span><span class="p">)</span> <span class="p">{</span><span class="n">result</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mh">0x0000ff00</span><span class="p">)</span> <span class="p">{</span><span class="n">result</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mh">0x000000f0</span><span class="p">)</span> <span class="p">{</span><span class="n">result</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mh">0x0000000c</span><span class="p">)</span> <span class="p">{</span><span class="n">result</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mh">0x00000002</span><span class="p">)</span> <span class="p">{</span><span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 求 log_2(x) 也相当于求 log_10(x)/log_10(2) */</span>

<span class="cm">/* 判断是否 2 的幂，来自 Linux kernel */</span>
<span class="cp">#define is_power_of_2(n) ((n) != 0 &amp;&amp; ((n) &amp; ((n) - 1)) == 0)
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>快速浮点数开平方（牛顿求根法导出的开平方算法，一个详解<a href="https://wenku.baidu.com/view/a7f9bfbff7ec4afe05a1df35.html" target="_blank" rel="noopener noreffer">世界上最快的浮点开方算法 - 百度文库 (baidu.com)</a>）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="nf">Q_rsqrt</span><span class="p">(</span> <span class="kt">float</span> <span class="n">number</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">threehalfs</span> <span class="o">=</span> <span class="mf">1.5F</span><span class="p">;</span>

    <span class="n">x2</span> <span class="o">=</span> <span class="n">number</span> <span class="o">*</span> <span class="mf">0.5F</span><span class="p">;</span>
    <span class="n">y</span>  <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
    <span class="n">i</span>  <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">long</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>                       <span class="c1">// evil floating point bit level hacking
</span><span class="c1"></span>    <span class="n">i</span>  <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">);</span>               <span class="c1">// what the fuck?
</span><span class="c1"></span>    <span class="n">y</span>  <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">float</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
    <span class="n">y</span>  <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span> <span class="n">threehalfs</span> <span class="o">-</span> <span class="p">(</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="p">)</span> <span class="p">);</span>   <span class="c1">// 1st iteration
</span><span class="c1"></span>    <span class="c1">//      y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
</span><span class="c1"></span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>32 位 Bit 翻转，所有的 Bit。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">reverse</span><span class="p">(</span><span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xaaaaaaaa</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x55555555</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xcccccccc</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xf0f0f0f0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x0f0f0f0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xff00ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x00ff00ff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
    <span class="k">return</span><span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li></li>
</ul>
<p>更多奇技淫巧，没有写明 “实用” 的大概率仅为图个新鲜：</p>
<ul>
<li><a href="https://github.com/gurugio/book_cprogramming" target="_blank" rel="noopener noreffer">gurugio/book_cprogramming: Framework and Plugin design in C (github.com)</a>，总结 C 技巧，大概比较实用。</li>
<li><a href="https://www.zhihu.com/question/27417946/answer/1253126563" target="_blank" rel="noopener noreffer">C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)</a>，特殊写法实现一些计算加速，比较实用。</li>
<li><a href="https://coolshell.cn/articles/10975.html" target="_blank" rel="noopener noreffer">一个“蝇量级” C 语言协程库 | 酷 壳 - CoolShell</a>，介绍 Adam 的 protothreads 这个协程库，用 switch 实现 yield 语义。</li>
<li><a href="http://www.gowrikumar.com/c/index.php" target="_blank" rel="noopener noreffer">C PUZZLES, Some interesting C problems (gowrikumar.com)</a>，C programming questions/puzzles，做了这些题，会学到很多的奇技。</li>
<li><a href="http://uguu.org/sources.html" target="_blank" rel="noopener noreffer">code (uguu.org)</a>，可编译的源码字符画；<a href="https://www.zhihu.com/question/27417946/answer/36555570" target="_blank" rel="noopener noreffer">C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)</a>，源码字符画 CP。</li>
</ul>
<h4 id="用-c-实现高阶特性">用 C 实现高阶特性</h4>
<ul>
<li>
<p>将 C 语言变成支持动态类型的函数式编程语言，<a href="http://libcello.org/" target="_blank" rel="noopener noreffer">Cello • High Level C (libcello.org)</a>。</p>
<p>Github 页：<a href="https://github.com/orangeduck/Cello" target="_blank" rel="noopener noreffer">orangeduck/Cello: Higher level programming in C (github.com)</a>。</p>
<p>受 Python 等高级语言的启发，实现了通用数据结构/动态函数/类等等，比较全名和丰富。</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/robert-cai/archive/2013/12/04/3456785.html" target="_blank" rel="noopener noreffer">lw_oopc（C语言的面向对象） - robert_cai - 博客园 (cnblogs.com)</a>，作者做了大量的工作实现了 c 语言的封装、多态、继承这三种面向对象特征，还实现了所谓的虚函数。<a href="https://zhuanlan.zhihu.com/p/25997811" target="_blank" rel="noopener noreffer">OOPC-C面向对象 - 知乎 (zhihu.com)</a>。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/27417946/answer/1412733677" target="_blank" rel="noopener noreffer">C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)</a>，介绍 Morn 库，用 C 实现 “函数重载” 和 “泛型”。</p>
</li>
</ul>
<hr>
<h2 id="6-常用宏定义">6 常用宏定义</h2>
<p><em>p.s 以下有一些在 C 标准库里有实现，资源紧张可以用下面的宏定义，不紧张推荐全部使用标准库</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 宏定义的形式规范
</span><span class="cm">    宏定义使用全大写（尽量），并遵循 &#34;属什么 _ 是什么 _ 做什么&#34; 的命名形式；
</span><span class="cm">    尽量把常数数字用宏定义代替；
</span><span class="cm">    对宏定义中的所有输入和输出（整个结果语句）用括号保护起来，长句用 do{ }while(0);
</span><span class="cm">*/</span>

<span class="cm">/* 打印一个变量名及其值 */</span>
<span class="cp">#define PRINT_HEX_VAR(var)  printf(&#34;%s: 0x%08X\n&#34;, #var, var);
</span><span class="cp"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">program_flag</span> <span class="o">=</span> <span class="mh">0xAABBCCDD</span><span class="p">;</span>
<span class="n">PRINT_HEX_VAR</span><span class="p">(</span><span class="n">program_flag</span><span class="p">);</span>

<span class="cm">/* 打印一个数组 */</span>
<span class="cp">#define ARR_SIZE(arr)               (sizeof(arr)/sizeof(*arr)) </span><span class="c1">// 返回数组元素的个数
</span><span class="c1"></span><span class="cp">#define PRINT_DIGIT_ARR(arr)    do{\
</span><span class="cp">                                    printf(&#34;%s: &#34;, #arr); \
</span><span class="cp">                                    for(int i=0; i &lt; ARR_SIZE(arr); i++) \
</span><span class="cp">                                        printf(&#34;%d &#34;, arr[i]);\
</span><span class="cp">                                        printf(&#34;\n&#34;);\
</span><span class="cp">                                  }while(0)
</span><span class="cp"></span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="n">PRINT_DIGIT_ARR</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>

<span class="cm">/* 定义变量。__typeof__(x) 用于获取变量 x 的类型 */</span>
<span class="cp">#define var(left, right) __typeof__(right) left = (right)
</span><span class="cp"></span><span class="n">var</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1LL</span><span class="p">);</span> <span class="cm">/* 用法举例，这里相当于 long long s = 1LL; */</span>

<span class="cm">/* 获取大于 a 的最近的 2^n 倍的且是 size 的整数倍的值，可计算申请内存时要对齐的某字节数 */</span>
<span class="cp">#define ROUNDUP(a, size) (((a) &amp; ((size)-1)) ? (1+((a) | ((size)-1))) : (a))
</span><span class="cp"></span><span class="cm">/* 获取大于 size 的最近的且是 val_size 倍数的值，可用于 Flas h的 page 大小对齐的时候 */</span>
<span class="cp">#define VAL_ROUNDUP(size, val_size)     (((size)+val_size-1)/val_size*val_size)
</span><span class="cp"></span>
<span class="cm">/* 得到指定地址上的一个字节或字 */</span>
<span class="cp">#define MEM_B( x ) ( *( (unsigned char*) (x) ) )
</span><span class="cp">#define MEM_W( x ) ( *( (unsigned short*) (x) ) )
</span><span class="cp"></span>
<span class="cm">/* 求最大值和最小值 */</span>
<span class="cp">#define MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )
</span><span class="cp">#define MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )
</span><span class="cp"></span><span class="cm">/* 但是上句还是有可能报错，比如：
</span><span class="cm">double xx = 1.0;
</span><span class="cm">double yy = MIN(xx++, 1.5);
</span><span class="cm">printf(&#34;xx=%f, yy=%f\n&#34;,xx,yy);
</span><span class="cm">
</span><span class="cm">以下放大招了，看看 GNU 的实现...用下面这句就不会出错，那当然了...
</span><span class="cm">#define MIN(A,B)	({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a &lt; __b ? __a : __b; })
</span><span class="cm">*/</span>

<span class="cm">/* 得到一个field在结构体(struct)中的偏移量 */</span>
<span class="cp">#define FPOS( type, field ) ( (unsigned long) &amp;(( type *) 0)-&gt; field )
</span><span class="cp"></span>
<span class="cm">/* 得到一个结构体中field所占用的字节数 */</span>
<span class="cp">#define FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )
</span><span class="cp"></span>
<span class="cm">/* 按照LSB格式把两个字节转化为一个 unsigned short */</span>
<span class="cp">#define FLIPW( ray ) ( (((unsigned short) (ray)[0]) * 256) + (ray)[1] )
</span><span class="cp"></span>
<span class="cm">/* 按照LSB格式把一个 unsigned short 的 val 转化为两个字节 ray[0] 和 ray[1] */</span>
<span class="cp">#define FLOPW( ray, val ) \
</span><span class="cp">    (ray)[0] = ((val) / 256); \
</span><span class="cp">    (ray)[1] = ((val) &amp; 0xFF)
</span><span class="cp"></span>
<span class="cm">/* 得到一个字的高位和低位字节 */</span>
<span class="cp">#define WORD_LO(xxx) ((unsigned char) ((unsigned short)(xxx) &amp; 255))
</span><span class="cp">#define WORD_HI(xxx) ((unsigned char) ((unsigned short)(xxx) &gt;&gt; 8))
</span><span class="cp"></span>
<span class="cm">/* 返回一个比X大的最接近8的倍数的数 */</span>
<span class="cp">#define RND8( x ) ((((x) + 7) / 8 ) * 8 )
</span><span class="cp"></span>
<span class="cm">/* 将一个字母转换为大写 */</span>
<span class="cp">#define UPCASE( c ) ( ((c) &gt;= &#39;a&#39; &amp;&amp; (c) &lt;= &#39;z&#39;) ? ((c) - 0x20) : (c) )
</span><span class="cp"></span>
<span class="cm">/* 判断一个字符是不是10进制的数字 */</span>
<span class="cp">#define DECCHK( c ) ((c) &gt;= &#39;0&#39; &amp;&amp; (c) &lt;= &#39;9&#39;)
</span><span class="cp"></span>
<span class="cm">/* 判断一个字符是不是16进制的数字 */</span>
<span class="cp">#define HEXCHK( c ) ( ((c) &gt;= &#39;0&#39; &amp;&amp; (c) &lt;= &#39;9&#39;) ||\
</span><span class="cp">                      ((c) &gt;= &#39;A&#39; &amp;&amp; (c) &lt;= &#39;F&#39;) ||\
</span><span class="cp">                      ((c) &gt;= &#39;a&#39; &amp;&amp; (c) &lt;= &#39;f&#39;) )
</span><span class="cp"></span>
<span class="cm">/* 带防止溢出数据类型最大值的自加一 */</span>
<span class="cp">#define INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))
</span><span class="cp"></span>
<span class="cm">/* 圆周率 */</span>
<span class="cp">#define M_PI  3.14159265358979323846f
</span><span class="cp"></span>
<span class="cm">/* 在编译时就能够进行条件检查的断言，而不是在运行时进行。下面是个Linux Kernel的例子 */</span>
<span class="cp">#define BUILD_BUG_ON_ZERO(e)  (sizeof(struct{int : -!!(e);}))
</span><span class="cp">#define BUILD_BUG_ON_NULL(e)  ((void*)sizeof(struct{int : -!!(e);}))
</span><span class="cp"></span><span class="cm">/* Force a compilation error if condition is true */</span>
<span class="cp">#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2 * !!(condition)]))
</span><span class="cp"></span>
<span class="cm">/* 检测a和b是不是同一类型，不是同一类型编译不过 */</span>
<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>

<span class="cm">/*Author: MaxwellXyao*/</span>
<span class="cp">#define BIT(n)                  (1 &lt;&lt; (n))               </span><span class="c1">//位mask
</span><span class="c1"></span><span class="cp">#define bit_SetTrue(x,mask)     ((x) |= (mask))          </span><span class="c1">//该位设置为真
</span><span class="c1"></span><span class="cp">#define bit_SetFalse(x,mask)    ((x) &amp;= ~(mask))         </span><span class="c1">//该位设置为假
</span><span class="c1"></span><span class="cp">#define bit_Toggle(x,mask)      ((x) ^= (mask))          </span><span class="c1">//位切换
</span><span class="c1"></span><span class="cp">#define bit_IsTrue(x,mask)      (((x) &amp; (mask)) != 0)    </span><span class="c1">//该位是否真
</span><span class="c1"></span><span class="cp">#define bit_IsFalse(x,mask)     (((x) &amp; (mask)) == 0)    </span><span class="c1">//该位是否假
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 编译时一些信息的字符串，用内建宏调试
</span><span class="cm">__FILE__		表示当前所在文件名的字符串
</span><span class="cm">__LINE__		表示当前所在行的整形数字
</span><span class="cm">__FUNCTION__     表当前所在函数的函数名字字符串
</span><span class="cm">__DATE__		表示编译时的 月/日/年 字符串信息
</span><span class="cm">__TIME__		表示编译时的 时:分:秒 字符串信息
</span><span class="cm">__STDC__		如果实现是标准的，则是十进制常量1，否则为其他
</span><span class="cm">
</span><span class="cm">如下面，Debug 时输出文件名、行号、函数名等 */</span>
<span class="cp">#define DEBUG_INFO() fprintf(stderr,&#34;[DEBUG]%s:%d %s\n&#34;, __FILE__, __LINE__, __FUNCTION__)
</span><span class="cp"></span>
<span class="cm">/* 参考 https://blog.csdn.net/cleverhorse/article/details/84655543
</span><span class="cm">   将编译时间转换为int类型作为时间戳 __DATE__ __TIME__ 转INT类型
</span><span class="cm">*/</span>
<span class="cp">#define YEAR ((((__DATE__[7]-&#39;0&#39;)*10+(__DATE__[8]-&#39;0&#39;))*10+ \
</span><span class="cp">              (__DATE__[9]-&#39;0&#39;))*10+(__DATE__[10]-&#39;0&#39;))
</span><span class="cp"></span>
<span class="cp">#define MONTH (__DATE__[2]==&#39;n&#39;?1 \
</span><span class="cp">              :__DATE__[2]==&#39;b&#39;?2 \
</span><span class="cp">              :__DATE__[2]==&#39;r&#39;?(__DATE__[0]==&#39;M&#39;?3:4) \
</span><span class="cp">              :__DATE__[2]==&#39;y&#39;?5 \
</span><span class="cp">              :__DATE__[2]==&#39;n&#39;?6 \
</span><span class="cp">              :__DATE__[2]==&#39;l&#39;?7 \
</span><span class="cp">              :__DATE__[2]==&#39;g&#39;?8 \
</span><span class="cp">              :__DATE__[2]==&#39;p&#39;?9 \
</span><span class="cp">              :__DATE__[2]==&#39;t&#39;?10 \
</span><span class="cp">              :__DATE__[2]==&#39;v&#39;?11:12)
</span><span class="cp"></span>
<span class="cp">#define DAY ((__DATE__[4]==&#39; &#39;?0:__DATE__[4]-&#39;0&#39;)*10+ \
</span><span class="cp">              (__DATE__[5]-&#39;0&#39;))
</span><span class="cp"></span>
<span class="cm">/* 距 2000 年 过去多少天 */</span>
<span class="cp">#define DATE_AS_INT (((YEAR - 2000) * 12 + MONTH) * 31 + DAY)
</span><span class="cp"></span>
<span class="cp">#define HOUR ((__TIME__[0]-&#39;0&#39;)*10+(__TIME__[1]-&#39;0&#39;))
</span><span class="cp">#define MINUTE ((__TIME__[3]-&#39;0&#39;)*10+(__TIME__[4]-&#39;0&#39;)) </span><span class="cm">/* 24h 制 */</span><span class="cp">
</span><span class="cp">#define SECOND ((__TIME__[6]-&#39;0&#39;)*10+(__TIME__[7]-&#39;0&#39;))
</span><span class="cp"></span>
<span class="cm">/* 距 2000 年 过去多少分钟 */</span>
<span class="cp">#define TIME_AS_INT_NO_SEC (( DATE_AS_INT * 24 + HOUR ) * 60 + MINUTE)
</span><span class="cp"></span><span class="cm">/* 距 2000 年 过去多少秒 */</span>
<span class="cp">#define TIME_AS_INT ((( DATE_AS_INT * 24 + HOUR ) * 60 + MINUTE) * 60 + SECOND)
</span></code></pre></td></tr></table>
</div>
</div><p>更多实用内容：这两个总结一下写在这里，表明引用</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/141541643" target="_blank" rel="noopener noreffer">【C语言笔记】认识认识#pragma、#error指令 - 知乎 (zhihu.com)</a>；</li>
<li><a href="https://zhuanlan.zhihu.com/p/141542463" target="_blank" rel="noopener noreffer">C语言、嵌入式中一些实用的宏技巧 - 知乎 (zhihu.com)</a>。</li>
</ul>
<hr>
<h2 id="7-c-标准库的使用">7 C 标准库的使用</h2>
<p><em>p.s 资源不紧张推荐全部使用标准库（除了 malloc 和 free）</em></p>
<ul>
<li>
<p>最常用的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
</code></pre></td></tr></table>
</div>
</div><p>参考这几个地方齐活了：</p>
<ul>
<li>
<p><a href="https://gitee.com/zhaixuebuluo/glibc_man_cn" target="_blank" rel="noopener noreffer">C标准库函数新编手册: C语言标准库函数API使用手册中文版 (gitee.com)</a>。</p>
<p>上面的 gitee 仓库很优秀，已经离线到了本地<code>./额外文档/zhaixuebuluo-glibc_man_cn-master.zip</code>中。</p>
</li>
<li>
<p><a href="https://blog.csdn.net/best_xiaolong/article/details/108957688" target="_blank" rel="noopener noreffer">C语言常用标准库解读_张巧龙的博客-CSDN博客</a>。</p>
</li>
<li>
<p><a href="https://www.runoob.com/cprogramming/c-standard-library.html" target="_blank" rel="noopener noreffer">C 标准库 – 参考手册 | 菜鸟教程 (runoob.com)</a>。</p>
</li>
</ul>
</li>
<li>
<p>可能会用到的：</p>
<pre><code>  #include &lt;time.h&gt;      // 提供储存时间的结构体和计算时间差等函数；

  #include &lt;limits.h&gt;    // 这两个库包含了各种变量类型的最大、最小值等信息；
  #include &lt;float.h&gt;
</code></pre>
</li>
<li>
<p>不常用的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#include &lt;stdarg.h&gt;    // 用于函数定义变长形参；
#include &lt;assert.h&gt;    // 提供了一个名为 assert 的宏，仅在 debug 模式有效，判断一个表达式是否为 FALSE(即 0)，如果是则报告错误并终止程序；
#include &lt;errno.h&gt;     // 被其他库文件调用，提供一些返回值定义；
#include &lt;locale.h&gt;    // 定义了特定地域的设置，比如日期格式和货币符号；
#include &lt;setjmp.h&gt;
#include &lt;signal.h&gt;
#include &lt;stddef.h&gt;
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h2 id="8-st-hal-的编写形式">8 ST HAL 的编写形式</h2>
<p>相关文章：</p>
<ul>
<li>STM32 注释风格参考：<a href="https://blog.csdn.net/wanshiyingg/article/details/51923352" target="_blank" rel="noopener noreffer">STM32注释风格参考_wanshiyingg的专栏-CSDN博客</a>。</li>
</ul>
<p>ST HAL 的各个文件编写风格非常一致，下面以 F4 SPI 为例：</p>
<p>.h文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="err">——————————————————————————开头——————————————————————————</span>
<span class="cm">/**
</span><span class="cm">  ******************************************************************************
</span><span class="cm">  * @file    stm32f4xx_hal_spi.h
</span><span class="cm">  * @author  MCD Application Team
</span><span class="cm">  * @brief   Header file of SPI HAL module.
</span><span class="cm">  ******************************************************************************
</span><span class="cm">  * @attention
</span><span class="cm">  ...一大段版权说明和开源协议说明
</span><span class="cm">  *
</span><span class="cm">  ******************************************************************************
</span><span class="cm">  */</span>

<span class="cm">/* Define to prevent recursive inclusion -------------------------------------*/</span>
<span class="cp">#ifndef STM32F4xx_HAL_SPI_H
</span><span class="cp">#define STM32F4xx_HAL_SPI_H
</span><span class="cp"></span>
<span class="cp">#ifdef __cplusplus
</span><span class="cp"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
<span class="cp">#endif
</span><span class="cp"></span>
<span class="err">——————————————————————————中间部分，挑重点——————————————————————————</span>
<span class="cm">/* Includes ------------------------------------------------------------------*/</span>
<span class="cp">#include</span> <span class="cpf">&#34;stm32f4xx_hal_def.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="err">这添加各种</span> <span class="n">Includes</span>

<span class="err">这里所有</span> <span class="err">@</span><span class="n">addtogroup</span> <span class="err">的部分省略，这是添加分组，为了</span> <span class="n">Doxygen</span> <span class="err">组织文档层级结构</span>
<span class="err">其格式：</span>
<span class="cm">/** @addtogroup STM32F2xx_StdPeriph_Driver
</span><span class="cm">
</span><span class="cm">  * @{
</span><span class="cm">
</span><span class="cm">  */</span>

<span class="p">...</span>

<span class="cm">/**
</span><span class="cm">
</span><span class="cm">  * @}
</span><span class="cm">
</span><span class="cm">  */</span>

<span class="cm">/* Exported types ------------------------------------------------------------*/</span>
<span class="err">这定义各种结构体、枚举和数据类型定义，都符合</span> <span class="n">Doxygen</span> <span class="err">形式，定义开头注释，每一个成员注释</span>
<span class="cm">/* Exported constants --------------------------------------------------------*/</span>
<span class="err">这添加各种常量，宏定义</span> <span class="err">#</span><span class="n">define</span> <span class="err">以上结构体应填入的选项名</span>
<span class="cm">/* Exported macros -----------------------------------------------------------*/</span>
<span class="err">这添加个各种宏定义，控制模块和各个子模块启停、</span>
	<span class="err">得到标志置位和清除标志位等等的宏定义等等，启动和停止成对出现</span>
<span class="cm">/* Exported variables --------------------------------------------------------*/</span>
<span class="err">共有变量</span>
<span class="cm">/* Exported functions --------------------------------------------------------*/</span>
<span class="err">这添加给其他文件和用户调用的</span><span class="n">API声明</span>
<span class="cm">/* Private types -------------------------------------------------------------*/</span>
<span class="cm">/* Private variables ---------------------------------------------------------*/</span>
<span class="cm">/* Private constants ---------------------------------------------------------*/</span>
<span class="cm">/* Private macros ------------------------------------------------------------*/</span>
<span class="err">这添加</span><span class="p">.</span><span class="n">c文件的API内部使用的私有宏定义</span><span class="err">，其他文件和用户不得调用</span>
<span class="cm">/* Private functions ---------------------------------------------------------*/</span>

<span class="err">——————————————————————————结尾——————————————————————————</span>

<span class="cp">#ifdef __cplusplus
</span><span class="cp"></span><span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* STM32F4xx_HAL_SPI_H */</span><span class="cp">
</span><span class="cp"></span><span class="cm">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span>
<span class="err">最后加一个</span> <span class="n">COPYRIGHT</span>
</code></pre></td></tr></table>
</div>
</div><p>.c文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="err">——————————————————————————开头——————————————————————————</span>
<span class="cm">/**
</span><span class="cm">  ******************************************************************************
</span><span class="cm">  * @file    stm32f4xx_hal_spi.c
</span><span class="cm">  * @author  MCD Application Team
</span><span class="cm">  * @brief   SPI HAL module driver.
</span><span class="cm">  ...一大段本文件简述
</span><span class="cm">  *
</span><span class="cm">  @verbatim
</span><span class="cm">  ==============================================================================
</span><span class="cm">                        ##### How to use this driver #####
</span><span class="cm">  ==============================================================================
</span><span class="cm">  ...很长的一段使用说明
</span><span class="cm">  @endverbatim
</span><span class="cm">  ...很长的一段附录表格和几个@note
</span><span class="cm">  ******************************************************************************
</span><span class="cm">  * @attention
</span><span class="cm">  ...一大段版权说明和开源协议说明
</span><span class="cm">  *
</span><span class="cm">  ******************************************************************************
</span><span class="cm">  */</span>

<span class="err">——————————————————————————中间部分，挑重点——————————————————————————</span>
<span class="cm">/* Includes ------------------------------------------------------------------*/</span>

<span class="err">这里所有</span> <span class="err">@</span><span class="n">addtogroup</span> <span class="err">的部分省略，这是添加分组，为了</span> <span class="n">Doxygen</span> <span class="err">组织文档层级结构</span>

<span class="cp">#ifdef HAL_SPI_MODULE_ENABLED
</span><span class="cp"></span><span class="err">模块预编译控制，方便工程剪裁</span>

<span class="cm">/* Private typedef -----------------------------------------------------------*/</span>
<span class="err">私有类型定义</span>
<span class="cm">/* Private defines -----------------------------------------------------------*/</span>
<span class="err">私有常数宏定义</span>
<span class="cm">/* Private macros ------------------------------------------------------------*/</span>
<span class="err">私有宏定义</span>
<span class="cm">/* Private variables ---------------------------------------------------------*/</span>
<span class="err">私有变量</span>
<span class="cm">/* Private function prototypes -----------------------------------------------*/</span>
<span class="cm">/* Private functions ---------------------------------------------------------*/</span>
<span class="err">私有</span><span class="n">API</span><span class="err">，仅本文件内部调用，外部文件和用户不可调用</span>
<span class="cm">/* Exported functions --------------------------------------------------------*/</span>
<span class="err">共有</span><span class="n">API</span><span class="err">，供外部文件和用户调用</span>

<span class="cp">#endif </span><span class="cm">/* HAL_SPI_MODULE_ENABLED */</span><span class="cp">
</span><span class="cp"></span>
<span class="err">——————————————————————————结尾——————————————————————————</span>
<span class="cm">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span>
<span class="err">最后加一个</span> <span class="n">COPYRIGHT</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="9-本文参考源">9 本文参考源</h2>
<ol>
<li><a href="https://github.com/MaJerle/c-code-style" target="_blank" rel="noopener noreffer">c-code-style</a>；</li>
<li><a href="https://jishuin.proginn.com/p/763bfbd35604" target="_blank" rel="noopener noreffer">20个成熟软件中常用的宏定义</a>；</li>
<li><a href="https://www.stmcu.com.cn/" target="_blank" rel="noopener noreffer">ST HAL</a>；</li>
<li><a href="https://www.zhihu.com/question/440136872" target="_blank" rel="noopener noreffer">知乎问题页：程序员们有什么好的编程习惯？</a>；</li>
<li>【正点原子】嵌入式Linux C代码规范化V1.0；</li>
<li>本人长时摸索的经验。</li>
<li>其他。</li>
</ol>
<p><em>p.s 本 C 规范系广泛约取而成，参考并非照搬。</em></p>
<p><em>p.s 此文件系业余整理而成，远不及&quot;Google C/C++编程规范&rdquo;、&ldquo;华为编程规范&quot;等文件的专业程度。</em></p>
<h2 id="10-大厂规范和名设计模式">10 大厂规范和名设计模式</h2>
<p>以下强烈建议空闲时认真学一学。</p>
<h3 id="大厂规范">大厂规范</h3>
<ol>
<li><em><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener noreffer">Google C++风格指南</a></em>；</li>
<li><em>华为 C语言编程规范</em>
<ul>
<li><em><a href="https://blog.csdn.net/m0_38106923/article/details/105042594" target="_blank" rel="noopener noreffer">华为C语言编程规范（精华总结）</a></em>；</li>
<li><em><a href="https://zhuanlan.zhihu.com/p/346160926" target="_blank" rel="noopener noreffer">C语言编程规范（一）（华为标准要求）</a></em>；</li>
<li><em><a href="https://zhuanlan.zhihu.com/p/346689923" target="_blank" rel="noopener noreffer">C语言编程规范（二）（华为标准要求）</a></em>；</li>
</ul>
</li>
<li><em><a href="https://www.misra.org.uk/Publications/tabid/57/Default.aspx" target="_blank" rel="noopener noreffer">MISRA C Coding Standard</a></em>；</li>
<li>[CodingStyle] Linux 内核源代码目录下的 Documentation/CodingStyle 文件。中文：<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/process/coding-style.html" target="_blank" rel="noopener noreffer">Linux 内核代码风格 — The Linux Kernel documentation</a>。</li>
</ol>
<h3 id="设计定律原则和模式">设计定律、原则和模式</h3>
<ol>
<li><a href="https://www.cnblogs.com/zzy0471/p/coderule.html" target="_blank" rel="noopener noreffer">比较优雅地编码（良好的命名，清晰的结构和不差的算法）</a>；</li>
<li><a href="https://github.com/nusr" target="_blank" rel="noopener noreffer">nusr</a>/<a href="https://github.com/nusr/hacker-laws-zh" target="_blank" rel="noopener noreffer">hacker-laws-zh 对开发人员有用的定律、理论、原则和模式</a>；</li>
<li><a href="https://zhuanlan.zhihu.com/p/352074106" target="_blank" rel="noopener noreffer">如何正确地使用设计模式？ - 知乎 (zhihu.com)</a>；</li>
<li><a href="https://blog.csdn.net/feixiaoxing/article/details/7294900" target="_blank" rel="noopener noreffer">C语言和设计模式（总结篇）_平凡的程序员-CSDN博客_c设计模式</a>；</li>
<li><a href="https://blog.csdn.net/super828/article/details/84311440" target="_blank" rel="noopener noreffer">23种设计模式全解析_CodeAllen的博客-CSDN博客</a>；</li>
<li><a href="https://blog.csdn.net/zcshoucsdn/article/details/80217199" target="_blank" rel="noopener noreffer">架构与设计 之一 C 嵌入式设计模式（Design Patterns for Embedded Systems in C）的学习记录_itexp-CSDN博客</a>；</li>
<li><a href="https://www.cnblogs.com/lumang/p/9032692.html" target="_blank" rel="noopener noreffer">书籍推荐《调试九法-软硬件错误的排查之道》 - lumang - 博客园 (cnblogs.com)</a>；</li>
<li>etc。</li>
</ol>
<h3 id="提高代码运行效率">提高代码运行效率</h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5mzknQZyZU2bimO6oZUnyQ" target="_blank" rel="noopener noreffer">提高代码运行效率</a>；</li>
<li>etc。</li>
</ul>
<h2 id="11-尾记">11 尾记</h2>
<h3 id="开光保护">开光保护</h3>
<p><a href="https://blog.csdn.net/vbirdbest/article/details/78995793" target="_blank" rel="noopener noreffer">佛祖保佑永无BUG 神兽护体 代码注释(各种版本)</a></p>
<p><a href="https://www.sohu.com/a/116621959_430930" target="_blank" rel="noopener noreffer">厉害了word程序猿，进寺庙给服务器开光保永不宕机</a></p>
<p>以下是效果图。</p>
<p><img src="assets/QQ图片20210219140545.jpg" alt="QQ图片20210219140545" style="zoom: 80%;" /></p>
<p><img src="assets/QQ图片20210219140542.jpg" alt="QQ图片20210219140542" style="zoom: 50%;" /></p>
<h2 id="署名">署名</h2>
<ul>
<li>编辑整理：<a href="https://github.com/Staok" target="_blank" rel="noopener noreffer">Github 页</a>，<a href="https://www.zhihu.com/people/xuhaoyang" target="_blank" rel="noopener noreffer">知乎页</a></li>
<li>发表时间：始于 2021.2 且无终稿</li>
<li>首发平台：https://zhuanlan.zhihu.com/p/350839857 and <a href="https://github.com/Staok/coding-style-and-more">https://github.com/Staok/coding-style-and-more</a></li>
<li>遵循协议：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener noreffer">CC-BY-NC-SA 4.0</a></li>
<li>其他说明：
<ol>
<li>本文件是“瞰百易”计划的一部分，尽量遵循 <a href="https://github.com/Staok/Please-stay-in-the-future" target="_blank" rel="noopener noreffer">“二项玻”定则</a>，致力于与网络上碎片化严重的现象泾渭分明（这中二魂&hellip;）！</li>
<li>本文系广泛撷取、借鉴和整理，侵删。本文适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！</li>
<li>转载请注明作者及出处。整理不易，请多支持。</li>
</ol>
</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-07-02</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="http://Staok.github.io/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/" data-title="【规范】C &amp; MCU 编写规范和其他" data-hashtags="规范,软件"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://Staok.github.io/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/" data-hashtag="规范"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Linkedin" data-sharer="linkedin" data-url="http://Staok.github.io/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"><i class="fab fa-linkedin fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://Staok.github.io/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/" data-title="【规范】C &amp; MCU 编写规范和其他" data-ralateuid="u/3585238893"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E8%A7%84%E8%8C%83/">规范</a>,&nbsp;<a href="/tags/%E8%BD%AF%E4%BB%B6/">软件</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/" class="prev" rel="prev" title="科幻小说《请留在未来》注解篇"><i class="fas fa-angle-left fa-fw"></i>科幻小说《请留在未来》注解篇</a>
            <a href="/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="next" rel="next" title="【主线剧情02】ARM Linux 基础学习记录">【主线剧情02】ARM Linux 基础学习记录<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.84.4">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":20},"comment":{},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
