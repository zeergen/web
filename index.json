[{"categories":["主线剧情"],"content":"介绍 ARM 和 i.MX6ULL SoC 的基本内容，以及GCC、Makefile等","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"ARM \u0026 i.MX6ULL 基础学习记录 编辑整理 by Qitas 本文大部分内容摘自“100ask imx6ull”开发板的配套资料（如《IMX6ULL裸机开发完全手册》等等），侵删。进行了精髓提取，方便日后查阅。过于基础的内容不会在此提及。如有错误恭谢指出！ ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"目录 [TOC] ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"ARM \u0026 Linux 相关 p.s 汇编基本指令和 ARM 的汇编启动代码看 “ARM异常处理 及其模板” 文件夹里的 startup.s 文件。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"cpsr 寄存器详情 运行模式 Cortex-A7架构的运行模式有9种。运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。大多数的程序都运行在用户模式，用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。但是用户模式是不能直接进行切换的，用户模式下需要借助异常来完成模式切换，当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完成处理器模式切换。 模式 描述 User 用户模式，非特权模式，大部分程序运行的时候就处于此模式 Sys(System) 系统模式，用于运行特权级的操作系统任务 FIQ 快速中断模式，进入 FIQ 中断异常 IRQ 一般中断模式 ABT(Abort) 数据访问终止模式，用于虚拟存储以及存储保护 SVC(Supervisor) 超级管理员模式，供操作系统使用 UND(Undef) 未定义指令终止模式 MON(Monitor) 用于安全扩展模式 Hyp 用于虚拟化扩展 几点说明： 板子上电时，CPU处于SVC模式，它用的是SVC模式下的寄存器。 程序运行时发生了中断，CPU进入IRQ模式，它用的IRQ模式下的寄存器。 CPU发生某种异常时，比如读取内存出错，它会进入ABT模式，使用ABT模式下的寄存器来处理错误。 每一种模式对应使用的寄存器 几点说明： 如果某个程序处于 FIQ 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_fiq。 如果某个程序处于 SVC 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_svc。 除了 FIQ 模式，寄存器 R0~R12 都是通用的，即模式之间切换前这些寄存器的值应该保存。 因为ARM处理器是三级流水线：取指-\u003e译码-\u003e执行，循环执行，所以程序计数器 R15(PC) = 当前执行指令地址 + 4 * 2 个字节。 未定义指令异常的个别用法：在某些系统中，代码可能包含用于协处理器（例如VFP协处理器）的指令，但是系统中不存在相应的VFP硬件。另外，VFP硬件有可能无法处理特定指令，而是想调用软件来对其进行仿真。或者，可能会禁用VFP硬件，采用异常处理，以便可以启用它，然后重新执行指令。使用未定义的指令，可以实现一些仿真器。比如在你的芯片中，它并未支持某条硬件除法指令，但是你还可以在代码中使用它。当CPU执行这条指令时会发生异常，在异常处理函数中，你用软件来实现该指令的功能。对于不是特别设置的未定义指令，在异常处理函数中不能处理它时，通常做法是记录适当的调试信息，并杀死对应的应用程序。在某些情况下，未定义指令异常的另一个用途是实现用户断点：调试器去修改代码，替换断点位置的指令为一条未定义指令。 SVC异常的个别用法：软中断 swi 指令可以触发此异常，获得 SVC 权限。在Linux中对文件的open/read/write等APP层的系统函数，它的本质都是执行SVC指令，从而进入Linux内核中预设的SVC异常处理函数，在内核里操作文件。可以使用寄存器或者操作码中某个字段将参数传递给SVC处理程序。 程序状态寄存器 cpsr 所有运行模式都共用一个 CPSR 物理寄存器，因此 CPSR 可以在任何模式下被访问。当特定异常中断发生时，备份程序状态寄存器 SPSR 用来保存 CPSR 的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。 各个位的说明： N(bit31)：当两个有符号整数运算(补码表示)时，结果用N表示，N=1/0 表示 负数/正数。 Z(bit30)：对于 CMP 指令，Z=1 表示进行比较的两个数大小相等。 C(bit29)： 在加法指令中，当结果产生了进位，则C=1，表示无符号数运算发生上溢，其它情况下 C=0； 在减法指令中，当运算中发生借位，则C=0，表示无符号数运算发生下溢，其它情况下 C=1； 对于包含移位操作的非加/减法运算指令，C 中包含最后一次溢出的位的数值； 对于其它非加/减运算指令，C 位的值通常不受影响。 V(bit28)：对于加/减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V=1 表示符号位溢出，通常其他位不影响 V 位。 Q(bit27)：仅 ARM v5TE_J 架构支持，表示饱和状态，Q=1/0 表示累积饱和/累积不饱和。 IT[1:0] (bit26:25) 和 IT[7:2] (bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。 J(bit24) 和 T(bit5)：控制指令执行状态，表明本指令是ARM指令还是Thumb指令。{J,T} = b00 为 ARM；= b01 为 Thumb；= b11 为 ThumbEE；= b10 为 Jazelle。 GE[3:0] (bit19:16)：SIMD 指令有效，大于或等于。 E(bit9)：大小端控制位，E=1/0 表示大/小端模式。 A(bit8)：禁止异步中断位，A=1 表示禁止异步中断。 I(bit7)：I=1/0 代表 禁止/使能 IRQ。 F(bit6)：F=1/0 代表 禁止/使能 FIQ。 M[4:0]：运行模式控制位，如表 M[4:0] 运行模式 10000 User 模式 10001 FIQ 模式 10010 IRQ 模式 10011 Supervisor(SVC)模式 10110 Monitor(MON)模式 10111 Abort(ABT)模式 11010 Hyp(HYP)模式 11011 Undef(UND)模式 11111 System(SYS)模式 在用户模式下，无法改变处理器模式的M位[4：0]来切换模式和A，I和F位来使能或者禁止异步中止、IRQ和FIQ。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:1","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"大小端模式 大端模式（Big-endian），是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:2","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"汇编程序调用 C 程序详情 在 C 程序和 ARM 汇编程序之间相互调用时必须遵守 ATPCS 规则，其是基于 ARM 指令集和 THUMB 指令集过程调用的规范，规定了调用函数如何传递参数，被调用函数如何获取参数，以何种方式传递函数返回值。 寄存器 R0~R15 在 ATPCS 规则的使用 在函数中，通过寄存器 R0~R3 来传递参数，被调用的函数在返回前无需恢复寄存器 R0~R3 的内容。 在函数中，通过寄存器 R4~R11 来保存局部变量。 寄存器 R12 用作函数间 scratch 寄存器。 寄存器 R13 用作栈指针，记作 SP ，在函数中寄存器 R13 不能用做其他用途，寄存器 SP 在进入函数时的值和退出函数时的值必须相等。 寄存器 R14 用作链接寄存器，记作 LR ，它用于保存函数的返回地址，如果在函数中保存了返回地址，则 R14 可用作其它的用途。 寄存器 R15 是程序计数器，记作 PC ，它不能用作其他用途。 汇编程序向 C 程序函数传递参数 当参数小于等于 4 个时，使用寄存器 R0~R3 来进行参数传递。 当参数大于 4 个时，前四个参数按照上面方法传递，剩余参数传送到栈中，入栈的顺序与参数顺序相反，即最后一个参数先入栈。 C 程序函数返回结果给汇编程序 结果为一个 32 位的整数时，通过寄存器 R0 返回。 结果为一个 64 位整数时，通过 R0 和 R1 返回，依此类推。 结果为一个浮点数时，通过浮点运算部件的寄存器 f0，d0 或 s0 返回。 结果为一个复合的浮点数时，通过寄存器 f0-fN 或者 d0~dN 返回。 对于位数更多的结果，通过调用内存来传递。 当 C 程序从一个函数跳转到另一个函数时，会先把源函数的 CPU 的寄存器和函数内的局部变量都入栈，当跳回时再出栈，这一过程的汇编代码是当 C 程序编译成汇编时被编译器自动添加。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:3","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"GCC 命令详情 要使用 gcc 等编译器或交叉编译器，应先把编译器的可执行文件放在某个目录，然后给系统环境变量加此路径（Win平台为添加环境变量，Linux为使用EXPORT 命令，或者在 bashrc 文件中添加，具体步骤在此不提），对于 Make 工具同理。 C/C++ 程序文件的编译过程图示： 预处理（-E）：gcc -E main.c -o main.i 编译（-S）：gcc -S main.c -o main.s 汇编（-c）：gcc -c main.c -o main.o 完成整个编译（-o filename）： 单文件：gcc main.c -o main 多文件：gcc main.c sub.c add.c -o ouput，其中 main.c 里面 include 了 sub.h 和 add.h。 输出所有警告（-Wall）：gcc main.c -Wall -o main.c 头文件选项： -I dirname：将 dirname 目录加入到头文件搜索目录列表中。当 gcc 在默认的路径中没有找到头文件时，就到本选项指定的目录中去找。例如 main.c 目录中有 Inc 文件夹，里面有 test.h 文件，并且 main.c 中调用了 test.h 文件，则命令为：gcc main.c -I inc -o main 添加库文件搜索目录（-L dirname），加载库名选项（-l name），静态库选项（-static）等选型略。 代码优化选项： -O 或 -O1：基本优化，使代码执行的更快。 -O2 或 -O3：产生尽可能小和快的代码。如无特殊要求，不建议使用 O2 以上的优化。 -Os：生成最小的可执行文件，适合用于嵌入式软件。 产生能被 GDB 调试器使用的调试信息：gcc main.c -g -o main。GDB 的命令行调试指令详情略（包括运行、单步执行、加删查断点、打印变量等命令）。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:4","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Makefile 简述和模板 解决问题：针对包含超多文件的工程；自动搜索被添加目录中的所有被调用的文件；在第二次全编译时，没有修改的文件只链接而不重复编译节省时间。 基本语法：（注，注释必须单独一行，不能写在语句后面） 基本格式 目标（target）：依赖（prerequisites） [Tab]命令（command） target：需要生成的目标文件。 prerequisites：生成该 target 所依赖的一些文件。 command：生成该目标需要执行的命令。 在命令前加 “@” 符号，在 make 时不显示此条命令的执行过程，只显示结果。 变量赋值（ =、:=、?=、+= ） # Makefile 中的变量是字符串。 PARA = 100ask # = # 相当于 PARA 的指针给 CURPARA，之后 PARA 的值变，CURPARA 的值会跟着变。 CURPARA = $(PARA) # := # 仅赋值，之后 PARA 的值变，CURPARA 的值不会跟着变。 CURPARA := $(PARA) # ?= # 使用“?=”给变量设置值时，如果这个变量之前没有被设置过，那么“?=”才会起效果；如果曾经设置过这个变量，那么“?=”不会起效果。相当于函数定义时的 weak 修饰符。 # += # 这样的结果是OBJ的值为：”main.o，add.o，sub.o“。说明“+=”用作与变量的追加。 OBJ = main.o add.o OBJ += sub.o 自动变量（ $@、$^、$\u003c ） CC = gcc OBJ = main.o add.o sub.o output: $(OBJ) $(CC) -o $@ $^ # $@：表示规则中的目标（target），即 output # $^：表示规则中的所有依赖文件（All prerequisites），即 main.o add.o sub.o main.o: main.c $(CC) -c $\u003c # $\u003c：表示规则中的第一个依赖文件（The first prerequisites），即 main.o 右边的第一个依赖，即 main.c add.o: add.c $(CC) -c $\u003c sub.o: sub.c $(CC) -c $\u003c clean: rm $(OBJ) output 模式规则（ %.x ） CC = gcc OBJ = main.o add.o sub.o output: $(OBJ) $(CC) -o $@ $^ %.o: %.c $(CC) -c $\u003c # %.o: %.c 表示如下： # main.o 由 main.c 生成，add.o 由 add.c 生成，sub.o 由 sub.c 生成 clean: rm $(OBJ) output 伪目标 # 在目标和文件名重名时，加上这句指令，便可以正常执行。用于避免执行命令的目标和工作目录下的实际文件出现名字冲突。 .PHONY:clean clean: rm $(OBJ) output Makefile 函数 经常使用的 Makefile 函数，主要有两个(wildcard，patsubst)。函数的调用格式 $(function（空格或tab）arguments)，这里 function 是函数名， arguments 是该函数的参数。 # $(wildcard 指定文件类型) 用于查找指定目录下指定类型的文件 # 这条规则表示，找到目录./src下所有后缀为.c的文件，并赋值给变量SRC。命令执行完，SRC变量的值：./src/ask.c ./src/100.c SRC = $(wildcard ./src/*.c) # $(patsubst 原模式, 目标模式, 文件列表) 用于匹配替换 # 这条规则表示，把变量 SRC 中所有后缀为.c的文件替换为.o。 命令执行完，OBJ变量的值：./src/ask.o ./src/100.o OBJ = $(patsubst %.c, %.o, $(SRC)) # $(subst from,to,text) 字符串替换，在文本`text’中使用`to’替换每一处`from’。 # 结果为‘fEEt on the strEEt’ $(subst ee,EE,feet on the street) # $(strip string) 去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。 # $(findstring find,in) 在字符串`in’中搜寻`find’，如果找到，则返回值是`find’，否则返回值为空。 # $(filter pattern...,text) 返回在`text’中由空格隔开且匹配格式`pattern...’的字，去除不符合格式`pattern...’的字。 # $(filter-out pattern...,text) 返回在`text’中由空格隔开且不匹配格式`pattern...’的字，去除符合格式`pattern...’的字。它是函数filter的反函数。 # $(sort list) 将‘list’中的字按字母顺序排序，并去掉重复的字。输出由单个空格隔开的字的列表。 # 文件名函数 略 一个简易的 Makefile 模板 文件夹树形目录 ├── inc │ ├── add.h │ └── sub.h ├── Makefile └── src ├── add.c ├── main.c └── sub.c # 编译输出文件加尾缀 \"_VERSION\" VERSION = 0.0.1 # 源文件 .c 文件的所在的名为 src 的目录 SOURCE = $(wildcard ./src/*.c) # 增加一个名为 src1 的源文件所在目录 #SOURCE += $(wildcard ./src1/*.c) # 引用文件 .h 文件的所在的名为 inc 的目录 INCLUEDS = -I ./inc # 增加一个名为 inc1 的引用文件所在目录 #INCLUEDS += -I ./inc1 # 编译输出目标文件的文件名 TARGET = output # 编译输出目标文件所在的文件夹名 OUTPUTDIR = obj # 编译器全名 CC = gcc # 以下都是固定的不用动 CFLAGS = -Wall -g OBJECT = $(patsubst %.c, %.o, $(SOURCE)) $(TARGET): $(OBJECT) @mkdir -p $(OUTPUTDIR)/ $(CC) $^ $(CFLAGES) -o $(OUTPUTDIR)/$(TARGET)_$(VERSION) %.o: %.c $(CC) $(INCLUEDS) $(CFLAGES) -c $\u003c -o $@ .PHONY:clean clean: @rm -rf $(OBJECT) $(OUTPUTDIR)/ 更加通用的 Makefile 模板 在文件 “general_Makefile.zip” 里。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:5","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"imx6ull 相关 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"裸机映像文件合成详情 先说原理，看 imx6ull 芯片手册可知，芯片上电时内部的 boot ROM 固化的程序会通过外部引脚确定启动方式（USB\\NAND\\EMMC\\SD等），将应用的二进制数据（app.bin）从存储区（NAND\\EMMC\\SD等）搬运到内存区（DDR2\\3等），然后跳转到内存区的程序处开始执行程序。这个过程是这个芯片自动完成的，但是需要根据规定合成烧录到存储区的映像文件， 在编译得到应用的二进制文件 app.bin 之后，再用 mkimage 工具（gcc-arm-linux-gnueabihf-6.2.1 编译器自带的）根据 imximage.cfg.cfgtmp 这个文件的信息，合成头部信息，再与 app.bin 组合生成 .imx 文件， .imx 的头部再添加 1KB 的数据（可以全为0，也可包含分区表等数据） 组合生成 .img 文件，具体如下： .imx 文件 = 头部信息（ IVT + Boot data + DCD） + app.bin -\u003e 用于在烧写工具中烧写到 EMMC 中，烧写工具会自动将其烧写到 1KB 偏移处。 .img 文件 = 1k.bin + .imx 文件 = 1k.bin + 头部信息（ IVT + Boot data + DCD） + app.bin -\u003e 用于在烧写工具中烧写到 SD 中，烧写工具会将其烧写到 0 位置处（对与 SD 的烧写，此工具不会自动加 1KB 偏移…）。 头部信息包含了指示 boot ROM 程序要把 app.bin 数据搬运到内存的何处，其大小，以及包含了配置 DDR 的寄存器、引脚等数据等待，具体如下： IVT：Image vector table，含 header（含 tag、length、version，这 3 项，length 表示 IVT 的大小）、entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）、dcd（指示 DCD数据 在内存中的位置）、boot_data（指示 Boot data 在内存中的位置）、self（指示 IVT 在内存中的位置）等，共占 32*8bit 大小，entry 为 app.bin 要在内存中的目的地址。 Boot data：start（映像文件在内存中的地址，为 IVT 在内存中的绝对地址减去 1024 偏移）、length（整个映像文件的长度，含 1k.bin）、plugin，共占 32*3bit 大小。 DCD：配 imx6ull 芯片的寄存器，如 DDR 的配置等，可自定，复杂，mkimage 根据 imximage.cfg.cfgtmp 这个文件的信息合成。 其中，entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）的地址在 Makefile 中调用 mkimage 工具时是可以指定的，在\"重定位\"章节会细说。 具体分布： 头部数据和偏移区使用 mkimage 工具生成，官方都会提供的。 最前面的灰色部分就是偏移数据区，对于EMMC/SD存储区设备是 1KB，对于 NAND 是256B，具体看手册。 最终生成的 .img 文件结构： imx6ull 上电启动过程分析： boot Rom 会把 EMMC 或 SD 卡的前 4K 数据读入到芯片内部 RAM 运行 boot Rom 根据 DCD 进行初始化 DDR。 boot Rom 根据 IVT，从 EMMC 或 SD 卡中将 app.bin 读到 DDR 的 0x80100000 地址（IVT 的 entry）。 跳转到 DDR 的 0x80100000 地址执行，即 CPU 开始从内存 0x80100000 地址开始执行机器码。 以上步骤执行完之后的 DDR 内存图示：（这是反汇编产生的 .dis 文件内容） ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:1","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"重定位、启动和编译 各段数据重排序 每一个汇编成机器码的 .o 文件都会分为这几个数据段： 代码段(.text)：存放代码指令 只读数据段(.rodata)：存放有初始值并且const修饰的全局类变量（const 修饰的变量） 数据段(.data)：存放有初始值的全局类变量（有非零初始值的变量，如 char A = ‘A’;） 零初始化段(.bss)：存放没有初始值或初始值为0的全局类变量（如 int g_intA = 0;int g_intB;，这些存放在 .bss 段） 注释段(.comment)：存放注释 在 Makefile 文件中，在链接步骤，通过 LD 工具，把各个 .o 文件的各个数据段，按照 imx6ull.lds 定义的顺序安放，即各段数据重排序，最后合成一个二进制文件 app.bin，其中的代码段(.text)、只读数据段(.rodata)和数据段(.data)等都来自于前面各个 .o 文件，每个段前后的顺序按照 imx6ull.lds 安放。 链接脚本 imx6ull.lds 解析（一体式链接脚本格式）： SECTIONS { . = 0x80100000; //设定链接地址为0x80100000 . = ALIGN(4); //将当前地址以4字节为标准对齐 .text : //创建段，其名称为 .text { //.text包含的内容为所有链接文件的数据段 *(.text) // *：表示所有文件 } . = ALIGN(4); //将当前地址以4字节为标准对齐 .rodata : { *(.rodata) } //.rodata存放在.text之后,包含所有链接文件的只读数据段 . = ALIGN(4); .data : { *(.data) } //.data存放在.rodata之后，包含所有链接文件的只读数据段 . = ALIGN(4); __bss_start = .; //将当前地址的值存储为变量__bss_start .bss : { *(.bss) *(.COMMON) } //.bss存放在.data段之后, 包含所有文件的bss段和注释段 __bss_end = .; //将当前地址的值存储为变量__bss_end } 同时 imx6ull.lds 文件给出 .bss 段的头、尾地址标识：_ _bss_start 和 _ _bss_end。 启动文件程序 以最简单的裸机点灯程序的启动文件 start.S 为例。仅为示例，过于简单，完整示例可看 “ARM异常处理 及其模板\"内的 startup.s 文件。 .text .global _start _start: /* 设置栈地址 */ ldr sp,=0x80200000 bl main halt: b halt Makefile 文件解析 以最简单的裸机点灯程序的 makefile 为例。 PREFIX=arm-linux-gnueabihf- CC=$(PREFIX)gcc LD=$(PREFIX)ld AR=$(PREFIX)ar OBJCOPY=$(PREFIX)objcopy OBJDUMP=$(PREFIX)objdump led.img : start.S led.c main.c $(CC) -nostdlib -g -c -o start.o start.S # 把启动文件 .s 和各个 .c 文件都汇编为机器码文件 .o $(CC) -nostdlib -g -c -o led.o led.c $(CC) -nostdlib -g -c -o main.o main.c $(LD) -T imx6ull.lds -g start.o led.o main.o -o led.elf # 链接，按照 imx6ull.lds 定义的格式，各段数据重排序，把各个 .o 文件组成 .elf 文件 $(OBJCOPY) -O binary -S led.elf led.bin # .elf 转为 .bin 二进制文件，应用二进制文件 $(OBJDUMP) -D -m arm led.elf \u003e led.dis mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80100000 -d led.bin led.imx # 使用 mkimage 生成 头部数据，并与 .bin 组合，产生 .imx 文件 dd if=/dev/zero of=1k.bin bs=1024 count=1 # 创建一个 1KB 的空文件 1k.bin cat 1k.bin led.imx \u003e led.img # 把 1k.bin 放在 .imx 前头，组合成 .img 文件 clean: rm -f led.dis led.bin led.elf led.imx led.img *.o 清零 bss 段 此部分理解为主，可以不做。 在 启动文件 汇编程序中，用 .bss 段的头、尾地址（_ _bss_start 和 _ _bss_end）来对此区域清零，让 C 程序中未定义初始值或零初始值的变量在初始化时都为零值，而非随机值。 附程序： clean_bss: ldr r1, =__bss_start @ 将链接脚本变量__bss_start变量保存于r1 ldr r2, =__bss_end @ 将链接脚本变量__bss_end变量保存于r2 mov r3, #0 clean: strb r3, [r1] @ 将当前地址下的数据清零 add r1, r1, #1 @ 将r1内存储的地址+1 cmp r1, r2 @ 相等：清零操作结束；否则继续执行clean函数清零bss段 bne clean mov pc, lr 并在进入主函数前调用 bl clean_bss /* 清零bss段 */ 数据段再单独重定位 此部分理解为主，可以不做。 事出有因，想要把 .data 段的数据放到 片内内存中以加快访问速度，参考芯片手册得到片内RAM的地址为：0x900000 ~ 0x91FFFF，共128KB（当然不会很大，也就裸机下的编一编、学一学行，Linux 系统等的大型工程就不适合了），所以我们将 .data 段重定位后的地址设置为0x900000。 第一步：把链接脚本 imx6ull.lds 中的 .data : { *(.data) }换成下面的： data_load_addr = .; .data 0x900000 : AT(data_load_addr) { data_start = . ; //addr = 0x900000 *(.data) data_end = . ; //addr = 0x900000 + SIZEOF(.data) } 第二步：在启动文件中，复制 data 段数据到片内内存 data_start copy_data: /* 重定位data段 */ ldr r1, =data_load_addr /* data段的加载地址, 从链接脚本中得到, 0x8010xxxx */ ldr r2, =data_start /* data段重定位地址, 从链接脚本中得到, 0x900000 */ ldr r3, =data_end /* data段结束地址, 从链接脚本中得到,0x90xxxx */ cpy: ldr r4, [r1] /* 从r1读到r4 */ str r4, [r2] /* r4存放到r2 */ add r1, r1, #4 /* r1+1 */ add r2, r2, #4 /* r2+1 */ cmp r2, r3 /* r2 r3比较 */ bne cpy /* 如果不等则继续拷贝 */ mov pc, lr /* 跳转回调用copy_data函数之前的地址 */ 并在进入主函数前调用 bl copy_data /* 复制 data 段数据到片内内存 data_start */ 100ask imx6ull 的 《IMX6ULL裸机开发完全手册》中的 “9.4.3 总结:如何在C函数中使用链接脚本变量\"章节讲了如何在 C 程序中调用链接脚本中的表示地址的变量，从而可以在 C 程序中实现 “清零 bss 段\"和\"数据段搬运到片内内存”，而不用在启动代码里完成这些操作。 100ask imx6ull 的 《IMX6ULL裸机开发完全手册》中的 “9.5 重定位全部代码\"章节讲了将全部应用的二进制数据搬到芯片的内部内存（128KB），并在其内运行，并且使用 C 程序实现 bss 段清零。其步骤是：第一步，修改链接脚本，段顶位置加上 . = 0x900000;，并加上头、尾的地址标识字符；第二步，在 C 程序中利用头、尾的地址标识字符将其间的数据搬运到芯片内部内存地址；第三步，修改启动文件汇编程序，跳转到内部内存的应用数据处执行。 修改应用在内存中的存放地址 此部分理解为主，可以不做。 IVT 中的 entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）的地址在 Makefile 中调用 mkimage 工具时是可以指定，需要改相关联的几个地方如下： 假设应用的二进制数据（app.bin）原来是要存放在内存的 0x80100000 位置，现在要改为 app_address 处。 Makefile 文件中修改 -e 选项后的地址 mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80100000 -d r","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:2","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"100ASK IMX6ULL Flashing Tool 工具使用 通过 USB 运行裸机程序（不需要烧写，通过u-boot直接在内存中运行）： 板子设到 USB 启动，在 100ask_imx6ull_flashing_tool 工具中的“专业版”界面，打开 .imx 文件，直接点运行。 通过 USB 烧写裸机程序： 板子设到 USB 启动，在 Tool 中的“基础版”界面，若选 EMMC ，则用 .imx 文件，若选 SD ，则用 .img 文件。成功后，断电，切到 EMMC 或 SD 启动模式，再上电。 或者在 win 上，用 win disk imager 工具，把 .img 文件写到 SD 卡。 基础版界面详情： 按钮 作用 烧写整个系统 “选择设备”为EMMC时，把emmc.img烧到EMMC上； “选择设备”为SD/TF时，把sdcard.img烧到SD/TF卡上； “选择设备”为NAND时，把rootfs.ubi烧到Nand Flash上； 并且会烧写对应的U-Boot，请看下面的“更新Uboot”按钮说明。 更新内核 把zImage上传到根文件系统的/boot目录 (对于Nand，是直接烧到内核分区) 更新设备树 把100ask_imx6ull-14x14.dtb上传到根文件系统的/boot目录 (对于Nand，是直接烧到设备树分区) 更新Uboot 对于IMX6ULL全功能版： ①“选择设备”为EMMC时，把u-boot-dtb.imx烧写到EMMC ②“选择设备”为SD/TF时，把u-boot-dtb.imx烧写到SD/TF卡 对于IMX6ULL mini nand版： ①“选择设备”为NAND时，把u-boot-dtb_nand.imx烧写到Nand Flash ②“选择设备”为SD/TF时，把u-boot-dtb_nandsd.imx烧写到SD/TF卡 烧写裸机 把所选裸机文件，烧写到EMMC、SD/TF卡或Nand Flash 上传文件 把所选用户文件，上传到根文件系统的/目录 对于imx6ull mini nand版，无法上传文件(只支持ext4文件系统，而它不是) ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:3","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"异常与GIC介绍 GIC概念 念课本（以下内容都是针对\"通用中断控制器（GIC）“而言，直接摘录的，有的地方可能不符人类的表达方式）： 通用中断控制器（GIC）架构提供了严格的规范，不同厂商的中断控制器之间具有很高的一致性；该控制器包括一组用于管理单核或多核系统中的中断的硬件资源。GIC提供了内存映射寄存器，可用于管理中断源和行为，以及（在多核系统中）用于将中断路由到各个CPU核。它使软件能够屏蔽，启用和禁用来自各个中断源的中断，以（在硬件中）对各个中断源进行优先级排序和生成软件触发中断。它还提供对TrustZone安全性扩展的支持。GIC接受系统级别中断的产生，并可以发信号通知给它所连接的每个内核，从而有可能导致IRQ或FIQ异常发生。 通用中断控制器的工作流程。GIC分为两部分：分发器（Distributor）和CPU接口（CPU interface）。系统中的所有中断源都连接到分发器。可以通过仲裁单元的寄存器来控制各个中断源的属性，例如优先级、状态、安全性、触发方式和使能状态。中断的优先级和可接收中断的核都在分发器中配置。分发器把中断输出到“CPU接口单元”，后者决定将哪个中断转发给CPU核。CPU接口单元寄存器用于屏蔽、识别和控制转发到CPU核的中断的状态。系统中的每个CPU核心都有一个单独的CPU接口，一个CPU核不可能访问另一个CPU核的CPU接口。中断处理详情请看下面的\"处理中断\"部分。 GIC作为内存映射的外围设备，被软件访问。所有内核都可以访问公共的 GIC的分发器 单元。 中断在软件中由一个称为中断ID的数字标识。中断ID唯一对应于一个中断源。软件可以使用中断ID来识别中断源并调用相应的处理程序来处理中断。呈现给软件的中断ID由系统设计确定，一般在SOC的数据手册有记录。 中断可以有多种不同的类型： 软件触发中断（SGI，Software Generated Interrupt）。这是由软件通过写入专用仲裁单元的寄存器即软件触发中断寄存器（ICDSGIR）显式生成的。它最常用于CPU核间通信。SGI既可以发给所有的核，也可以发送给系统中选定的一组核心。中断号0-15保留用于SGI的中断号。用于通信的确切中断号由软件决定。 私有外设中断（PPI，Private Peripheral Interrupt）这是由单个CPU核私有的外设生成的。PPI的中断号为16-31。它们标识CPU核私有的中断源，并且独立于另一个内核上的相同中断源，比如，每个核的计时器。 共享外设中断（SPI，Shared Peripheral Interrupt）。这是由外设生成的，中断控制器可以将其路由到多个核。中断号为32-1020。SPI用于从整个系统可访问的各种外围设备发出中断信号。 GIC分发器 拥有许多寄存器，可以通过它们配置各个中断的属性。这些可配置属性是： 中断优先级：GIC分发器使用它来确定接下来将哪个中断转发到CPU接口。 中断配置：这确定中断是对电平触发还是边沿触发。 中断目标：这确定了可以将中断发给哪些CPU核。 中断启用或禁用状态：只有GIC分发器中启用的那些中断变为挂起状态时，才有资格转发。 中断安全性：确定将中断分配给Secure还是Normal world软件。 中断状态。中断标志位需要软件清除。 GIC分发器还提供优先级屏蔽，可防止低于某个优先级的中断发送给CPU核。 处理流程 众多的中断源，汇集于中断管理器，由中断管理器选择优先级最高的中断并通知CPU。CPU会根据中断的类型到跳转到不同的地址处理中断。当CPU核接收到中断时，它会跳转到异常向量表执行。顶层中断处理程序读取CPU接口模块的Interrupt Acknowledge Register，以获取中断ID。除了返回中断ID之外，读取操作还会使该中断在GIC分发器中标记为active状态。一旦知道了中断ID（标识中断源），顶层处理程序就可以根据中断ID来执行相应的处理任务。 当特定于设备的处理程序完成执行时，顶级处理程序将相同的中断ID写入CPU interface模块中的End of Interrupt register中断结束寄存器，指示中断处理结束。除了把当前中断移除active状态之外，这将使最终中断状态变为inactive或pending（如果状态为inactive and pending），这将使CPU interface能够将更多待处理pending的中断转发给CPU核。这样就结束了单个中断的处理。 同一CPU核上可能有多个中断等待服务，但是CPU interface一次只能发出一个中断信号。顶层中断处理程序重复上述顺序，直到读取特殊的中断ID值1023，表明该内核不再有任何待处理的中断。这个特殊的中断ID被称为伪中断ID（spurious interrupt ID），伪中断ID是保留值，不能分配给系统中的任何设备。 再讲一遍，中断信号先到达分发器，分发器根据该中断所设定的CPU，把中断发送到CPU对应的CPU interface上；在CPU interface里判断该中断的优先级是否足够高，能否抢断或打断当前的中断处理，如果可以，CPU interface就会发送一个物理的信号到CPU的IRQ（或FIQ）线上；CPU接收到中断信号，转到中断处理地址进行处理。 初始化流程 复位后，必须初始化GIC，中断才能生效。在初始化中断时，要初始化这4部分：产生中断的源头(GPIO模块或UART模块等)、GIC(内部有Distributor或CPU interface)、CPU本身(设置CPSR寄存器)。 最后提一句，相关的初始化和处理的代码，芯片官方会提供裸机编程的框架，提供基本的所有寄存器及其结构体的 .h 文件，以及相关使用例程代码，用时看懂就行。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:4","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"ARM异常处理 \u0026 启动文件的示例 @ 本程序仅仅是一个示例 @ 不同ARM内核的中断向量表不同，具体看手册 @ 现在的微处理器寄存器结构非常复杂，不建议硬刚芯片手册手写配置代码，直接参考厂家和网络高手的例子特别省事 @ 一些基础的、不变的、规律性的则必须要会 @ 中断的保存、恢复现场，以及分辨中断号和调用相应中断函数，Cortex M3/M4 是硬件完成的， Cortex A7 是软件实现的 .text @ 代码段(.text)，表示代码段 @ 其他段介绍： @ 只读数据段(.rodata)：存放有初始值并且const修饰的全局类变量（全局变量或static修饰的局部变量） @ 数据段(.data)：存放有初始值的全局类变量 @ 注释段(.comment)：存放注释，注释段里面的机器码是用来表示文字的 @ 零初始化段(.bss)：存放没有初始值或初始值为0的全局类变量 @ 注：bss段和注释段不保存在bin/elf文件中， @ 所以如果bss段的数据没有清0的话，没有初始值的变量在初始化时会是随机的，但个人觉得清不清0不是特别重要。 .global start @ .global 表示 start 是一个全局符号 start: @ 程序入口 @异常向量表 b reset @ 0x00 reset ldr pc,=_undef @ 0x04 undef 未定义指令异常 ldr pc,=_swi_handler @ 0x08 swi 软中断入口 （如果用 mov 指令有32M地址大小限制） ldr pc,=_pre_fetch @ 0x0c prefetch abort ldr pc,=_data_abort @ 0x10 data abort nop @ 0x14 reserved ldr pc,=_irq @ 0x18 irq ldr pc,=_fiq @ 0x1c fiq _undef: .word _undef _swi_handler: .word _swi_handler _pre_fetch: .word _pre_fetch _data_abort: .word _data_abort _irq: .word _irq _fiq: .word _fiq _swi_handler: stmfd sp!,{r0-r12,lr} @ 把 r0-r12 和 lr 寄存器内容进栈，即保护现场 sub r0,lr,#4 @ 软中断号被保存到 lr 寄存器的上一个指令地址，将其临时保存到 r0 ldr r0,[r0] @ 取 r0 保存的地址所指向的值 bic r0,#0xff000000 @ 根据手册，软中断号被保存在低 24 位，则把高八位内容清 0 bl swi_user_handle @ 跳转到 swi_user_handle 软中断用户处理程序，并把下一指令的地址保存到 lr 中 ldmfd sp!,{r0-r12,pc}^ @ 从栈恢复 r0-r12 寄存器内容，并把原来的 lr 内容 恢复到 pc 中， @ 并从 spsr（cpsr的影子寄存器）恢复到 cpsr，即恢复现场 swi_user_handle: @... 软中断的用户应用程序，可以调用 c 函数 cmp r0,#2 @ 判断软中断号是否为2，是则执行后面尾缀带eq的指令 moveq r7,#2 cmp r0,#5 @ 判断软中断号是否为5，是则执行后面尾缀带eq的指令 moveq r7,#5 cmp r0,#7 @ 判断软中断号是否为7，是则执行后面尾缀带eq的指令 moveq r7,#7 ldr pc,lr @ 跳回 _irq: sub lr,lr,#4 stmfd sp!,{r0-r12,lr} bl irq_user_handle ldmfd sp!,{r0-r12,pc}^ irq_user_handle: @... 外中断的用户应用程序，可以调用 c 函数 @并在用户程序中，从中断控制器的寄存器中读出当前的中断号，做相应的相应，然后清中断标志位 @现在的微处理器寄存器结构非常复杂，不建议硬刚芯片手册手写配置代码，直接参考厂家和网络高手的例子特别省事 ldr pc,lr reset: ldr sp,=stack_base @ 分配栈地址到 sp 寄存器 msr cpsr,#0x10 @ 切换到 user 模式 @... 用户应用程序，可以调用 c 函数 swi 2 @ 触发软中断，自动跳转到软中断程序入口 @ 并自动把返回地址（下一个指令的地址）保存到 LR 寄存器 @ 并自动切换到 SVC（超级用户） 模式 nop nop swi 5 nop nop swi 7 nop nop /* @ 这一段是调用 c 程序里面的 void print_test_string(unsigned int cpsr, char *str) 函数 @ 给它传入的两个实参为 r0 和 r1 @ 这时 ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）所规定的 mrs r0, cpsr ldr r1, =test_string bl print_test_string */ b reset @ 返回 reset 地址，大循环 /* test_string: .string \"test_string\" */ @ 定义栈空间和地址，buf 为栈的开头地址，stack_base 为栈的尾地址，中间有 32 个 word 空间 @ 我们使用进出栈的指令是 stmfd 和 ldmfd @ 这两个指令，为从 stack_base 开始向上递进存，向下递进取的顺序，与这里定义的顺序一致 /* ldr sp,=0x80200000 stmfd sp!, {r0-r2} @ 入栈 ldmfd sp!, {r0-r2} @ 出栈 结果： 0x00000000 ... 0x801FFFF4 -\u003e R0 R1 0x80200000 -\u003e R2 sp指针的移动方向：存向上，取向下 也可以用下面指令，效果一样 push {r0-r2} @ 入栈 pop {r0-r2} @ 出栈 */ /* 栈的存取方式 栈的存取方式，为后进先出（LIFO），是由于进出栈指令的作用方式决定的，数据在栈指针处入栈时， 如 stmfd sp!,{r0-r12,lr}，根据这个指令的含义，栈指针sp会根据数据存放的方向自增或自减，出栈的时候过程相反， 在外界看来，这种方式就是只能在头部进出数据的线性表，从算法上来说是一种特殊的线性表，这种 方式是由汇编指令和硬件的易实现性所决定的。 堆是一块空闲空间，使用 malloc 函数来管理它，malloc 函数可以自己写 \"stack_base:\" 这种带冒号的标签表示地址位置，通过其得到指令/数据地址 */ .data buf: .space 32 stack_base: .end ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["ARM"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["规范"],"content":"比较详细、全名的介绍了SCH \u0026 PCB 设计规范和 AD 的使用","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":" 本文的源地址 Github：Qitas/thoughs-about-hardware-design: 介绍和罗列关于硬件设计所需要考虑的各个方面。纯个人经验总结，非科班念经。永远地不定期更新。CC-BY-NC-SA 4.0。 (github.com)。今后只在上面的链接里，这里不会跟进。 编辑整理 by Qitas，始于 2020.7 且无终稿。转载请注明作者及出处。 本文件是“折耳根”计划的一部分，尽量遵循“二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明（这中二魂…）！ 本文系广泛撷取、借鉴和整理，参考的公开文档、书籍和网页不可数、太多了。 适合刚入门的人阅读和遵守，已经有较多经验的人看一看图个乐。如有错误恭谢指出！ ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:0:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"O 目录 [TOC] ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:1:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"0.5 其他优秀的参考文章 （永远的 TODO）以下基本都是作者还没有看到的（看过之后的都会把精髓写在本文）。 PCB 基本布线规范与设计原则 by Hank 基本数模电学习和查询推荐《新概念模拟电路》——西安交通大学电工电子中心，杨建国。 《硬件系统工程师宝典》——EDA精品智汇馆，介绍了硬件系统设计概要、信号完整性、电源完整性、EMC/EMI、原理图和PCB设计详情等。 本条是作者的备注： 本地收集的文章： 《PCB小知识》系列文章，路径：【3 硬件、电路】\\【PCB设计规范】\\ PCB小知识。 有关高速PCB的独立文章，路径：【3 硬件、电路】\\【PCB设计规范】\\ 高速PCB。 ADI 智库文章：《PCB设计秘籍》、《高速电路设计指南》（这个主要针对高速数模转换器件的PCB技巧）、《非隔离式开关电源的PCB布局考虑》、《Power技术问题解答》（这个针对常用 LDO 和 DCDC 的常见问题做梳理）、《电源设计基础知识精选》（对电源方方面面的内容做大梳理）等，具体文章免费在下面链接下载：ADI电子书-您绝对值得拥有的电子书 | 教育 | 亚德诺半导体 (analog.com)，或者在 微信里添加 “ADI智库” 小程序，在小程序里面搜索这些文章的名称，即可下载。 MPS：PCB 布局指南：《电机驱动PCB布局指南》上、下篇、《低EMI DCDC变换器PCB设计》。 TI 的 有关电源的文章。 网上传开的华为的硬件规范。 华为内部硬件开发设计流程 (qq.com)。 .. AD 的更多丰富技巧和高速布线： 综合类（高级技巧）： AD官方：Altium Designer 全套最权威教学|【官方PCB设计培训】|Altium 战疫免费云公益课堂 | 共27节|AD20|PCB Layout_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 凡亿：凡亿教育的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili； .. 高速板设计（蛇形线 和 Active route）（看过之后都详细记下来）： AD官方：【官方培训】Altium Designer 高速DDR3模块全流程实战PCB设计 | AD20 教程 | 共5节|PCB Layout_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； AD官方：DDR存储器布局布线设计思路解析_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 凡亿：【PCB自动布线】 6层PCB高速ActiveRoute自动布线 速度就是快 Altium Designer 20_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 文章：AD19如何使用强大的自动布线功能 - 哔哩哔哩专栏 (bilibili.com)； 文章：(32条消息) Altium Designer 的ActiveRoute使用_MrZhanghx的博客-CSDN博客； ./额外文档/高速布线 教程/AD18中ActiveRoute使用.pdf。 .. 2T 移动硬盘里面的更多比较全的技巧视频 【电子 学习】\\【Altium.Designer】视频+教材\\Altium 技巧经验 较多。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"1 最基本的电路检查项和器件选型 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"关于电路模块化 分为两种层面的 “模块化” ，原理图形式的模块化 和 电路板实体的模块化。 电路原理图必须要模块化，便于以后的开发可以直接参考或复制之前已经设计的固定下来的功能模块。 电路板实体的模块化（接口形式可以是 插接键 或者 邮票孔 ），要视具体应用而定：如果电路板要抗震、要空间集成度高（即占用空间紧张）、要低噪声（即精密设计），那么就不宜用电路板实体的模块化，那么此时直接用原理图模块化的形式（可以借鉴或复制之前设计的模块化的原理图）进行原理图层面的框图连接，然后所有器件画在一个板子上，PCB也直接借鉴之前的设计，这样就实现比较高效的设计。 另外要注意的： 标准化、通用化和可靠性设计高于功能设计； 接口要考虑到电平兼容，比如 TTL 和 CMOS 两大电平标准； 设计系统要尽量利用硬件资源和外设资源，减少 cpu 负担。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"保护机制 过压，欠压，防反接，软起动。 过流，过温。 瞬态抑制，静电保护，浪涌保护，EMC/EMI，RC消火花。 通讯接口、驱动 I/O 保护：加缓冲，加隔离（信号隔离+电源隔离）。 共模、差模干扰抑制。 共阻抗地干扰抑制（高频）。 更多请参考 Qitas/protection-circuits: 对保护电路中的过流、过压、软起动、防反接、通讯和信号隔离、电平转换、防共地干扰、TVS瞬态抑制、共模抑制和电磁兼容做一个大总结 (github.com)。 关于隔离： 电源隔离：常为使用变压器的磁路形式隔离（如金升阳等的电源模块） 信号隔离：常有缓冲/中继（74 系列的244、245 等等）、光耦隔离和磁隔离（如 I2C、SPI 专用的磁隔离芯片）等等；要注意的是信号的隔离往往是两个单独的电路回路之间的信号连接，所以如果用光耦进行信号隔离，那么光耦两边的电源连接应该用两边对应的单独电路回路里面的电源，而不是公用一个地或者电源，这样起不到隔离效果。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"电源 确定入、出的压、流范围，纹波，温度特性。 保护机制完善程度考虑（参考上一小节）。 布局布线考虑。 合理的设计和明确电源轨。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"模块分离 要进行电源分割、空间远离和地线单独安排等措施。 各个部分接各自独立的“地”，最后都各自单点接公共地。 模块特性区分： 数字部分供电电源，给数字电路；模拟部分供电电源，给模拟电路。 强信号、大电流部分 与 弱信号（又分高频、低频）部分。 高电压区域 与 低电压区域。 干扰源 与 敏感元件。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"“地\"的类型-地平面分割 要划分这些“地”，防止互相干扰，每一个“地”单独划分区域，单独覆铜；一般方法是单点接地，都连接到电源地上，参考上面“电源”中配图。 电源地（PGND）（各个电压的地） 模拟地（AGND） 数字地（DGND） 负载地（外接的电机等大负载进行隔离） 外接传感器地（外接模块地隔离，或者共模电感隔离） 机壳地，外壳地 以下为接地的考虑： 更多参考文档./额外文档/单点接地和多点接地剖析.doc。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:5","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"电源完整性的测量 纹波和噪声的测量。 输出阻抗的测量。 环路增益的测量。 滤波器件（电容/磁珠等）性能参数的测量。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:6","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"电阻，电容，电感 电阻：阻值，功率，精度，温漂，品牌厂家，封装，价格，热噪声。 电容：容值，耐压，材质（优先选：固态，铝聚合物，陶瓷电容（NPO，X7R），MLCC 独石电容，钽电容（大容量的钽电容耐压很低）），ESR（等效电阻，要低），纹波电流额定值（rated ripple current），温度特性，泄露电流，封装，寿命年限。 电感：感值（看感值随温度下降的图表），饱和电流（或温度特性），直流电阻（DCR），封装大小（优先选：一体成型的 0630/4040，线艺公司的扁铜带/扁铜线型，铁硅铝（做差模电感最合适））。 关于阻容的封装的补充说明：电阻的直插（金属）封装比表贴（碳膜）和电容的直插（MLCC独石，NPO或X7R）比表贴（陶瓷，NPO或X7R），要来的更加稳定（如热稳定），噪声可能更小。对于要求精密、稳定的硬件可选此。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:7","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"功率开关管 Vds（漏源极电压），Vgs（栅极源极电压），Ids（漏源电流），Rds(on)（导通电阻）。 分布/寄生电容（符号：Cs，Cg。其越小，开关速度越快，开关损耗越小，普通硅基材料 MOS 可选 TI 的 NexFET 型）；封装。 目前三类 MOS 开关管：硅基（Si），碳化硅（SiC），氮化镓（GaN），目前英飞凌（Infineon）能提供很广泛的 MOS 选型和对应的预驱 IC，官网有不少选型指导手册。下图是三类 MOS 的适用范围： 总结目前适用范围： 传统硅基：成熟、稳定可靠，低压，低电流，低频； 碳化硅：高压领域，强电； 氮化镓：低压大电流，高频，强减小功率变换器的体积。（不过预驱参数和传统硅基不同，需要细看）。 以碳化硅为例，相比于 IGBT，其低阻值，高频率和高温工作（250 ℃），可明显将目前大功率变换器小型化，甚将改变工程设计模式。且碳化硅做的二极管，反向过压比硅基的小的多的多。碳化硅的开关管的开关损耗比传统硅基要减少 90%（理想）。 更多阅读： Wide Bandgap Semiconductors (SiC/GaN)。 体验三类 MOS： CoolMOS™ 7- CoolSiC™ - CoolGaN™ 和互补的EiceDRIVER™ IC.pdf。 英飞凌功率器件选型。 德州仪器（TI）的 NexFET MOS 选型（CSD 系列）。 谨防买到假货 MOS 管，识别经验现有两点（真实趟过雷的），一点是如下图识别丝印大小（左边两个真品，右边两个赝品），另一点是真货 MOS 的边缘是圆角，而方角的可能是假货，也不是绝对，需要进一步测量验证，比如加 Vgs，然后测量 Rds，假货肯定 内阻不正常 / 最大承受电流很低 等等。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:8","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"运放芯片 括号内为最廉价运放的典型值。 输入、输出电压范围（供电是否必须双电源，输出是否轨到轨），带宽/摆率/电压转换速率（SR，0.5V/us），开环差模增益（Aod，100dB）/频率响应/伯德图/频带宽（-3dB的频率，0.5~2MHz），放大倍数温漂。 差模输入阻抗（Rid，大于2MΩ），共模输入阻抗，共模抑制比（KCMR，大于80dB）。 输入失调电压（Uio，小于2mV），输入失调电流（Iio，0.2~2uA），输入偏置电流（Iib，0.3~7uA），它们的温漂。 功耗（80mW）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:9","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"开关电源芯片 即 DC-DC 的 BUCK、BOOST、BUCK-BOOST 等。 拓扑形式，频率，是否集成开关管。 输入、输出的电压、电流范围。输出是否可调。 是否带 comp 环路补偿端。 静态功耗。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:10","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"线性电源芯片 即 LDO。 输入、输出的电压、电流范围。输出是否可调。 根据不同功率选用不同封装的具体型号（如 78 系类有 m、l 系列等，1117 系列有 sot-223、sot-89 等系列）。 静态功耗（如 HT7333 最低 1uA）。 输出噪声。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:11","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"MCU / MPU ARM \u0026 SOC 系列快速鸟瞰——ARM 内核各系列介绍和各大厂的选型总结。 内核架构，RAM，ROM，I/O数量，通讯接口（UART，SPI，I2C，CAN，USB，SDIO等），其他特色外设，抗扰能力。 官方手册、工具链是否齐全，官方是否提供 EVK 开发板及其 BSP 底层支持包。 最小系统：供电电源，时钟（晶振等），复位（RC + 开关，内部看门狗，专用看门狗芯片等），SRAM（可选），FLASH（可选）。 功耗，价格，封装大小，供货周期。 如无必要，勿增实体！ ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:12","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"1.5 硬件测试规范化 硬件测试（或称可靠性检验）的指标条目、每个项目的测试步骤和测试报告等规范化。 （这条目前对于我个人是空白的，以后慢慢积累补上）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:4:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"1.75 元件原理图和封装的准备 法一：淘宝大法。淘宝上有很多卖封装的，也不贵，买一次一劳永逸真的划算，如 源创客 的等。 法二：开源大法。如 issus/altium-library、KitSprout/AltiumDesigner_PcbLibrary 、嘉立创的元件库 嘉立创SMT (JLC_SMT) - Gitee.com 等等。 法三：原厂大法。选定大厂的芯片后，一些大厂官网会直接提供该芯片对应的原理图和 PCB 封装，如 ST 等大厂官网对应 IC 页中寻找提供的 PCB 封装进行下载，具体 如何利用 Ultra Librarian 生成 Altium designer 器件封装。 法四：经销商/三方大法。如在 (1)贸泽电子 官网搜索芯片，会提供 https://componentsearchengine.com/ 网址所提供的芯片原理图、PCB 封装和 3D 模型文件，利用 Library Loader 软件（官网下载）或者针对 AD 的 Altium Library Loader 软件对器件模型文件转换成 Altium 软件格式的库文件。还有 (2)立创商城，搜索器件后可以得到 立创 EDA 的器件原理图和封装，导出到 Altium 即可，如何将嘉立创的原理图封装导入到AD20?。 法五：以上方法都没有，是特殊的器件，可以自制。对于原理图，一般元件的引脚和其划分不会特别复杂，应该很快就能画好；对于PCB 封装，常见的可用 AD 的 IPC 自动创建常用封装工具，先选择封装类型，再根据手册设置各种长宽参数，自动生成PCB封装以供使用，不常见的那只能最后的最后才自己画啦，按照芯片手册提供的封装规格，尺寸的单位看准了。 至于 3D 模型若没有，简单的可在 AD 的 PCB 库中的元件上添加 3D 实体（通常在机械1层）自己画，复杂的可去 找3D模型和导入的一个教程； IC封装网-行业IPC标准化的元件库及PCB封装库资源下载平台 (iclib.com)； 3D ContentCentral - 免费 3D CAD 模型、2D 工程图和供应商目录； 等网站下载。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:5:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"2 SCH 绘制规范和 AD 使用 个人规范，仅供参考。这里是针对 AD10 版本。 在使用 AD 时候，应先导入我的软件配置和 PCB 规则 Rules 文件，具体文件和方法说明在“AD 软件设置和PCB规则Rules配置文件”文件夹中。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:6:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"SCH 中的快捷键 拖住器件时，按 x、y 为镜像翻转。 选中一根线，Ctrl+R，可以复制重复放置。 先点 Tools -\u003e Cross Probe，扫描所有原理图中相连的线，再 ctrl + 鼠标左击，点击一根线全局高亮。 原理图和 PCB 界面分别选择 Tools -\u003e Cross Select Mode，可以在 SCH 和 PCB 界面交叉选择，即同时高亮选中同一个元件，有利于定位。 … ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:6:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"最基本的 SCH 绘制过程 对电路原理图进行电源、主控和其他外设等模组分页绘制（这里仅为示例，没有用 层次原理图设计模式，详看同名章节）；第一页可以是目录页，附文详细说明等，可以再加上历史版本和改动说明；第二页可以是原理图框图；原理图第三页可以加上 电源轨框图 示意。后二者在原理图比较复杂的情况下，很有必要。 原理图第一页的 目录 规范示意： 原理图第一页的 历史版本 规范示意： 原理图第一页的 目录 和 历史版本 和 说明 兼有，示意： 原理图第二页的 框图 示意： 原理图第三页的 电源轨框图 示意： 对于每一页SCH（这里仅为示例，没有用 层次原理图设计模式，详看同名章节）： 各个子模块用线格划分； 并在各个格子里写上子模块名称； 页面右下角写上本页名称，x / Total（x 当前页编号，Total 为总页数），作者和日期； 可在子模块旁边放上实物图片、官方推荐PCB图等方便画原理图； 信号/小电流线用细线，电源/驱动/大电流线用粗线。 原理图作画要布局工整，走线清晰，注释到位！ 每个器件的命名。在 Designator 写上准编号，电容是C?，电阻是R?，电感L?，芯片IC?，晶体管Q?，以此类推；在 Comment 写上器件的名称。 型号名补全，查看器件手册的发货信息（Order information），确定具体的封装、温度范围和功能等的一个器件型号全名，在原理图的器件中写清，方便导出 BOM 表和采购。 原理图中元件标识的规范，供参考，不是必须。如下图，电阻原理图的左上角、右上角、左下角和右下角以此标识 Designator、Comment（一般为阻值）、封装和精度，对于电容类似，对于电感要有饱和电流标识，其他器件同理。 网络标识的命名规范，基于 “器件名（或器件类型） _ IO性质（数字还是ADC） _ IO名（管脚名）\"。中间常用于 MCU 的网络命名，其他非 MCU 器件非必须。例如，“MCU _ IO _ KEY1”、“TPS5450 _ SW”、“DRV _ EN _ BUCK “等，如下图示意。 初次研制阶段，可多用 0 欧电阻、磁珠和跳线帽等，留出可以可测试、可断开和可配置的地方，方便逐个电源域、逐个模块的测试电流、功能裁剪等。比如加在电源出口，初次上电前可以先断开，不给后面的的电路供电，上电后测量电压和纹波，合理后，即可再接上，或者可以在此缺口直接测量电流。 原理图中接口件，旁边放上实物图，图片设置为内嵌型。 原理图画好后该给各个元件建立唯一编号。打开“工具”-\u003e“注解”，点 Reset All ，再点“更新更改列表”，最后执行“接受更改”。 对原理图进行编译和查错。依次点 “工程”-\u003e“Compile Document” 和 “工程”-\u003e“Compile PCB Project”。没错后即可导入PCB。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:6:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"3 PCB 绘制规范和 AD 使用 个人规范，仅供参考。这里是针对 AD10 版本。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:7:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"板层标识定义 Top Overlay 为丝印层。 Top Solder 为开窗层。 Keep-out Layer 为板边界。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:7:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"PCB 中的快捷键 q 为单位在 mil 和 mm 之间切换。 拖住器件，按下 L 切换器件所在层。 Ctrl+鼠标左键点击一根线为高亮此线，点右下角“清除”清除高亮。 按住 Alt，鼠标在板子器件上移动，会显示器件轮廓。 Shift+s：为高亮所在层，重复操作取消高亮。 处于布线状态时，shift+空格为改变线类型，空格为改变线凹凸。 Ctrl+g：为选择切换栅格类型为线或点。 Backspace 为布线时回到上一步。 线状态下按*（乘号）为带过孔换层。 Ctrl+m：为测量长度。 Ctrl+左键点一下对正在布的线完成自动布线连接。 Ctrl+h：再点一根线会全选之，然后 del 删除整根线。 Shift+h：PCB 的左上角状态栏是否显示。 Shift+g：PCB 左上角状态栏是否固定不动。 键盘上边数字“3”为显示 3D 视图，数字“2”还原。 3D 视图中依次点“v”、“b”-\u003e翻转板。 按 L 按键，在视图选项中隐藏相关元素，比如隐藏覆铜（Polygons）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:7:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"最基本的 PCB 绘制过程 要全程符合“PCB 布局布线规范”章节内容。如果有双屏幕的话，在画 PCB 的时候我一般会把原理图视图放在左屏（在 AD 软件中将原理图标签拖过去就是），PCB 视图放在右屏，或者相反，这样双屏左右对照着看和画，不用来回切。 先定义PCB规则。点开“设计”-\u003e“规则”，主要设置线宽范围，元件最小间距，焊盘的开窗范围，默认过孔尺寸，覆铜类型为直接连接等。 过孔尺寸：焊盘比孔至少大6mil。例如最小孔直径为12mil（0.305mm），焊盘直径至少18mil。 划定板边界。在 Keep-out Layer 层绘制板边界闭合线，然后执行“设计”-\u003e“板子形状”-\u003e“按照选择对象定义”。 放置 PCB 原点到 PCB 边界的左下角。依次点击“编辑”、“原点”和“放置”，然后放置原点。 把每个模块包含的所有元件移动到一堆。 首先开启交叉选择，分别打开在原理图和PCB界面的“工具”-\u003e“交叉选择模式”选项。 在原理图界面中，选中一个子模块内所有器件，再到PCB界面，点“排列工具”-\u003e“在区域内排列器件”，在空白区域内拖出一个矩形，此子模块所有的器件便都堆在此矩形区域内。 PCB中显示元件的原名（此步骤非必须）。 随便选中一个元件，右键点开“查找相似对象”，都是“any”情况下点“应用”，此时所有器件已全选，再点“确定”，出现“PCB Inspector”窗口，在其中取消选中“Show Name”，打开选中“Show Comment”即可。 PCB Inspector 对于多器件批量改属性特别好用。选中要统一修改的器件，然后按 F11 调出 PCB Inspector 窗口，然后在 PCB Inspector 窗口改属性，所选中的多个器件就一同更改了。 多层板（多于 2 层的偶数层）。 在 PCB 里连按快捷键“D”、“K”调出层叠管理，或者在“设计”里面找“叠层管理”，或者空白处右击，“选项”里的“层叠管理”。 多层板的推荐板层分布图在“PCB 布局布线规范”章节的“中学生级”里。 注意内电层在拼板的时候网络会丢失，暂时没有简便的办法。有内电层在需要拼板的时候，建议这样处理：先把PCB文件直接复制一个，命名为“xxx 不含内电层版.PcbDoc”，然后打开此文件，执行以下步骤： 先把内电层的分割线都删掉，然后 D K 快捷键调出板层管理，把内电层（负片层）删掉，换为普通层（正片层）。 然后在新的普通曾里按照原来分割线的形状覆铜，网络选择跟原来一样。 四层板举例： 在“层叠管理”中，在中间添加“Signal1”和“Signal2”两个信号层，或者添加“GND”和“VCC”两个内电层(Internal Plane)； 前者的信号层可直接布线。后者的内电层特性为负片，即布线的地方不铺铜，什么都不画的时候是一整块铜皮，专用于电源划块，即内电层分割；双击一个封闭区域可设置此区域覆铜连接的net。 信号层和内电层可以各有一个，混搭组成四层板，这样内电层专走电源和地，还多了一个信号层。 其他注意点：画线不要用交互式走线，要用工具栏中的“应用工具”的“走线”等功能；典型内层厚度为1.4mil；通常采用默认的 Layer Pairs（层成对）模式；不允许在内电层上布置信号线；内电层不同区域之间的间隔宽度不小于 40mil。 典型四层板板层分布为（由上到下）： 信号层 - 内电层（GND层） - 电源层 - 信号层（把信号层露在外面是为了好实物修改，也可不这样）； 信号层 - 内电层（GND+VCC层）- 信号层 - 信号层。 元器件布局。 布局的好，走线容易，布局不好，走线困难。 先大后小，先难后易，均匀分布，整齐划一。 数模分离；功率驱动和信号处理分离；高频低频分离。 间隔充分，模块独立。 根据主信号流向摆放主要元器件。 整齐美观，有规律。 器件布局和走线推荐，优先参考 IC 的数据手册。 更多布局规则请参考“4 PCB 布局布线规范”章节的内容。 布线。 除非可以混过去的项目，否则坚决不用自动布线（你晓得）。 不手动布地线，地线的布线在下一小节“后续工作和润色”中用覆铜和过孔解决。 对于两层板而言：先走电源线，再走信号线；对于四层板而言：摆好器件，先划分好内电层区域，再走电源线，再走信号线。 电源线足够粗，功率走线必要时考虑开窗加锡。功率走线可以用覆铜来布线，然后原地复制粘贴一个再换成开窗层，得到整块覆铜的开窗。 走信号线时，模拟信号、高速信号和时钟线优先布线。电流和地路径不形成环。 AD 10 的等长线/蛇形线设计： 画法参考文档./额外文档/AD10 蛇形等长线的画法和规则设定.pdf； 先走好线，然后等长线都加到一个网络，按T R，选择最长线确定，移动鼠标拖蛇形线。 快捷键：“1、2”改弧度，“3、4”改间距，“，、。”改绕长，在左下角导航选“PCB”窗口，可见加入网络的要等长的线及其各自的长度。 多跟线一块走：先选中多跟线，点“交互式布多跟线”，再点任一个线，就并排走了。 更多布线规则请参考“4 PCB 布局布线规范”章节的内容。 检查布线完成情况：工具栏 “Report”，“Board information”，勾上 “Routing information”，点 “Report”，新页面中查看布线的完成情况。如果还差最后几根不容易发现的线，在 PCB 页面中以 shitf + s 显示单独层来查看未连接的线。 后续工作和润色。 永远不要手动消除 DRC 报警或报错，要么修改 PCB，要么修改到合适的规则。 板边缘圆润。 电源芯片下方的 PAD 处仅加一个超大的过孔，而不是一堆小过孔，小过孔会被焊锡堵住。 加泪滴。 加螺丝定位孔。 覆铜，原理图和器件布局时候按照“地”的划分而讲究，覆铜也按照这个讲究来讲究。 每一块覆铜之间间隔在2mm以上，尤其是高压和低压区域的覆铜。 对于覆铜，确保不出现较大的（超过 150mil）死铜、孤铜。覆铜不要有尖端或者细支延申或者存在于焊盘之间的覆铜的细线，可以在要去掉尖端的地方放置多边形占着地方，然后重新更新一下覆铜，尖端的地方就没有了。 敷铜不要有尖锐的边角，四周要圆润。 绕着模块加大的过覆铜过孔，板子四周加一圈过覆铜过孔，板子内多加过覆铜过孔增加回流路径。 每一个滤波旁路电容的地脚旁边放一个地过孔。 每一个芯片底部有尽量完整的地覆铜和过孔。 注意过孔不要露铜。 在丝印层加板子的接口（电源、通讯接口等）、Logo等标识。 留下必要的测试点（开窗点），直径至少大于 0.4mm，测试点周围至少 2.54mm 空间以内要保持空旷。 工艺边 工艺边是为了满足自动化贴片的需要而增加的辅助部分，生产完成之后会被移除，一般设计为 5mm。 定位孔: 用于 PCB 加工和测试时的定位，一般设计为 2mm 的过孔。 Mark 点: 用于自动化贴片机进行识别定位，通常设计为 1mm 的焊盘。 PCB 画好后，执行 DRC 检查！ 拼板。 新建一个PCB，选择“放置”-\u003e“内嵌板阵列”或者拼板之类的（不同版本名字不同），选择要拼板的源文件、更改阵列参数和更改间距参数等即可。 两板的连接处中间加两排或者一排过孔（邮票孔：一般0.8mm大小的非金属化过孔，间距1.1mm，五个为宜），拿到后可直接掰开，掰开后再处理平滑一下边缘，而省去切割；应该注意便于板掰开的过孔要足够多，不用吝啬，如果寥寥几个过孔的话掰开仍然很困难。 或者用粘贴的方法。把要拼的板子的PCB文件复制一份，打开新复制的文件，全选并复制，原点要在最左下角，然后点特殊粘贴，只勾选“duplicate designator”（如果勾选“Keep Net Name”，那么多个板同名线会显示未连接），然后点“粘贴”或者“矩阵粘贴”，然后选不进行重新覆铜即可。 可点击“生成PCB封装库”，把当前 PCB 里面所有器件的封装单独做一个 PCB 封装库。 缩减PCB文件体积 Altium Designer PCB文件太大怎么办-百度经验 (baidu.com)。 更多常用技巧都总结在./PCB LOGO-画法集合-PCB工具-规则文件/PCB实验-画板技巧综合.PcbDoc里。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:7:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"3.5 AD20 SCH \u0026 PCB 常用设置 这里没有说到的都与上面 “2 SCH 绘制规范和 AD 使用” 章节中的一样。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"AD 20 软件设置 改中文界面：AD20 界面右上角的设置图标，选 “system”，选 “General”，选 “Use local resource”，重启软件。但建议使用全英文。 窗口找不到：AD20 界面右上角的设置图标，选 “system”，选 “View”，选 Desktop 中的 “Reset”。 自定菜单项的快捷键：按住 Ctrl 键点击所选功能项，打开 Edit Command 窗口，并设置快捷键，注意不要与已有快捷键的提示（Currently in use by）冲突；取消快捷键：在快捷键选项框中下拉选择 None 即可。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"AD 20 快捷键 \u0026 绘制技巧 在拖动元件的时候按 “Tab” 键调出元件属性进行参数修改和设置等。 在原理图中器件的属性界面有 “Pin” 标签栏，进去可以选择显示/隐藏引脚标号和名称。 取消高亮：Shift + c，或者右键点 “Clear Filter”。 拖动元件，按住 “Ctrl” 的时候器件不会吸附网格而自由移动。 修改器件移动时的网格，SCH 为修改 “Snap Grid” 参数，PCB 为 ctrl+g 或者在属性中双击 “Grid Manager” 调出 Grid Edtior，修改 Steps 参数；PCB中修改 Steps 可以以准确、固定的间距放置多个器件。 跨图连接器 Off Sheet Connector，尽量不要用，这就像 C 中的 goto 一样容易混乱，要么设计成 层次原理图设计，要么设置网络标号为全局使用（选择 project-\u003eproject options-\u003eoptions，在 Net … Scope 中选 “Global …” 即可）。 … SCH 中的： 多个相似器件的批量修改，如所有电容的 Designator 修改为 “C?\"，或者统一修改封装等等：右击一个器件，点 “Find Similar”，把 Symbol Refrence 选为 same，或者其他选为 same，然后点 Apply，会高亮出所有相似器件，然后鼠标在空白处按住左键拖动框选所有相似器件，便可以在属性栏中批量修改属性，调出属性栏可以按 F11。或者手动单独多选要批量修改的多个器件，然后在属性栏中可以批量修改。PCB 中同理，可用于批量修改封装、修改焊盘/过孔等等，只是在 “Find Similar” 步骤中点 Apply 后相似器件会自动都被选中，直接在属性栏批量修改即可。 .. PCB 中的： 按住 xxx（暂时不知道），鼠标在板子器件上移动，会显示器件轮廓。 隐藏覆铜：按 L 按键，在视图选项（View Options）中选择关闭覆铜（Polygons）显示。 切换三种布线模式（忽略，避开，推挤）：Shift+r。 把选中的器件排列到框里：“Tools”，“Component Placement”，”.. Within Rectangle”；或者设置个快捷键。 覆铜：选择好网络、选择移除死铜、设定移除小于比如 10mil 的铜片和选择 “Pour Over Same Net ..\"；移动覆铜后，要右键选 “Polygon Actions” 的 “Repour All”。覆铜的属性栏里面的 Actions 里面有重新覆铜、设置网络（再手动点一根要连接的网络的线）、前置/后置和修改（手动画线微调边缘）等。 挖掉一块覆铜：选 Polygon Pour Cutout 工具，在已经覆铜的区域画个框，然后重新覆铜 “Repour All”。 批量放过地孔：给覆铜添加或者围绕某个线添加，选 Tools 的 Via Stitching/Shielding，在里面设置孔连接的网络、孔分布和孔大小等信息，可以选择给整个板面均匀加接地孔（孔间距可以打一些防止孔过多了），也可以选择给信号线的周围围绕着加接地孔，比较方便。 只能选择某种类型要素而其他元素不能被选中，方便只修改某一类元素而防止误碰其他要素：点工具栏的 Selection Filter，哪一项打开哪一项就能被选中，反之不能被选中；一般在覆铜后可以把覆铜 Polygons 关闭使能选中。 调节 PCB 线高亮时候与背景对比的程度：点右下角 Panels，点进 View Configuration，在 View Options 栏中下面调节 Mask and dim，还可以调节 Object Visibility，可以把 覆铜 Polygons 的亮度调低，以区分覆铜和走线、焊盘。 板子镂空：先围绕要镂空的区域画 Keep-out-layer 闭合曲线，然后工具栏选择 Designer，Board Shape，Define Board Cutout，然后围绕刚才画的镂空区域的 Keep-out-layer 闭合曲线 画一圈。 .. 器件原理图库绘制的技巧： 引脚名字上要加横线表示低有效：绘制器件原理图库，在名字的每一个字符中间加 \" \\ \" 字符即可。 快速添加各个引脚名：在一个器件原理图库的界面，其属性的 “Pin” 标签中，下面有笔形状的 “编辑” 按钮，点进去可以以表格形式编辑当前器件各个引脚属性。 .. 更多 AD20 快捷键参考./额外文档/AD20常用快捷键总结（北冥有鱼）.xlsx。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"通用 AD 规范-今后尽量适用 导入 AD20 软件配置文件，参考 “7 AD 导入导出配置文件” 章节。 统一的标题栏：每一页原理图都使用 A4 大小，标题栏使用模板文件./PCB LOGO-画法集合-PCB工具-规则文件/标题栏模板/A4 - 折耳根.SchDot，将其复制到 AD20 安装目录下的 /Altium/AD20/Documents/Templates，然后在 SCH 界面的属性栏的 Page Options 的 Formatting And Size 中选 Template，下拉选择 “A4 - 折耳根” 选项，在属性栏的 参数页面加上 标题、作者、版本号等等信息。 统一的设计模式：原理图都使用 “层次原理图设计” 的模式。 导入 AD20 的 PCB Rules 规则配置文件，参考 “7 AD 导入导出配置文件” 章节。针对线宽的规则可以做依不同 Class 设置不同线宽规则，并在 Rules 界面的左下角设置优先级（手动布线时低优先级不起作用）；针对高速线的规则要依 Class 单独设置规则，详见下面的 “等长线/蛇形线设计” 小节。 准备焊接实物 PCB 的准备：AD20 中 PCB 界面右下角 Panels 里面打开 PCB List 栏，选 View All Objects，再选 Components，即列出所有器件并按照 Comment 排列，可以选中所有一个值的阻/容器件然后器件会高亮显示，并且 PCB List 栏的下面会显示被选中元件的数量，接着焊接这一值的阻/容器件，然后换下一波相同值的器件，以此类推。使用钢网和加热台快速手工贴片：如何快速高质量手工PCB贴片。 .. ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"层次原理图设计 顶层以框图形式，方便原理图各个子系统部分模块、固定和规范化，也方便从顶层快速了解整个原理图工程。通常先把各个子系统的局部电路原理图画好，放置好端口 Port，最后在顶层做框图把各个模块连接。以下介绍的是自下而上的画，若是架构设计人员可以自上而下设计。 一个模块只用一页原理图，画好各个子系统电路模块原理图，并添加好 Net Label（局域级别有效），然后再添加各个模块对外连接的 Port，并填好 Port 的网络标号名字（可以与 Net Label 重名），输入输出类型； 新建一个顶层原理图文件，在其中 点工具栏 Design，点 Creat Sheet Symbol Form Sheet，选择一个子原理图模块，放置 Sheet Symbol，其中的 Port 和 Sheet 框图的大小均可调整，然后连线；如果子原理图模块更新了端口，在 Top 层的 Sheet Symbol 上右击，选择 Sheet Symbol Actions 里面的 Sync.. 同步即可。 在所有原理图都是平级的时候（即没有顶层 Top 原理图 SCH 的时候）：当单独使用 Port 或 Net Lable 时候，这两个都是全局作用的；当同时使用的时候，Port 是全局作用的，Net Lable 是局域级别作用的（即所在 SCH 页内）；从电源符号那一栏中拖出的（有 GND、VCC 等各种电源符号）的网络标号总是全局作用的，因为其名字都带 Port。但是当原理图有分层的时候，Port （包括电源符号的 Port）也变成局域级别作用，仅当在上级原理图中用线连接后才会连接。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"布局复制 针对多个一样的模块，PCB 中器件摆放/布局都一样化。 先布局好一套模块，另外几套模块的位置可以乱，先放着； 打开 Panels 中的 PCB List，选择 View Selected Objects，再选 Components，再把上面布局好的一套模块的所有器件选中，这时 PCB List 中会显示所有被选中的器件信息表，找到表中的 X1 和 Y1，右击选择 Switch to edit mode，然后选中 X1 和 Y1 复制，然后选中另外一套模块的所有器件，在其 X1 和 Y1 上粘贴即可，这时两套是重叠的，不要取消刚才的选中状态，进行整体平移到两套不重叠，然后选中第一套模块的所有器件，在 PCB List 中复制所有的 Rotation，然后选中第二套模块的所有器件，在其 Rotation 栏粘贴即可。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:5","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"总线连接 看图自学。 Sheet 2 SCH 图： Sheet 3 SCH 图： Top SCH 图： PCB 效果： ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:6","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"差分走线设计 这里的步骤以 嘉立创 提供的计算工具和下单助手提供的阻抗生产选项为准。下面以 USB 差分走线（阻抗一般为 90 Ω）为例。 嘉立创提供的阻抗计算工具； 嘉立创下单助手的 工艺信息 一栏选择 “需要阻抗”，并选择层压结构（一般为第一个 JLC7628）； 在 PCB 的 规则 Rules 中，点进 DiffPairsRouting 栏里，改差分走线的 最小间隙和优选间隙 为步骤1中指定的（7 mil），最小宽度、优选宽度和最大宽度 改为步骤1中指定的（9.72 mil）， 在 SCH 或 PCB 中添加差分对，一个详细步骤文章，另一个详细步骤文章，然后在 PCB 页面中打开 panels 的 PCB 栏，在其中选择 Differential Pairs Editor，可以看到差分对的名称以及其具体的每一个差分线。 在 PCB 界面中选择 “交互式差分对走线” 进行走线。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:7","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"等长线/蛇形线设计 这里是针对 AD20 的操作。 PCB 界面的右下角 Panels 按钮里面打开 PCB 栏，左边 PCB 栏中显示 Nets，在 Net Classes 栏里面添加要等长的线的 Class 命和线； 然后在 Rules 里面，High Speed 里面的 Matched Lengths 上右击新建一个规则，进去在 Where The Object Matches 栏里面的 第一个选 Net Class，第二个选 要等长的线的 class，然后在下面设置 Tolerance，容忍等长的误差，最好填小一点如 3 mil。 PCB 界面 工具栏 选择 Interactively Tune Trace Lengths 工具，从最短的线开始画线进行等长变化的区域；快捷键：“1、2”改弧度，“3、4”改间距，“，、。”改绕长，在左下角导航选 “PCB” 窗口，可见加入网络的要等长的线及其各自的长度；走线等长变化的区域可以调整，直接对等长变化区域选中的矩形框的四周拖拽，改变等长区域；删除等长，直接选中线的等长变化区域再按 del。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:8","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"添加 LOGO 图案 两个方法，推荐用第二种。 PCB Logo Creator 生成丝印图案的方法，具体教程 pdf 和所需软件在 ./PCB LOGO-画法集合-PCB工具-规则文件/创建 PCB Logo 图形/PCB Logo Creator 生成丝印图案的方法.zip 里面。 LOGO 字体 添加 PCB 图案的方法，具体教程和所需软件在 ./PCB LOGO-画法集合-PCB工具-规则文件/创建 PCB Logo 图形/LOGO 字体 添加 PCB 图案的方法.zip 。AD20 添加字体logo 视频教程 - 北冥有鱼。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:9","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"4 PCB 布局布线规范 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"幼稚园级 走线没有锐角和直角拐弯，可以走 T 型线。 元件引脚下的焊盘不能放过孔。 功率线、信号线尽可能短，功率线要足够粗，必要时应开窗加锡，并且大电流线、电源线之间的间隔应大于30mil，内电层不同区域之间的间隔宽度不小于 40mil。 大电流、高功率的走线及其经过的器件应尽量按照能量流动的\"好走\"的路线布局和布线，尽量减少拐弯和跨层，让其一马平川的流动。 线宽和电流能力关系表： 过孔直径和电流能力关系表：（看工程实践一栏；孔径高于 0.5mm 时，每增加 0.5mm ，电流能力增加 0.5A ） 推荐过孔孔径：（单位 mm） 信号线——0.3过孔，0.5外径，0.84电流； 弱电电源线——0.5过孔，0.8外径，1A电流； 大电流(多个)——1过孔，1.5外径，1.5~4A电流； 大电流（多个）——1.5过孔，2外径，2~5A电流。 PCB走线与电流关系更多参考文档：./额外文档/PCB走线与电流关系.pdf 。 去耦电容（旁路电容）尽量靠近 IC 等器件的电源输入端，滤波电容可以放置在芯片的背面，靠近芯片的电源和地引脚。 多采用星形拓扑结构，少采用菊花链布局，缩短电源的公共回路。 电源变换元器件（如变压器、DC/DC 变换器、三端稳压管等）应该留有足够的散热空间；干扰源（DC/DC 变换器、晶振、变压器等）底部不要布线，以免干扰。 差分信号（如 USB 和 CAN 的信号线、运放输入，电流采集的差分电压信号和晶振的差分时钟信号等）紧靠并排走线。 留下必要的测试点（开窗点），留螺丝孔。 丝印方向尽量在两个方向以内，避免人看的时候不断转板子。过孔尽量不要放在丝印上， 用丝印标识出从板子引出的 引脚 功能，接口说明，开关、拨码开关的功能表，LED 指示的功能。 画出 LOGO，板子名称，板子版本号，防静电（手勿触碰）、高压提醒等丝印层标识。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"中学生级 多层板：时钟频率到 5MHZ 或脉冲上升时间小于 5ns（五五准则），则 PCB 板须采用多层板。 多层板：多层板的关键信号层最好位于两个地平面之间，即其电路模块的上下层所对应的区域都用地平面覆盖。 多层板：电源平面应相对于其相邻地平面内缩 5H-20H（H 为电源和地平面的距离，若内缩 20H 则可以将 70% 的电场限制在接地边沿内，内缩 1000H 则可以将 98% 的电场限制在内）。 多层板的推荐板层分布图： 多层板：相邻布线层的走线应尽量垂直；实在无法实现垂直而必出现平行的应互相远离，或时钟、总线、射频线等关键信号走线和其他同层平行走线应满足 3W 原则，3W 原则：线中心距不少于 3 倍线宽（70% 的电场不互相干扰），还有更好的 10W 原则（98% 的电场不互相干扰）。 对于变压器、扬声器、电感等会产生磁场的元件，布局时应注意减少磁力线对于印制导线的切割，相邻元件磁场方向应相互垂直，减少彼此之间的耦合。 元件的放置要便于调试和维修。大元件边上不能放置小元件；需要调试的元件周围应有足够的空间。发热元件应有足够的空间以利于散热；热敏元件应远离发热元件。 接口电路的滤波、防护、隔离器件、EMC和整流等应该靠近接口放置；如果接口处既有滤波又有防护电路，应该遵从先防护后滤波的顺序。I/O接口电路及功率驱动电路尽量靠近 PCB 板边缘，即大功率器件尽可能放在电路板边缘。 防护电路的检查项详看 “1 最基本的电路检查项和器件选型” 章节的 “保护机制”。 晶振、继电器、开关电源等强辐射器件远离单板接口连接器至少 1000mil。 敏感电路或器件（如复位、看门狗、信号线路等）远离单板各边缘特别是单板接口侧边缘至少 1000mil，或关键信号线距参考平面边沿的距离大于 3H（H 为线距离参考平面的高度）。 电源、模拟小信号、高速信号、时钟信号和同步信号等关键信号优先布线。 过孔可能会引发信号传输线的阻抗突变，因此需要尽量减少过孔使用的数量，尤其是对于关键信号线。 信号线（特别是关键信号线）换层时，应在其换层过孔附近设计地过孔。 敏感信号的周围应放置多个接地过孔（宽度大于 50mil 地线或间距小于 300mil 的地孔），提供电磁屏蔽。 对于金属外壳接地元件(例如晶振)，应在其投影区的顶层上铺接地铜皮，并在其周围密布上一圈接地孔，提供电磁屏蔽。 无论是时钟线、信号线还是电源线，在 PCB上 的走线都应该尽量短，器件紧密排布以减少 PCB 上走线长度；而且时钟线和信号线等在 PCB 上的走线应尽量用地过孔和地平面在空间上包裹；并且在 PCB 板的四周边缘打一圈连地平面的过孔。 一个芯片的外围阻容元件应尽量靠近芯片，并尽量接近其所要连接的芯片引脚。例如，电源脚去耦电容靠近电源引脚，匹配电阻布局时候要靠近该信号的驱动端等。 MCU 的 IRQ 中断引脚等重要 IO 注意静电保护等，可加 TVS 保护管，防正负过压的保护二极管。 开关器件如 MOS，其栅极和源极之间要加 TVS 防过压冲击（设计让 Vgs ≤ 18 V 恒）。MOS 的栅极串电阻的作用：MOS 导通速度过快，高压情况下容易击穿周围的器件或者损坏 MOS（后者为感性上理解）；栅极电阻阻值过大会导致 MOS 管导通速度过慢，开关损耗会巨大。栅极电阻最好紧靠栅极，并且这个是信号线，布线避免与其他线耦合，避免栅极过压。 小型化是产品开发的必经之路，挑战极限才有竞争力。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"本科级 开始触及知识的盲区了。 信号完整性（SI）分析。考虑传输延迟（蛇形线），反射（阻抗匹配，线长不要是1/4波长的整数倍），串扰（元件和导线的磁场相互垂直、平行线相互远离（3W原则）、信号线间用地平面隔离等）等等。 电源完整性（PI）分析。 阻抗匹配的内容，也需要遵守，属于原理图设计部分：高频电路源与目的之间的阻抗匹配非常重要，错误的匹配会带来信号反馈和阻尼振荡。过量地射频能量则会导致 EMI问题。此时，需要考虑采用信号端接；滤波器选型的阻抗失配准则：对低阻抗噪声源，滤波器需为高阻抗（大的串联电感）；对高阻抗噪声源，滤波器就需为低阻抗（大的并联电容）；降低敏感线路的输入阻抗有效减少引入干扰的可能性；LC滤波器 在低输出阻抗电源和高阻抗数字电路之间，需要LC滤波器，以保证回路的阻抗匹配；降低敏感线路的输入阻抗。 对于高频电路，需要考虑元件之间的分布参数的影响。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"PCB 检查项 上图图源。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"4.5 PCB 检查工具 自动化 PCB 检查工具。 华秋 DFM：一键分析导入的 PCB 文件，检查项有板子尺寸、孔、线、间距、孤铜等等，排除生产难点、设计缺陷，给出优化建议，结合各种生产因素，自动计算或反算阻抗等等，比较有用。 etc. ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:10:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"5 AD 导出 BOM 表 AD10 的教程：Altium Designer（AD）软件导出BOM文件操作步骤-百度经验 (baidu.com)； AD20 的教程（推荐使用，还包含自定义 BOM 表模板）：AD20如何自定义BOM模板?Altium Designer20 实用技巧系列教程（五）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili，其中 BOM 模板文件在 ./PCB LOGO-画法集合-PCB工具-规则文件/AD20 BOM模板 北冥有鱼 里面，这个模板导出的 BOM 表比较常用、整齐，还包含描述、封装、单位价格（可以在导出 Excel 表格后再填入单价，表中的总价格会自动计算；表格最底部有一栏 PCB ，可以填入价格）等，比较实用。注，视频中的模板的位置，在不同版本 AD20 不同，如果按照视频找不到，那么就应该在 /Altium/AD20/Documents/Templates/ 目录下。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"6 AD 导出 Gerber 和 钻孔文件 用时再学： 【AD小教程】导出Gerber文件和钻孔文件_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 【完结】第26课 Altium Designer20(AD20)+VESC6.4实战教程：调整丝印输出Geber文件并投板（北冥有鱼）完结撒花_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:12:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"7 AD 导入导出配置文件 AD 软件的设置和 PCB Rule 设置，两个配置文件的导入和导出，参考本文件夹这里 ./PCB LOGO-画法集合-PCB工具-规则文件/AD 软件设置和 PCB 规则 Rules 配置文件/。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:13:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"8 使用 KeyShot 10 渲染三维模型 B站等有很多教程视频，以下只经验之谈。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:14:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"基本步骤 用Altium Designer导出.step格式的3D模型文件，再导入keyshot，但这个模型不带走线和丝印。 导出表面贴图：在Altium Deigner里面使用“智能PDF”分别导出正反面的只有“走线和丝印”两个层的图，注意颜色可选，然后可以把这个pdf使用PS简单修一修（比如颜色修改和过孔透明），再导出.png格式的图。省事的做法可以直接在AD的3D视图截图，然后贴到keyshot的PCB板面上。 PCB板面添加贴图：然后把贴图添加到keyshot中PCB模型的板面的材质里面的标签里面。如果板面不加材质，保持原色，则直接在其材质面板下的纹理下的颜色双击添加图片，映射类型选平面，对准选部件，然后点移动纹理调整，调整使这个图像对齐贴合PCB板面即可，另一面的图片再在标签里添加。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:14:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"KeyShot 的几个初级技巧 （毕竟只是看一下效果，不是专业的） 3D视图下，tools菜单下的legacy tools可以导出带走线的，带丝印的模型，但是文件太大，keshot会卡，对电脑性能要求很高,我还没测试。 没试 高版本的AD，可以导出pdf3d 没试 单个模型加材质：单击选中一个模型（出现橘色描边），然后添加材质。或者双击这个模型，右边菜单下面点“接触链接材质” 单独删除模型，先模型右击点分离，便可删除单独部件。 右边菜单 什么都不选 全局设置的情况下 有 照明和图像里面很多不错的效果可以调整 材质和打光：https://www.bilibili.com/video/BV14W411d7Hx 动画制作：https://www.bilibili.com/video/BV1T741177WU ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:14:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范和 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["其它"],"content":"科幻小说《请留在未来》，Science-fiction 《please stay in the future》","date":"2020-06-01","objectID":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["其它"],"content":" 本文另发在，恭迎：知乎、BiliBili 按： 有时真的非常想写一些东西，写一些不一样的东西，这个小文费了不多也不少力气。 星空对于我小时候来说是理想国，做梦会梦到的存在。看火箭发射真的会落泪吗，男儿有泪不轻弹，不过是想起了多少前辈的努力，看到往天上飞行的火箭，心里一直在呐喊“飞啊，向上!向上冲啊。”对于闲笔碎言的写一些这样的文字，我记得过去的一些，小学应要求写过一篇描述未来学校的，初中写过两个一共几万字的科学幻想小作品，高中又写了几篇小短篇。直到现在这篇，更长，篇幅更丰富。 最初的最初，是在知乎上，抖机灵写了一个描述“实现了共产主义的外星文明”的基本设定的回答，觉得这些设定挺有意思，也有一些想批判性写的东西，由此展开写了此小说。我承认我并没有在认真写科幻文，只是不间断批判性的夹带一些私货。这是一个“后现代魔幻现实赛博朋克文艺和共产红星高照的硬科幻时政”小说。 始写于约2019.7的人生困难时期，有时在路上想到一个点子记下来，有时在睡前隐隐约约想到一种场景记录下来，就这样断断续续积攒灵感，最后在几天里收集整理，成文于2020.6.1的阳光时期，困难终会过去。 注：《请留在未来-注解篇》为对正文中的彩蛋和致敬的部分内容做注解。 以下正文，致敬。 ","date":"2020-06-01","objectID":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:0","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["其它"],"content":"请留在未来 “文明，让宇宙在静默运转中绽放意义之花，从远古第一堆篝火的摇曳微光到新世纪航天器尾焰的灼热焰火，而这仅是人类文明滔滔麦田中的零星穗谷。 …… 让偏见化作带有人情的想象，让想象缓解带有无知的挫败。一个思考者认为这是否算作创新的哲学观念，即“有用的组合”和“有意义的简化”。如果推此作为哲学观念，它将难以产生预测将要发生的或者如何做才对的具体方法论，哲学总是后知后觉的在事后阐述其道理，毕竟，当一个人站在人生十字路口时，谁能够预测每一条分支的未来，预测未来岂能理论化。但，二项玻所引发的认知革命使得人类可以预测近未来，这是一种几百年来呼之欲出，而又是最重要的一个技术革命，使得并且值得之前的认知逻辑一律推倒重来，最终的科技革命竟是回到人类认识这个世界的方式上，多么简约美观”。——选自《二项玻传》。 我将向你讲述，一个镜像文明的简史。悠久的人类史诗，在一次次技术革命中重塑，但从二项玻诞生的那一天，人类才真正突破了自身的屏障。想象一个与地球相仿的平行地球，但她，随着出现这样的转变，而离我们所熟知的模样远去，快速地变得不可观测，不可理解，不可叙述，是结束，也是开始。 透过图书馆的巨型窗，阳光下一切熠熠生辉，夏叶正在看一本书，上面介绍着：“目前的观测表明，我们的宇宙在大尺度结构上曲率接近于——零，意味着，即使在可观测宇宙的边缘，即在观测距离距此大约180亿光年，实际距离距此大约450亿光年的位置，以那里作为新的观测原点，看上去依旧是漫天的繁星，似曾相识燕归来。与此同时的另一件事，在圆周率无限并且不循环的数字中，理论上包含着所有序列组合，包括每一个人的电话号码，车牌号和身份证，比如笔者的生日出现在第45,561,304位；其可以包含着汤显祖戏剧的GB2312编码，包含着DNA，或者说包含着可以描述地球的的数字串，也可能包含着另一个无限不循环小数”。 人和桌椅错落的影子渐渐拉长，阳光留在墙壁上的光斑悄悄上升。图书馆证是夏叶所在的一家IT公司发的，想鼓励员工没事的话多看一点书，这家公司专门运营一个百科知识库，夏叶经常要去运维服务器。今天是一个周末，夏叶拿起手机约了公司同事晚上在公园对面吃饭。天还没黑，月亮已见，斑驳街景中多了一个看起来正在想事的人。 “最近几天我做了一些奇怪的梦”，夏叶和同事在餐厅一偶闲聊。 “就是那种，很少见的那种，我感觉自己漂浮在宇宙中，你知道吗”，夏叶疑惑的说道。 同事来了兴趣，紧接着说：“你不要担心，我不会怕。你也不怎么看关于宇宙的东西啊，怎么会梦见这类东西”。 “对啊，最近才想了解一下看看，哈哈之前我连地球外面长什么样子都不晓得，但不瞒你说，那梦相当真实，我梦到我在一个巨大星球的环上，那叫什么来着，土星是吗，各种碎冰和碎石还有我都漂浮着，整个环围绕着巨大的土星旋转，我的天，那土星，贼大。然后某个方向有一个光点慢慢亮起，突然，我周围的物体全部向光点相反方向无声地快速移动，使我感觉我在向光点的方向移动”。 “挺有意思啊，不过你梦到这种东西正常吗，是不是最近精神压力有些大”。 “好像是什么预兆之类的，但有时候就没有了，昨天就没有”。 又过了不慌不忙的几天工作，梦算是又正常了。 一天晚上，夏叶吃过晚饭，戴上耳机听几首歌，一首流行英文乐，一首中文情歌，再出去压马路转一转，到公园稍微活动一下，同时还听着一首摇滚，一首民谣，一首说唱，一首future bass风格的电音，一首Vocaloid，一首日系轻音乐和一首交响乐，回到家，刷了几下朋友圈，聊一聊，对明天的日程做一个规划，查一下长期任务的完成情况，再洗漱完毕，便关灯睡去。 （序章完） 在42光年之外，一个市郊，也多了一个正在想事的人。“这个项目最近很难维持了”，大潭结束了一天的工作，疲劳的坐在记录仪前讲述着，“这个机器我已经维持了十年，马上就要成功了，我肯定不会放弃的”。 大潭继续说道：“大约150年以前，星球共同体第一次接收到了外星文明信号，但是奇怪的是那个文明所在的行星乃至上面的文明生物与我们相当类似，从概率上讲，在距离我们足够多的可观测宇宙距离之外，微观粒子的特定排序有可能重现，但是在42光年外这么近的距离便出现了一颗平行地球，难以置信。估算他们的水平大概落后我们200年，可是由于无线电信号传输的数据太少，并且来回一次交流的时间需要84年！这都堪比彗星的周期，但那一次截获的信号中有记录一个保存了他们大部分文明成果的服务器和硬盘所在房屋的坐标，于是共同体决议研制了这个“远距离取物”的传送机器，在两个星球之间传输数据，直接送硬盘比无线传输在这种情况下更好，这个过程预计要进行约150年，但是相比于84年也只能传相当少的信息来说，这个计划相当可行”。 “当上这个项目的主管，接手这个项目是我年轻时的一个理想。几年前我说过马上就要完成这个已经进行了几代人的实验，感觉近在咫尺，一晃到了现在，现在……” 大潭停顿了一下，想了想继续说道：“现在这个项目很难维持，我不得不计划铤而走险一出。这个项目已经持续了太久太久，人在历史中学到的就是历史会重演，在最后的十年里，绝大部分人相继开始认为这个项目是个吸金的无底洞，纷纷反对或者离开，有人说这个时代奇迹太多，谁会关心那个落后手工业的外星文明。如果有人以后能看到这段，我想说，拜托各位，几百年前的人多么有梦想，他们如此远见的制定了他们注定看不到的百年计划，比比皆是”。 大潭关掉了记录仪。转念一想：“忘了把机器现在缺少钯元素这个状况记录进去了，说着说着又跑偏。机器大概明后天结束，千万不能在最后一刻掉链子，150年了，一秒都不准出差错”。 “不录了困了”，大潭心想，“明天去弄来42克钯”。 大潭躺在床上，看着天花板上的几行字逐渐进入梦乡： “美丽的宇宙太空， 以它的神秘和绚丽， 召唤我们踏过平庸， 进入它无垠的广袤。①” 窗外远处的巨型荧幕上正在播放着介绍认知革命的画面，其中正播到：“……平均来看一个人能熟练掌握的知识是有限的，而且在某一刻的思考所能涉及到的方面更是有限，即内存RAM不算大，即便感觉所有可能都思考过了，但是仍有感觉还没有思考到的地方，随着知识爆炸的步伐，这种不安全感促使人们制定了名为“天下大同”的科技推进计划，即所有知识和经验都要进行精简和步骤化，一个人要进入一个领域时，能够用最小的时间迅速了解到这个领域80%的东西，这个是经过机器学习和优化理论精密计算处理过的，进而，学科交叉和互相借鉴的理论和应用得到空前发展，引起了一场又一场的技术革命……直到今天，我们仍在认知革命上获取新鲜、创新和高质量的文明成果，这一切都要感谢玻柏先生的开创性设想。明天还会和今天一样吗……” 大潭出生在这么一个时代里，通过计算机辅助启发和自动演化推理的帮助，以及全面而简洁的认知学习，符合人性的学习知识和逻辑，其初心是能够使人快速在一个领域登堂。 第二天，大潭开始了炫技。大潭提前已经了解到某研究所的无人卡车今日会运输一些钯元素，现在，大潭给某研究所的服务器挂一个“肉机”自动化扫描和尝试进入该服务器，该行为必会引起服务器的自动化反攻击程序，大潭在几年前设计该服务器电路板时留了一个后门，当自动化反攻击程序启动时，后门会检测其服务器内存里的指令流，从而找到该反攻击程序的地址，然后大潭远程控制后门发送关掉该程序的指令流，从而相当于拿到了该服务器的shell，在服务器上定位到该运输车，控制其开到一个桥底下，然后拿到了关键的一些钯元素。 传送机器得以继续运转。机器指示的进度达到了99.999%，最后就剩半天的时间！ 大潭提前架好了记录仪等待着这历史性的一刻，只是这一刻没有第二个人在。这个时代的奇迹太多，人们关心不过来。 突然电脑中的危险感知响起警报，“这个时候来这个”，大潭无趣的看过去，屏幕上提示“警侦即将锁定昨天卡车失窃的幕后玩家”，大潭心想，“不好，快找上门了，反侦察能力还是欠佳啊”。 大潭焦急的等待着机器的结果，等待那从外星文明传送来的服务器和硬盘。 滋滋声时时作响，命令框内哔哔的更新着运行状况，电脑AI温馨的提醒着“一会要有光，小心眩光”，在机器的容器内渐渐有了光，可是在下一刻，一个人形的黑影出现在容器中，大潭眉头一皱，看向斜上方，转回头又露出无奈的眉目。 不多久，夏叶出现在机器中，急促的呼吸一口空气而后醒来。 大潭还是诧异的心想：难道传送的那一刻把硬盘和一个人同时扫描了？那硬盘应该就在其旁边啊，但硬盘没有出现。 大潭去将容器打开，夏叶惊慌的问道：“这是哪里！你是谁？”，大潭紧张的回答道：“你好，我想这里有些错误，这个实验进行的有错误”，大潭在心想：天啊，几代人的维护，错传送了一个人而不是服务器，等等，冷静……唉。 大潭继续回答道：“不用害怕，我不是坏人，对于我来说，你是外星人。我叫大潭”。 大潭抢过话头接着说：“你们所在的星球是一颗和我们的星球非常像的星球，不仅仅是外貌的像，而是粒子排列、演化的方向等都很类似，所以你能听懂我的话，也就是说，一定数量的粒子排列，如果能在一定区域内穷举的话，那么在另一个区域有可能出现相同的排列，从概率来说这几乎是一定发生的事情，但是这两个区域的距离在计算上表明应该不低于几个宇宙直径，但是墨菲定律也在起着作用，这种相同的排列竟巧如造物的出现在同一片星区，也就是相距42光年的我们的星球和你们的星球”。 夏叶有些困惑，大潭仍耐心的继续说明情况，还带她走到窗边，看到外面的世界和远处的城市。 “什么？！我现在在外星球，但怎么感觉一切都好熟悉，哇这个神奇的城市，可是，我到底怎么来到这里的，我想回去”。夏叶说道。 大潭：“这真的是我们的错！另外你没有错失理智这很好，但是你对于42光年的距离好像没有概念。我们做的实验是将你们星球一个记录了百科知识的服务器传送到我们这里好进行对你","date":"2020-06-01","objectID":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:1:0","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["主线剧情"],"content":"介绍 Linux 基本使用和对 ARM SoC 的基本编译流程","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"ARM \u0026 Linux 基础学习记录 编辑整理 by Qitas 本文部分内容摘自“100ask imx6ull”开发板的配套资料（如《嵌入式Linux应用开发完全手册_韦东山全系列视频文档全集》），还有参考（非复制）菜鸟教程、红联的文章等等等等，比较广泛，侵删。进行了精髓提取，方便日后查阅。过于基础的内容不会在此提及。如有错误恭谢指出！ ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"目录 [TOC] ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Linux 一般开发步骤 p.s 本应放在最后，刻意写在前头。 Bootloader、Linux 内核、根文件系统、APP 等等软件，需要在 Ubuntu 中编译；但是阅读、修改这些源码时，在 Windows 下会比较方便。 所以工作日常开发流程如下： PC 端，使用 source insight 编、改源码 —\u003e传—\u003e Linux端，操作 Ubuntu 对修改好的源码进行编译、制作 —\u003e下载—\u003e 嵌入式端，在 Linux 板子上运行、测试。 分步来说就是： 在 Windows 上阅读、研究、修改，修改后，上传（推荐 FileZilla）到 Ubuntu ； 在 Ubuntu 上编译、制作（推荐使用 MobaXterm 通过 SSH 远程登陆 Ubuntu）； 把制作好的可执行程序下载到开发板上运行、测试。 u-boot、Linux内核，Windows 和 Ubuntu 各存一份。根文件系统使用 buildroot （或 Busybox 或 Yocto）制作，它无需放在 Windows 上。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Linux OS 相关 p.s 关于在 VM 虚拟机中安装 Linux 发行版系统和在PC上安装 Linux 发行版系统，用时再在网上随查随用。 p.s 若仅用于开发或者只使用命令行的形式，一般在 MobaXterm 或者 Xshell 中使用 SSH 连接 Linux 系统（如 Ubuntu）来进行系统操作。 p.s 鼠标退出 VM ，按 ctrl + alt。 Linux 系统使用教程 - 菜鸟教程，当字典用。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Linux 文件系统 文件目录 Ubuntu 中的目录遵循 FHS 标准(Filesystem Hierarchy Standard， 文件系统层次标准)。它定义了文件系统中目录、文件分类存放的原则、定义了系统运行所需的最小文件、目录的集合，并列举了不遵循这些原则的例外情况及其原因。 FHS 并不是一个强制的标准，但是大多的 Linux、 Unix 发行版本遵循 FHS。 这些目录简单介绍如下。 文件属性 终端中执行 “ls -al” 命令则给出每个文件完整属性信息。文件属性示意图如下 。 第一个字符表示“文件类型”，它是目录、文件或链接文件等。如下表所示。 d 目录 - 文件 l 链接文件 b 设备文件里的可供存储的接口设备 c 设备文件里的串行端口设备，如鼠标、键盘等 文件类型后面的 9 个字符以 3 个为一组： 第一组表示“文件所有者的权限”； 第二组表示“用户组的权限”； 第三组表示“其他非本用户组的权限”。 每组都是 rwx 的组合， 其中 r 代表可读， w 代表可写， x 代表可执行； 如果没有对应的权限，就会出现减号 -。 连接数： 表示有多少文件名连接到此节点。 文件所有者：表示这个文件的“所有者的账号”。 文件所属用户组。 文件大小：表示这个文件的大小，默认单位是 B(字节)。 文件最后被修改的时间： 这个文件的创建文件日期或者是最近的修改日期。 文件名：对应文件的文件名。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:1","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Linux Shell Linux大神都是怎么记住这么多命令的？ - 知乎 (zhihu.com)。 Linux学习教程，Linux入门教程（超详细） (biancheng.net)。 Linux 教程 | 菜鸟教程 (runoob.com)。 概况 Shell 的意思是“外壳”，在 Linux 中它是一个程序，比如/bin/sh、 /bin/bash 等。它负责接收用户的输入，根据用户的输入找到其他程序并运行。比如我们输入“ ls”并回车时， shell 程序找到“ ls”程序并运行，把结果打印出来。Shell 有很多种实现，我们常用 bash。 命令提示符如下图。 根目录： “/” ；家目录： “~” ；上一级目录： “..” ；当前目录： “.” ；上一次目录：\"-\"。执行当前目录的 “app” 应用程序： “./app” 。 常用命令 预备 Ctrl + Alt + t 打开终端。 以下命令的多个选项可以任意按需组合。 惯例选型含义：-a 表含隐藏文件，-r 表文件夹内遍历所有文件，-h 容量以方便识别的形式打印，-i 执行例外操作前会询问，加上比较保险，-v 显示版本， –help 显示帮助，等等。 tab 键自动补全命令和文件或目录的全名。 快捷键： ctrl + c，结束当前进程。 ctrl + z，暂停当前进程，可使用 fg 恢复，详见 “任务后台执行/任务查看” 章节。 ctrl + a，使光标移动到命令行的最前，对于长命令可以快速定位到最前。 ctrl + e，使光标移动到命令行的最后。 ctrl + d，退出当前终端，关闭，作用与 exit 一样。 多个命令写在一行并自动逐个执行，命令之间加 \u0026\u0026 符号。 输入路径全名的中途，按两下 tab 键显示当前目录下的内容。 各种通配符： *：任何字符和字符串。 ?：一个任意字符。 [abc…]： 内的任意一个字符。 [abc]表示 a、 b、 c 任一个字符；有时候也表示范围，如 [a-x] ，表示 a 到 x 的任一个字符； [1-9] 表示 1 到 9 的任一数字。 [!abc…]：和上面的相反，表示除 内的字符外的任意一个字符。 例 rm -f 1[!1]*.txt 删除名字中第一个字符是“1”而第二个字符不是为“1”的所有文件 。 流控制，输入输出重定向（\u003e，\u003c）： Shell 输入/输出重定向 command \u003e file，将输出重定向到 file，将 stdout 重定向到 file，将 command 的打印内容覆盖输入到文件 file 里。 command \u003c file，将输入重定向到 file，将 stdin 重定向到 file，本来需要从键盘获取输入的命令会转移到读取文件内容。 command \u003e\u003e file，将输出以追加的方式重定向到 file，追加输入到文件 file。 错误信息重定向： 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 command 2\u003e\u003efile 让执行命令后的错误信息 stderr 追加到 file 文件末尾。 管道（ | ）： command1 | command2，当在两个命令之间设置管道时，管道符|左边命令的输出就变成了右边命令的输入。 这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command1 的输出结果； command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。 例：查看指定程序的进程运行状态，并将输出重定向到文件中。 ps aux | grep httpd \u003e /tmp/ps.output cat /tem/ps.output Shell 教程 - 菜鸟教程，Linux 命令大全 - 菜鸟教程，当字典用。 略过的命令 pwd、cd、mkdir（-p 选项指示连续创建目录及其子目录）、rmdir（不能删除非空目录）、touch、clear、echo（往文件写内容 echo none \u003e /sys/class/leds/cpu/trigger）。 获取命令帮助： –help/man 命令后加 –help 选项，获取此命令的所有选项和其释义。详情如下图。 命令的完整手册，命令前加 man，提供命令、API、概念、配置文件等帮助信息。详情如下。 man 手册一共有 9 册，每一册专注一个方面。如下表。 section 名称 说明 1 用户命令 用户可操作的命令 2 系统调用 内核提供的函数(查头文件) 3 库调用 常用的函数库 4 特殊文件 设备文件(/dev下)和特殊文件 5 文件格式和约定 对一些文件进行解释 6 游戏程序 游戏程序 7 杂项 包括宏包和约定等 8 系统管理员使用的管理命令 通常只有系统管理员可以使用 9 内核相关 Linux内核相关文件 每一册都细分为语法说明、详细说明、作者说明、版权信息等章节。如下表。 段名 主要内容 NAME 命令、数据名称的简短说明 SYNOPSIS 简短的命令语法说明 DESCRIPTION 最为权威和全面的使用说明 EXAMPLES 使用本命令或数据的一些参考示例 AUTHOR 作者 REPORTING BUGS 报告相关的错误信息 COPYRIGHT 版权 SEE ALSO 与本命令或数据相关的其他参考说明 显示目录文件和文件夹：ls -l 显示完整属性信息；-a 显示隐藏文件；-h 文件和文件夹大小以 K/M/G 单位显示。一个例子如图。 统计目录每个文件大小：du 统计指定目录内每个文件和文件夹大小：du -ah ~/Videos。-a 表显示隐藏文件，-h 表大小以 K/M/G 单位显示。 显示指定文件所占空间： # du log2012.log 300 log2012.log 复制文件或文件夹：cp -r 表示递归目录下所有文件； -d 如果源文件为链接文件，只复制链接文件而不是实际文件； -i 增加特殊情况的讯问，如同名时会询问是否覆盖等； -f 强制覆盖。 例子： 拷贝 dir1 内所有文件到 dir2：cp dir1/* dir2 或者 cp -r dir1/ dir2/； 复制目录时常用：cp -rid dir_a dir_b。 移动/重命名文件/文件夹：mv 直接举例： mv file1 dir1 dir2，将文件 file1 和 目录 dir1 移动到目录 dir2 里面。 mv file1 file_1，将文件 file1 重命名为 file_1。 删除文件或文件夹：rm -r 递归；-f 强制；-i 询问（个人建议常用）。 删除目录：rm -rf dir_a。 喜闻乐见的删库跑路：rm -rf /*。 改变文件权限和属性 改变文件所属用户组 ：chgrp 将 install.log 文件的用户组改为 hy 用户组：chgrp hy install.log。注意 hy 用户组必须要在/etc/group 文件内存在才可以。 -R : 进行递归的持续更改，也连同子目录下的所有文件、目录都更新成为这个用户组之意。常常用在更改某一目录内所有文件的情况。 改变文件的所有者：chown 例子：chown bin install.log、chown book:book install.log，改变 install.log 文件的所有者为 bin，改变 install.log 文件的所有者和用户组为 book 和 book。 改变文件所有者和用户组的这两个命令的应用场景：复制文件，由于复制行为会复制执行者的属性和权限，因此复制后需要改变文件所属用户、用户组等。 -R：也是递归子目录。 改变文件权限：chmod 使用 u、 g、 o 三个字母代表 user、 group、 others 3 中身份。此外 a 代表 all，即所有身份。范例：chmod u=rwx,go=rx .bashrc； 也可以增加或去除某种权限，“ +”表示添加权限，“ -”表示去除权限： chmod a+w .bashrc、chmod a-x .bashrc、chmod +x app。 数字的方式就不细说了：用 4 代表 r 权限，2 代表 w 权限，1 代表 x 权限；owner = rwx = 4+2+1 = 7；例子：chmod 777 .bashrc。 连接流：cat -n 或 –number：由 1 开始对所有输出的行数编号。 -b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。 -s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。 例子： # 将一个字符串输入到一个文件 echo \"难凉热血折耳根\" \u003e users # 把 textfile1 的文档内容加上行号后覆盖输入 textfile2 这个文档里 cat -n textfile1 \u003e textfile2 # 把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容 追加 到 textfile3 文档里 cat -b textfile1 textfile2 \u003e\u003e textfile3 # 清空 /etc/test.txt 文","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:2","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Vim 编辑器 功能：打开、新建和保存文件；文本编辑；多行、列间复制、粘贴和删除；查找和替换。 意义：开发中，尤其对于大型项目并不常用，但是在需要临时修改、现场调试和没有 GUI 形式的编辑器等等的时候，可以快速进行一些简单文本编辑。 一图以蔽之 一般模式 用于光标移动、复制、粘贴和删除等；命令行模式 用于输入保存、退出、查找和替换等控制命令，在一般模式打一个冒号再输入命令。 注：当不知道处于何种模式时，按 ESC 键返回到一般模式。可以在 Ubuntu 中安装中文输入法。 Vim 编辑器的配置，请看 “vi编辑器的配置_摘自100ask.txt” 文件。 在 一般模式 的更多指令 单击 o （字母 o）键，在当前光标所在行的下方新建一行，并进入编辑模式。 单击 0（数字零） 光标移至当前行行首；$，光标移至当前行行末； gg，跳到第一行，（xgg 就是跳到第x行的行首）；G，跳到文件结尾。 ctrl + f，上翻页，ctrl + b，下翻页。 使用 v 进入可视模式，选定文本块，移动光标键选定内容；用 y 复制选定块到缓冲区，用 d 剪切选定块到缓冲区，用 p 粘贴缓冲区中的内容。 dd，删除光标所在行(d:delete) 。 u，撤销上一步操作；ctrl + r，恢复，回退到前一个命令。 针对 Ubuntu 界面来说，ctrl + “-” ，减小字号；ctrl + shift + “+\"，增大字号。 在 命令行模式 的更多命令 查找：:/pattern 从光标开始处向文件尾搜索字符串 “pattern”，后按 n （在同一个方向重复上一次搜索命令）或 N （在反方向重复上一次搜索命令）；从当前光标位置开始搜索，若光标在文件开头，则为全文搜索。 替换：:%s/p1/p2/g 将文件中所有的 p1 均用 p2 替换；:%s/p1/p2/gc 替换时需要确认。释义，“ s“ 全称： substitute 替换；“ g“ 全称： global 全局；“ c“ 全称： confirm， 确认。 新打开一个文件：:sp \u003cfile\u003e纵向分屏 或 :vsp \u003cfile\u003e横向分屏，此时会同屏新增一个窗口；切换这多个窗口的方法（循环移动）：ctrl + w，w（先按 ctrl + w，再按键 w），在多文件编程时，切换不同的窗口很实用。让鼠标可以在多个屏幕间切换：:set mouse=a；在某个窗口输入:q，为退出此窗口。 跳转到第 n 行：:n。 文件另存为：:w \u003cfilename\u003e。 重命名当前文件：:f \u003cfilename\u003e。 打印当前文件名和行数：:f 。 从 a 到 b 行的内容写入 文件：:a,bw \u003cfilename\u003e。 在 Vim 命令行执行 Shell 命令：:！+ shell 命令。 一日，一人，代码前坐禅，贤者模式，顿悟，曰：整个键盘，都是 Vim 的快捷键。 恢复文件 vi 在编辑某一个文件时，会生成一个临时文件，这个文件以 . 开头并以 .swp 结尾。正常退出该文件自动删除，如果意外退出例如忽然断电，该文件不会删除，我们在下次编辑时可以选择一下命令处理： O 只读打开，不改变文件内容。 E 继续编辑文件，不恢复 .swp 文件保存的内容。 R 将恢复上次编辑以后未保存文件内容。 Q 退出 vi。 D 删除 .swp 文件。 使用 vi －r \u003cfilename\u003e 来恢复 filename 这个文件上次关闭前未保存的内容。 选项 -d，Diff 模式 (同 “vimdiff”, 可迅速比较两文件不同处)。 -R，只读模式 (同 “view”)。 -b，二进制模式。 -r ，恢复上次崩溃的文件 filename (Recover crashed session)。 VI 编辑器的配置 部分摘自 100ask cp /etc/vim/vimrc ~/.vimrc vim ~/.vimrc 在.vimrc中加入如下内容： \" option 前面加 un 前缀表失能此功能 \"关闭兼容功能 set nocompatible \"显示行号 set number \" 关闭行号为 set nonumber \"编辑时 backspace 键设置为2个空格 set backspace=2 \"编辑时 tab 键设置为4个空格 set tabstop=4 \"设置自动对齐为4个空格 set shiftwidth=4 \"搜索时不区分大小写 set ignorecase \"搜索时高亮显示 set hlsearch \"底部显示光标所在行和列 set ruler ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:3","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Ubuntu 下的包管理 包管理系统的功能和优点大致相同，但打包格式和工具会因平台（不同的 Linux 发行版）而异，如下表所示。 操作系统 格式 工具 Debian .deb apt, apt-cache, apt-get, dpkg Ubuntu .deb apt, apt-cache, apt-get, dpkg CentOS .rpm yum Fedora .rpm dnf FreeBSD Ports, .txz make, pkg 一般来说Ubuntu 下很多软件是需要先自行提供源码，使用源码自行编译，编译完成以后使用命令” install” 来安装到系统中。当然 Ubuntu 下也有其它的软件安装方法，使用得最多的方法就是自行编译源码后进行安装，尤其是嵌入式 Linux 开发。 自行对软件源码编译的一个好处是可以针对不同平台进行编译和部署。 我们利用软件包管理系统可以直接下载并安装所有通过认证的软件，其中 Ubuntu 下我们用的最多的下载工具： APT 下载工具， APT 下载工具可以实现软件自动下载、配置、安装二进制或者源码的功能。 在我们使用 APT 工具下载安装或者更新软件的时候，首先会在下载列表中与本机软件进行对比，看一下需要下载哪些软件，或者升级哪些软件，默认情况下 APT 会下载并安装最新的软件包，被安装的软件包所依赖的其它软件也会被下载安装或者更新，非常智能省心。 包管理工具 apt # \"package\" 替换为 包名。 sudo apt-get update 更新源 sudo apt-get install package 安装包 sudo apt-get remove package 删除包 sudo apt-cache search package 搜索软件包 sudo apt-cache show package 获取包的相关信息，例如说明、大小、脚本等 sudo apt-get install package --reinstall 重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package --purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被那些包依赖 sudo apt-get source package 下载该包的源代码 换源 和 添加系统变量 换源： 首先备份源列表：sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup； 编辑 /etc/apt/sources.list 文件，在文件最前面镜像源： # 阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse # 清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse # 中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-secur","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:4","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"Linux 驱动和应用的体验 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"100ask Ubuntu 主机 的配置工作 配置 100ask Ubuntu 主机 的环境： 先执行：sudo apt-get update 再执行： wget --no-check-certificate -O Configuring_ubuntu.sh https://weidongshan.coding.net/p/DevelopmentEnvConf/d/DevelopmentEnvConf/git/raw/master/Configuring_ubuntu.sh \u0026\u0026 sudo chmod +x Configuring_ubuntu.sh \u0026\u0026 sudo ./Configuring_ubuntu.sh 在 NAT 网络下，要想开发板能通过 NFS 挂载 Ubuntu 主机，需要修改 mountd 端口为 9999。详情看《嵌入式Linux应用开发完全手册_韦东山全系列视频文档全集》的 P94 第二篇 4.1.3。 修改 VM 虚拟机 中 Ubuntu 主机 的 IP 为固定的。详情看 P95 第二篇 4.1.4。（可以不做） 开发板网络设置。详情看 P117 第二篇 6.4。 开发板挂载 Ubuntu 主机 的 NFS目录。详情看 P123 第二篇 6.7。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:1","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"准备交叉编译工具链 先准备好 Linux Ubuntu 平台运行的的针对 ARM 平台的编译器 gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf。 使用 Vim 工具编辑 ~/.bashrc 文件，在最后添加： export ARCH=arm export CROSS_COMPILE=arm-linux-gnueabihfexport- export PATH=$PATH:/home/\u003c用户目录\u003e/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin 并在终端键入 source ~/.bashrc 使其生效。 然后在终端测试一下 arm-linux-gnueabihf-gcc -v。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:2","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"第一个应用 略，略略略~。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:3","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"第一个驱动 注意： 驱动程序用到 Linux 内核的 API，编译驱动程序之前要先编译内核。 编译驱动时用的内核和嵌入式板子上运行的内核，要一致（不一致的话，不能正常安装 .ko 模块，强装会有意想不到的问题）。 嵌入式板子更换内核（重新编译）时，也要把其他所有驱动程序都重新编译，替换原来的。 编译内核 在 Linux 源码目录里执行： make mrproper make xxx_imx6ull_defconfig make zImage -j4 make dtbs 释义： make mrproper 命令会删除所有的编译生成文件、内核配置文件(.config文件)和各种备份文件，所以几乎只在第一次执行内核编译前才用这条命令。make clean 命令则是用于删除大多数的编译生成文件，但是会保留内核的配置文件.config，还有足够的编译支持来建立扩展模块。所以你若只想删除前一次编译过程的残留数据，只需执行 make clean 命令。总而言之，make mrproper删除的范围比 make clean 大，实际上，make mrproper 在具体执行时第一步就是调用 make clean。 配置文件位于内核源码 arch/arm/configs/ 目录。 得到 内核文件 和 设备树文件 这两个文件： arch/arm/boot/zImage arch/arm/boot/dts/100ask_imx6ull-14x14.dtb 编译内核模块 在 Linux 源码目录里执行： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules sudo make ARCH=arm INSTALL_MOD_PATH=/home/book/nfs_rootfs modules_install 释义： 第一条，如果设置好了 ARCH 和 CROSS_COMPILE 环境变量，直接键入 make modules 也可。 第二条命令是把模块安装到 /home/book/nfs_rootfs 目录下备用 ， 会得到 /home/book/nfs_rootfs/lib/modules 目录。 更新目标板 有很多种方式传输文件，详见 “PC 与 嵌入式板 传输文件的方式汇总” 章节。将 zImage 、 100ask_imx6ull-14x14.dtb 和 lib 目录分别放到嵌入式板子的 /boot 、 /boot 和 /lib 目录，比如使用方便的 nfs 文件系统；然后存储 sync，重启 reboot。 编写、编译驱动 按照驱动程序的编写规则，写好驱动程序（hello_drv.c）、相应的测试程序（hello_drv_test.c），以及准备好 Makefile 文件。 举例 Makefile 文件： # 修改为 Linux 内核所在目录 KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4 all: make -C $(KERN_DIR) M=`pwd` modules $(CROSS_COMPILE)gcc -o hello_drv_test hello_drv_test.c clean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.order rm -f hello_drv_test obj-m += hello_drv.o 确保三个环境变量 ARCH、CROSS_COMPILE 和 PATH（交叉编译器的 /bin 目录）都以就绪。 执行 make。产生 驱动程序的内核模块（hello_drv.ko）和 测试程序 ARM 端的二进制可执行文件，共两个文件，转移到 嵌入式目标板子上。 安装驱动程序模块 insmod hello_drv.ko。 在 lsmod 命令下可以看到 hello_drv 模块；执行 cat /proc/devices 可以看到 对应的设备及其主设备号；执行 ls -l /dev/\u003c设备名称\u003e 可以看到此设备的主、此设备号等更多信息。 执行测试程序进行验证。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:4","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"学至此的一点启示，也许不对 芯片厂家（大概）应该都会提供完整的 U-boot、 Linux 内核、芯片上硬件资源的驱动程序。 看韦东山的 imx6ull 板子的裸机开发源码，可以得知，启动文件 .s 文件需要看懂，都大同小异，然后官网会提供所有寄存器的 .h 文件及其结构体，然后每个外设似乎还会提供初始化、配置的代码（因为韦的源码里面，外设底层配置代码为英文注释的，99%的概率是官方提供的），这样就好了嘛，外设的底层驱动可以都扒官方例程。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:5","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"构建系统简约步骤 这里只简约说明编译步骤，并非详细使用说明（以后的系列文章可能会有）。 每个部分单独手动简约步骤 以下工作进行前，先配置好环境变量和开发链工具等工作，详见 “准备交叉编译工具链” 章节。 1、编译 u-boot，配置文件位于 u-boot 源码的 configs/ 目录，生成 u-boot 启动镜像 u-boot-dtb.imx。在 Uboot 目录下执行： make distclean make mx6ull_14x14_evk_defconfig make 2、编译内核，配置文件位于内核源码 arch/arm/configs/ 目录，生成 arch/arm/boot/zImage 内核文件 和 arch/arm/boot/dts/xxx_imx6ull-14x14.dtb 设备树文件。在 Linux 内核目录下执行： Linux-4.9.88$ make mrproper Linux-4.9.88$ make xxx_imx6ull_defconfig Linux-4.9.88$ make zImage -j4 Linux-4.9.88$ make dtbs 3、编译内核模块，并把模块文件导入 /home/book/nfs_rootfs/lib/modules 目录。在 Linux 内核目录下执行： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules sudo make ARCH=arm INSTALL_MOD_PATH=/home/book/nfs_rootfs modules_install 使用 Buildroot 构建系统简约步骤 Linux 平台上有许多开源的嵌入式 linux 系统构建框架，这些框架极大的方便了开发者进行嵌入式系统的定制化构建，目前比较常见的有 OpenWrt, Buildroot, Yocto 等等。其中 Buildroot 功能强大，使用简单，而且采用了类似于 linux kernel 的配置和编译框架。 制作根文件系统方法比较： Busybox。Busybox 本身包含了很了 Linux 命令，但是要编译其他程序的话需要手工下载、编译，如果它需要某些依赖库，你还需要手工下载、编译这些依赖库。如果想做一个极简的文件系统，可以使用 Busybox 手工制作。 Buildroot。它是一个自动化程序很高的系统，可以在里面配置、编译内核，配置编译 u-boot、配置编译根文件系统。在编译某些APP时，它会自动去下载源码、下载它的依赖库，自动编译这些程序。Buildroot 的语法跟一般的 Makefile 语法类似，很容易掌握。 Yocto。NXP、 ST 等公司的官方开发包是使用 Yocto，Yocto 语法复杂，容量大（10GB 以上），编译时间长。 Buildroot 是一组 Makefile 和补丁，可简化并自动化地为嵌入式系统构建完整的、可启动的 Linux 环境（包括 bootloader、 Linux 内核、包含各种 APP 的文件系统）。 Buildroot 运行于 Linux 平台，可以使用交叉编译工具为多个目标板构建嵌入式 Linux 平台。 Buildroot 可以自动构建所需的交叉编译工具链，创建根文件系统，编译 Linux 内核映像，并生成引导加载程序用于目标嵌入式系统，或者它可以执行这些步骤的任何独立组合。例如，可以单独使用已安装的交叉编译工具链，而 Buildroot 仅创建根文件系统。 学习更多关于 Buildroot 知识请参考这里。 扩展学习： buildroot 下进入 menuconfig 包选择配置配置界面 make menuconfig。 buildroot 下单独编译 u-boot make uboot-rebuild。 buildroot 下进入内核 make menuconfig 配置选项界面 make linux-menuconfig。 buildroot 下单独编译某个软件包 make \u003cpkg\u003e-rebuild。 buildroot 下进入 busybox 配置界面 make busybox-menuconfig。 buildroot 下生成系统 sdk，最后生成的目录在 output/images/ 目录下 make sdk。 构建根文件系统： 在 Buildroot 目录下执行： make clean make xxx_imx6ull_defconfig make all 漫长长长（2~6个小时，视电脑性能）的等待后编译完成。 可以配置多个不同的配置文件 xxx_imx6ull_defconfig，比如有的带 qt5 ，有的用于构建最精简的文件系统，有的用于另一块板子等待。 编译成功后文件输出路径为 output/images： buildroot 20xx.xx ├── output ├── images ├── xxx_imx6ull-14x14.dtb \u003c--设备树文件 ├── rootfs.ext2 \u003c--ext2 格式根文件系统 ├── rootfs.ext4 -\u003e rootfs.ext2 \u003c--ext2 格式根文件系统 ├── rootfs.tar ├── rootfs.tar.bz2 \u003c--打包并压缩的根文件系统，用于 NFSROOT 启动 ├── sdcard.img \u003c--完整的 SD 卡系统镜像 ├── u-boot-dtb.imx \u003c--u-boot 镜像 └── zImage \u003c--内核镜像 对应的文件更新到嵌入式板子的对应位置，或者使用 sdcard.img 或者 emmc.img 完整系统映像文件烧入 sd卡 或 emmc。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:6","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"PC 与 嵌入式板 传输文件的方式汇总 （如有更多方法将会补充） ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"网络传输：ETH/WiFi SSH 使用 MobaXterm 或 FileZilla 等等，通过 SSH 链接 Linux 板，进行文件传输。 NFS NFS 将服务端的文件系统目录树映射到客户端，而在客户端访问该目录树与访问本地文件系统没有任何差别。 如果你使用的是 VMware NAT 方式，假设 Windows IP 为192.168.1.100，在嵌入式 Linux 板子上执行以下命令(注意：必须指定 port 为2049、 mountport 为9999)： mount -t nfs -o nolock,vers=3,port=2049,mountport=9999 192.168.1.100:/home/book/nfs_rootfs /mnt 如果你使用的是 VMware 桥接方式，假设 Ubuntu IP 为192.168.1.100，在嵌入式 Linux 板子上执行以下命令： mount -t nfs -o nolock,vers=3 192.168.1.100:/home/book/nfs_rootfs /mnt mount 成功之后 ， 嵌入式 Linux 板子在 /mnt 目录下读写文件时， 实际上访问的就是 Ubuntu 中的 /home/book/nfs_rootfs 目录，所以嵌入式 Linux 板子和 Ubuntu 之间通过 NFS 可以很方便地共享文件。 tftp 略。需要时再看。《嵌入式Linux应用开发完全手册_韦东山全系列视频文档全集V2.8.pdf》P357、P373。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:1","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"USB 传输： 最 x 的方法 U 盘拷贝。 NXP 公司给 IMX6ULL 提供了烧写工具： mfgtools。或者对于 imx6ull 使用 100ask 开发的 100ask imx6ull flashing tool（详看 《【主线剧情01】ARM IMX6ULL 基础学习记录》的 “100ASK IMX6ULL Flashing Tool 工具使用” 章节）。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:2","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["主线剧情"],"content":"串口传输：rz/sz 命令 在\"板砖\"工地上网口、USB 口统统没有，那我们还可以使用串口。 注意： rz/sz 命令不稳定，不可靠，在没有其他办法的情况下再用它。 rz/sz 命令传输速率太小，适合传输小文件，不适合大文件。 上位机往板子发：rz 在 MobaXterm 里面通过串口连接并登录嵌入式 Linux 板子，然后输入 rz 命令，此时终端会提示等待接收，此时在 MobaXterm 里面鼠标右键会弹出一个选择框，点击 Send file using Z-modem 来选择要传输文件。 板子往上位机发：sz 嵌入式 Linux 板子启动进入 Linux 后，在串口中执行命令 sz \u003c要发送的文件\u003e，然后按住 shift 键的同时，用鼠标右键点击串口界面，选择 Receive file using Z-modem，最后在弹出的文件框保存文件。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:3","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["规范"],"content":"比较详细、全名的介绍了C \u0026 MCU 编写规范和其他","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":" 本文的源文在Qitas/coding-style-and-more: C 编写规范和其他。永远地不定期更新。CC-BY-NC-SA 4.0。 (github.com)。今后只在上面的链接里，这里不会跟进。 本文系广泛撷取、借鉴和整理，侵删。本文适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！ 按：引用观视频工作室视频【大师计划·林宝军03】北斗三号总师：我来跟你说说，…里面总师受访时所说的话： 5:48：“…所以我经常讲，要把一个产品做好，其实有三方面，一个是技术，一个是质量，一个是管理，这三方面；技术水平，质量保障能力和管理能力，三条腿哪个都少不了，少一个，这个东西（航天）也做不上去，其实技术只是一方面，…”。 6:44：“…光是技术上去了，不见得能做出一个系统。对我们工程来讲，就是（需要）规范的文化，什么意思呢，比如我们几十年的航天经验，我把这个经验总结成文字，总结成规范，不管是谁做，只要有一定的经验，按这个规范做出来，做得卫星出来，打到天上去就能好用，这就是规范文化。包括匠人文化和规范文化，最后都是按规矩去做，它强调的是解决了怎么做的问题，但它有一个缺点，没强调为什么，其实我认为在做的过程中，加个为什么可能更好。” ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:0:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"O 目录 [TOC] ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:1:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"1 日常素养 维护干净整洁的编程环境（保持愉悦的心情，干净整洁的桌面，友好和蔼的同事等等）。 身体坐直，按时走走，保证睡眠，计划运动。 要学习或使用新东西，全网搜集到好的手册和资料，就已经成功了一半（所谓好的资料不一定是官方教程或手册，可以是别人总结的入门系列文章或视频，适合自己快速摄入的才是好的）。 循序渐进，由浅入深。对什么也不感兴趣、不深入是浮躁，而且不经过深入全面的了解就硬扛大型项目也是一种浮躁。 习惯去看源代码（熏陶优秀代码风格，有时还能发现新东西）。 先搞清楚需求，再构思，再开发，顺序不能错。 不要重复造轮子，时常逛开源网站，有新想法可以先去找轮子，也许比自己写的更好，相信前人的智慧和同行们雪亮的眼光。 编译错误，如果不明白哪错了，直接无脑复制编译器的错误信息扔到搜索引擎框，然后点“搜索”按钮（大部分报错都是语法错误）。 关于提问，是一门艺术： 谈谈提问的艺术 | How To Ask Questions The Smart Way 《提问的艺术：如何快速获得答案》（精读版） 如何问出一个好问题？| 提问的艺术 有结对编程，协作开发的能力。 有写文档的习惯（对项目写文档，或者日常写博客，或者没事就画一画流程图梳理想法）（不要在技术文章里写“日记”、写“小说”。），条理清晰，简化描述（Keep it stupid simple），并且一定要写上用例，写上例子，写上实例（重要的事情讲三遍）！ 做好版本管理，有备份的意识（打压缩包写上时间也好，使用git工具也好，放到U盘里也好，传到私人网盘也好）。 时常看书，时常看看同行的文章，常读常新。 不止技术，不想当将军的士兵不是好士兵（有的人领导能力强，有的人能开发有竞争力的产品，有的人能把知识讲地透彻，有的人理论功底强），时常把视角拉远看一看。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:2:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"2 程序框架要点 软件工程结构的分层思想永不灭。 标准化、通用化和可靠性设计高于功能设计。 划分好文件、功能函数和所需变量。函数 “低耦合，可重用，参数化，注释全”，变量尽量用结构体打包；可重用意味着直接复制代码或者直接复制文件到另一个项目上直接就用。 功能增加裁剪的灵活性：做好预编译设置。方便于切换调试版本和执行版本，方便于切换行为模式，方便于剪裁功能块；功能剪裁用一个名字带\"_config\"的文件集中管理，供用户修改各种剪裁用的宏定义，就像总控台。 参数化设计的适应性：对比如协议解析、模块/功能数量增减、数据范围的变化适应等地方尽量写的通用，通过参数设定来改变运行时/编译时的功能灵活变化。 关于 MCU 的编写框架，我目前大抵就认我自己的开源项目 “stm32_framework” 的吧，规范都对齐这个项目。 MCU C 的一些规范： p.s 以下为项目 “stm32_framework” 编写时由经验形成的一部分规范，具体形式以此项目的源码和架构为准！ 本\"C 编写规范\"的全部规则都适用。 尽量利用硬件资源和外设资源，减少 cpu 负担。 系统外设功能的启用与否均用宏定义 SYSTEM_SUPPORT_XX 来管理剪裁。 RTOS任务函数均使用 os_task_xx_xx() 命名，属于\"os_task\"。 中断优先级分组选用分组4，即16级抢占优先级，不用0级响应优先级。 IO的低电平为有效电平，高电平截止或者无效；按键IO尽量都使用外部中断。 至少用一个定时器提供1ms或者10ms的时基，再用软件分频为 50ms/100ms/300ms/1s 等。 外设（Periph）和设备（Devices）分别初始化，外设的启停成对编写，命名统一。 通讯外设的发送和接收都使用中断，并尽量使用上DMA，以串口为例如下： 接收：（依时间间隔区分帧为例） 接收中断-\u003e打接收标志位，记当前时间（定时器计数器），比较上次接收的时间，启动DMA-\u003e接收缓冲区（足够大，大于2帧）-\u003e送解析函数。 发送：（类 lwip 的发送逻辑，事件驱动） 要发送的串放入 发送缓冲区，检查发送启动标志位是否就绪，若就绪就打 发送启动标志位-\u003e发送中断中，检测发送启动标志位，判断是否发送 发送缓冲区 的串，发完清此标志位，即设为就绪态。 等等等等。 通讯尽量使用成熟的协议来封装数据。 以打包、解包形式进行通讯。鉴于见识有限，协议选择还需要广泛调研和商榷，以下仅为举例 串口通讯协议可以上 Modbus。 CAN 通讯协议可以上 CANOpen。 TCP 通讯协议还有待确定，需要选择一个支持大带宽的。 可以用 json 格式封装数据。 如果要自定串口等接口的通信协议，要考虑的点： 一帧有确定的长度； 一帧有确定的帧头和帧尾，帧头和帧尾可以适当多加几个位增加容错； 保证一帧尽量连续传输，没有中断； 在有限确定的时间内完成发送； 数据的发送接收相关的函数与数据的打包和解析的相关函数，编写规范上应相互解耦，可重用； 接收完成标志位的置位大抵有两种方式：一个是判断有帧头和等待帧尾来判断为一帧，一个是从接收字节开始计时并在一定时间间隔没有接收数据后判断为一帧。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:3:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"3 代码格式化工具列举 p.s 针对较乱的\"祖传代码\"做初步治疗使用。代码格式化工具还可以把代码中的 tab 符变成四个空格，这样，当代码在不同的编辑器中打开时不会产生格式错误，所以可以用 AStyle 自己定制一份配置文件，在每次码完代码之后顺手运行一下 AStyle 即可。 (TODO)下面部分条目尚未补全。 (TODO)查一查astyle配置文件的用法，按照自己的规范形式，写一个配置文件 通用工具 AStyle： ​ 配置文件： c-code-style仓库中的 astyle-code-format.cfg 文件 ​ AStyle官网：AStyle官网 ​ AStyle is a great piece of software that can help with formatting the code based on input configuration. ​ This repository contains astyle-code-format.cfg file which can be used with AStyle software as command line below. astyle --options=\"astyle-code-format.cfg\" \"input_path/*.c,*.h\" \"input_path2/*.c,*.h\" VS Code：在 VS Code 中搜索 AStyle 插件 即可。 MDK：关于“把代码中的 tab 符变成四个空格”，在 MDK 的 Edit 的 Configuration 中，把 “Insert spaces for tab” 都勾上即可。 IAR： Eclipse： ​ 配置文件： c-code-style仓库中的 eclipse-ext-kr-format.xml ​ Repository contains eclipse-ext-kr-format.xml file that can be used with eclipse-based toolchains to set formatter options. ​ It is based on K\u0026R formatter with modifications to respect above rules. ​ You can import it within eclipse settings, Preferences -\u003e LANGUAGE -\u003e Code Style -\u003e Formatter tab. Source Insight： Notepad：关于“把代码中的 tab 符变成四个空格”，在 Notepad 的 设置 的 语言 中，把制表符框的 “替换为空格” 勾上即可。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:4:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"3.5 数据结构简述 数据结构 + 算法 = 程序；数据结构：现实问题的符合计算机存储的建模；算法：解决现实问题的步骤（符合有穷性，确定性，可行性等）。 一个软件项目，数据结构整理、设计的好，调用、修改和查询会特别方便，达到事半功倍的效果。 数据结构： 按照逻辑关系：表示元素的连接关系 集合，线性（线性表，队，栈等），树状（一对多），图状（多对多）。 按照存储关系： 顺序存储：如数组；位置连续，要提前申请空间；但会产生内存碎片，改动时前后要跟着变。 链式结构：如链表，链式、离散、节点化，空间可动态分配，改动方便（改节点的指向）；但空间占用大，查找不便。 索引存储：索引-数据 的结构。 散列存储：暂略。 数据运算： 每个数据结构要实现的基本运算：增、删、改、查、判（判空，判满）、排（排序）、复（复位）。 更复杂的运算可用以上基本运算实现。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:5:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"4 普适规则（General rules） 第一条，请您重视编写规范！可以有代码洁癖。 使用 C99 标准。 一个 tab 四个空格。 运算符前后空一格，给函数传递的多个变量之间在逗号后空一格，一元操作符后不要加空格，下面为例： for (i = 0; i \u003c 5; ++i) /* i 永远滴神 */ tempNum = 3 + 4; int32_t tempNum = sys_example_sum(4, 3); sys_example_func(\u0026time_data_struct, !(++is_time_show)); 注释里，字母和数字的两边空一格，尽量用/* ……… */注释，而非//...，例如： /* 用 3 这个数字代替洋文 three 了解了吗 */ 关于命名： 变量和函数的命名都只用小写（尽量），宏定义使用全大写（尽量），并遵循 “属什么 _ 是什么 _ 做什么” 的命名形式，如：sys_irq_disable()，属于 sys 级别函数，是 irq 管理，做 dsiable 的功能。不要用晦涩的英文缩写甚至拼音就不用讲了吧。 具有互斥意义的变量或者动作相反的函数应该是用互斥词组命名，如： add/remove begin/end create/destroy insert/delete first/last get/release increment/decrement put/get add/delete lock/unlock open/close min/max old/new start/stop next/previous source/target show/hide send/receive source/destination copy/paste up/down 不要使用单字节命名变量，但是允许使用 i， j， k 这样的作为局部循环变量。 文件统一采用小写命名。 关于函数、变量、宏定义等的命名看 5 具体各部分的规范形式章节。 控制语句总加括号（即使分支执行语句只有一句），括号在竖方向对齐，用 tab 把层次分地清清楚楚，例如：（为了节省空间，下面示例用横向写~） if( ) for (i = 0; i \u003c 5; ++i) do switch (check()) { { { { case 0: }else if( ) } }while( ); fsm_do_a(); { break; case 1: }else fsm_do_b(); { break; default: } break; } 层次分明，多用 tab 划分层次关系（预编译代码也不例外），例如： #ifdef _DEBUG #define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_) #else #define DEBUGMSG(msg,date) #endif 用 if (check_func()) { ... } 代替 if (check_func() == 1)，判断是否为 ‘0’ 可以用后者的写法（或者用 !check_func()），判断 ‘1’ 用前者写法。 判断指针是否为空只用 “NULL”，即 void* ptr; if (ptr == NULL || ptr != NULL) { ... }。 不用变长数组，用内存分配释放函数 malloc() 和 free()。 循环尽量用 for(;;) 替代 while(1) 等，无论有限次循环还是无限次循环，条件循环语句用后者。 长运算语句尽量多的用括号（每一步运算都用括号括起来），并做好空格增加可读性，例如： temp = ( 0x7F \u003c\u003c ((xByte - 1) * 8) ); #define MAX( x, y ) ( ((x) \u003e (y)) ? (x) : (y) ) 尽量减少数据传输过程中的拷贝。 大块内存使用请用内存管理（自实现的 malloc 和 free）。 每一个文件在最后留有至少一个空行。 对于 c 语言的文件，其 .h 文件的主体文件包含在下面的括号之内（标有 “…” 的位置）： 私有变量不要放在 .h 里面声明，公有变量的声明（加 extern 修饰符）放在 .h 文件里面以供其他文件调用。 在 .c 文件中 include 自己对应的 .h 文件和需要用到的 .h 文件，不要引用多余的 .h 文件；.h 文件中同样只引用用到的头文件，但是头文件尽量写成无依赖的，这就考验整个系统的规划和设计。 如果一个模块包含了多个 .c 源文件，那么将它们放入同一个文件夹并用模块名命名，然后只用一个 .h 头文件声明接口。 Every file (header or source) must include license (opening comment includes single asterisk as this must be ignored by doxygen). Use the same license as already used by project/library. #ifndef TEMPLATE_H #define TEMPLATE_H #include \u003cstdint.h\u003e#include \"all_other_custom_file.h\" /* 当 C 和 C++ 代码混合编译的时候，在下面两个 __cplusplus 标识的中间放 C 部分的声明代码 */ #ifdef __cplusplus extern \"C\" { #endif /* __cplusplus */ ... /* C 部分的声明代码 */ #ifdef __cplusplus } #endif /* __cplusplus */ #endif /* TEMPLATE_H */ … 更多网友总结的杂类细节规范、规则： 学C/C++语言，32个必备修养！ (qq.com)； etc… ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:6:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"5 具体各部分的规范形式 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"关于函数定义形式（Functions） 小写；星号 * 靠近类型名一端；用\" _ “分割语义；对齐以保持良好阅读性； 命名遵循 属什么 _ 是什么 _ 做什么 的形式； void sys_example_init(void); const char* sys_string_generater(void); my_struct_t* sys_example_func(int32_t para1, int32_t para2); void fsm_state_set(int32_t fsm_ID); my_type_t fsm_state_get(void); my_ptr_t* menu_get_current_ptr(void); 函数的局部变量数量最好不超过 5-10 个，并且不要占用太多的内存/栈资源； 一个函数尽量只做一件事，否则划分为多个更小的函数；不要重复，保持各个代码块的独特性； 低耦合，可重用，参数化，注释全！ 对函数的错误返回要做全面的处理；一般 返回 0 表示正确，返回其他表示错误，具体的值表示错误代号，可用定义了所有错误类型的枚举变量作为函数返回值类型，或者返回值 0 表示成功，正数表示失败，此正数可以表示错误代码；并设计专门的机制对错误标识做处理。 对函数的参数做合法性检查；检查指针；检查变量范围，变量有大小限制的，在注释里写明；在其他地方调用此变量的时候要进行检查或限幅： /* 幅值系数，范围 0~1 */ float wave_point_A = 0.8; /* 检查：*/ if( wave_point_A \u003e 1 ) wave_point_A = 1.0f; if( wave_point_A \u003c 0 ) wave_point_A = 0; /* 限幅：*/ wave_point_A \u003e 1 ? 1.0f : wave_point_A; wave_point_A \u003c 0 ? 0 : wave_point_A; 对于函数可能传入的参数是不定的任意类型，定义形参用 void* 修饰。 函数的嵌套不要过多，一般控制在最多 4 层。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"关于变量定义形式（Variables） 同类型的变量声明放在一行，变量定义时避免用函数返回值； 小写，星号 * 靠近类型名一端（除了一行多变量定义的情况），对齐以保持良好阅读性； char* a; char *p, *n; 用” _ “分割语义，命名遵循 “属什么 _ 是什么 _ 做什么” 的形式，意义明确，也不容易重名； 避免使用 stdbool.h 里的 “true” 或 “false”，用 “1” 或 “0” 代替； 数据类型，除了char、float 和 double，都使用 stdint.h 库里面的，统一起来； 合理的常用 const 修饰符，防止变量或指针在层层传递过程中被篡改，或者在定义的时候永远加上 const 修饰符，例： const unsigned char xByte; /* xByte 的内容不能变 */ const char *p; char const *p; /* 二者一样，都是 p 所指向的内容不能变 */ char* const p; /* const 修饰的是 p ， p 不能修改，即地址不能修改，其指向的内容可以修改 */ const void* const p; /* p 所指向的内容和 p 地址本身都不能改变 */ /* p.s char* c 与 char *c 没有任何区别 signed int 和 unsigned int 区别很大，前者是可以表达正负数的源码，后者是从 0 开始的正数或是一串参与逻辑运算的二进制 */ 变量如果是低有效，变量名加尾缀”_n\"，比如使能 en 是低有效（en 上面有一横），则命名为\"en_n\"； 明确全局变量的初始化顺序，系统启动阶段，使用全局变量前，要考虑到全局变量该在什么地方初始化，使用全局变量和初始化全局变量之间的时序关系一定要分析清楚； 明确变量的作用域，防止在预想的作用域外能够调用到具体的某个变量，降低模块间耦合度。 尽量减少不必要的数据类型转换。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"关于结构体、枚举和类型定义形式（Structures, enumerations, typedefs） 适用 “关于变量定义形式（Variables）“里面的所有内容； 结构体和枚举可以用 typedef 修饰； 结构体里的成员小写，枚举里的所有成员大写； 结构体定义和类型定义后加 “_t” ； typedef enum { MY_ENUM_OK = 0, MY_ENUM_TESTA, MY_ENUM_TESTB, }my_enum_t; struct SIMPLE_struct_t struct /* 只用一次的结构体 */ typedef struct { { { int a; int a; int a; char b; char b; char b; double c; double c; double c; }; }abc; }Simple_struct_t; 结构体的实例化尽量用\"表格\"形式，并在每列头部写好注释，例如： struct fsm_states_struct_t fsm_XXX1_state[XXX1_State_MAX] = /*定义描述名为‘fsm_XXX1’的状态机的状态图*/ { /*跳转条件都初始化为0*/ /* 状态 执行函数 跳转条件数量 各个条件跳转后的状态（注：根据跳转条件的优先级从高到低往下写）*/ {(unsigned int)XXX1_State_1, fsm_XXX1_state_1_Fun, 2,{ {0,(unsigned int)XXX1_State_5 }, {0,(unsigned int)XXX1_State_2 }, }}, {(unsigned int)XXX1_State_4, fsm_XXX1_state_4_Fun, 1,{ {0,(unsigned int)XXX1_State_5 }, }}, }; /*或者*/ Simple_struct_t simple = { .a = 4, .b = 5, }; 函数指针定义（的类型定义）的写法形式如下，函数指针名加后缀 “_ fn”，类型定义函数指针加后缀 “_ typedef _ fn”： /* 函数指针定义写法举例 */ unsigned char (*sys_print_compile_time_fn)(unsigned char); typedef uint8_t (*my_func_typedef_fn)(uint8_t p1, const char* p2); /* 用法 */ unsigned char (*sys_print_compile_time_fn)(unsigned char); typedef unsigned char (*sys_print_compile_time_typedef_fn)(unsigned char is_print_compile_time); unsigned char print_compile_time(unsigned char is_print) { if(is_print) { printf(\"%s\\n\",__TIME__); return 0; } return 1; } unsigned char print_compile_date(unsigned char is_print) { if(is_print) { printf(\"%s\\n\",__DATE__); return 0; } return 1; } int main() { /* 用法1，给函数指针赋值 */ sys_print_compile_time_fn = print_compile_time; /* 用法2，定义一个函数指针变量，并赋值 */ sys_print_compile_time_typedef_fn print_compile_time_fn; print_compile_time_fn = print_compile_time; /* 调用 */ (*sys_print_compile_time_fn)(1); (*print_compile_time_fn)(1); print_compile_time_fn = print_compile_date; (*print_compile_time_fn)(1); } ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:3","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"关于宏定义和预编译指令定义形式（Macros and preprocessor directives） 宏定义使用全大写（尽量），并遵循 “属什么 _ 是什么 _ 做什么” 的命名形式； 尽量把常数数字用宏定义代替；常量建议使用 const 定义来代替宏；前面这两句话实际是矛盾的，因地制宜吧，优化速度用前者，优化空间用后者； 对宏定义中的所有输入和输出（整个结果语句）用括号保护起来，长句用 do{...}while(0)。 #define MY_MACRO(x) ((x) * (x)) #define MIN(x, y) ((x) \u003c (y) ? (x) : (y)) #define SET_POINT(p, x, y) do{ (p)-\u003epx = (x); (p)-\u003epy = (y); }while(0) /*或者下句更好：*/ #define SET_POINT(p, x, y) do{ \\ /* Backslash indicates statement continues in new line */ (p)-\u003epx = (x); \\ (p)-\u003epy = (y); \\ }while(0) /* 2 statements. No semicolon after while loop */ 预编译指令语句使用 tab 标识好层次： #if defined(XYZ) /* Do when XYZ defined */ #if defined(ABC) /* do when ABC defined */ #endif #else /* Do when XYZ not defined */ #endif ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:4","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"关于注释的形式（Comments） 注释里尽量写为什么，而不是把重点放在做了什么，虽然后者也很重要。 尽量使用 Doxygen 的注释语法，然后可以使用 Doxygen 这个软件从源码工程的注释中自动化生成软件工程的说明文档，注释写的全（包括文件和API等的描述等等）那么生成的文档也会很全。Documented code allows doxygen to parse and general html/pdf/latex output, thus it is very important to do it properly。目测目前我见过的用源文件产生手册的大型项目有：LWIP、FreeRTOS、ST HAL、CMSIS等，关于 ST HAL 库里面的注释形式的详细情况请看 “8 ST HAL 的编写形式” 章节！ Doxygen 的注释语法规范。网上很多，这里列举几个： Doxygen 注释语法规范 - 黄树超 - 博客园 (cnblogs.com)。 C语言中的Doxygen注释模板_胡图图-CSDN博客_c语言函数注释模板。 需要注意的是，Doxygen 并不处理所有的注释，其重点关注与程序结构有关的注释，比如：文件、类、结构、函数、全局变量、宏等注释，而忽略函数内局部变量、代码等的注释。先从文件开始注释，然后是所在文件的全局函数、结构体、枚举变量、命名空间→命名空间中的类→成员函数和成员变量。 使用 Doxygen 生成文档的教程（这几个教程里面也包含有 Doxygen 的语法介绍）： Doxygen给C程序生成注释文档 - on_the_road - 博客园 (cnblogs.com)。 Doxygen生成注释文档_destiny的专栏-CSDN博客_doxygen生成文档。 代码注释规范之Doxygen - silencehuan - 博客园 (cnblogs.com)。 Vs Code Doxygen 格式注释生成插件：Vs code自动生成Doxygen格式注释_wang0huan的博客-CSDN博客。 p.s 关于 Doxygen 文档的更多具体写法用时再详看进行手写，或者使用生成插件 下面列举几种花哨的，其中有我自己“创造”的。函数定义的注释，主任务函数的注释，用于显眼！ /*__________函数简述_____________*/ /******************************** * 描述：函数详细描述 * 参数： 1、第一个形参名 描述 2、第二个形参名 描述 ... * 返回： 返回值类型 描述 ********************************/ /*____________运行错误提示和打印______________________________*/ /******************************** * 描述：表示某步骤运行有问题，串口提示，灯提示，声提示 * 参数： 1、errmsg 错误或者警告信息 2、errid 故障代号 3、err_flag 错误类别（可选flag_Fault或flag_Warning） * 返回： NULL ********************************/ /*************\\ * Multi-line * * comment * \\*************/ /*______________________\\\\\\ ///__________________________* *___________________________________外设初始化函数_______________________________________* *_______________________/// \\\\\\__________________________*/ 文件说明注释： /************************************************* 开头这里放开源协议的描述源文 Copyright © xxx Co., Ltd. 1998-2018. All rights reserved. File name: 文件名 Author： 作者 Version: 版本号 Description: 用于详细说明此程序文件完成的主要功能，与其他模块 或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系 Others: 其它内容的说明 Log: 修改日志，包括修改内容，日期，修改人等 *************************************************/ // Doxygen 格式 /** * @file main.c * @author your name (you@domain.com) * @version 0.1 * @date 2021-06-30 * @license GNU General Public License (GPL) * @brief * @attention * */ 程序文件开头的版权信息写法列举： 引用自软件中声明版权的写法-专业指导文档类资源-CSDN下载，侵删。 正确的格式应该是：Copyright [dates] by [author/owner] © 通常可以代替Copyright, 但是不可以用(c)。 All Rights Reserved 在某些国家曾经是必须的，但是现在在大多数国家，都不是法律上必须有的字样。 参见下面几个正确的格式： ©1995-2004 Macromedia, Inc. All rights reserved. ©2004 Microsoft Corporation. All rights reserved. Copyright © 2004 Adobe Systems Incorporated. All rights reserved. ©1995-2004 Eric A. and Kathryn S. Meyer. All Rights Reserved. 请注意标点符号和大小写的用法，这也是专业精神的一种体现。 现在流行some rights reserved：creativecommons.org some rights reserved 和copyright 本身并不矛盾，但是其中的界限更多是一个道德问题，真正的保留一部分权力，是指给浏览者fair use 的权利，fair use的界定也决不是随便乱用，或者抄袭。 甚至说，除了copyright, 还有copyleft,它的定义是为了程序员开发能够共享源代码的一个方式，英文里free, 并不仅仅是免费。 而且这种的源码公开免费使用，和版权也一点都不冲突。请大家不要误解。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:5","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"其他常用写法汇集（不定期更新） 将一些少见的并且技巧性、灵活性较高的写法进行罗列。 实用技巧 置位和清位，常用于嵌入式开发。 static volatile unsigned int *reg_temp = (volatile unsigned int *)(0x20E0084); /* 置位的标准写法 */ /* 下句表示把 内存中 0x20E0084 位置的 第1、2、5、14位进行置1，其他位不变 */ *reg_temp |= ( (1 \u003c\u003c 14) | (1 \u003c\u003c 5) | (1 \u003c\u003c 2) | (1 \u003c\u003c 1) ); /* 清位的标准写法 */ /* 下句表示把 内存中 0x20E0084 位置的 第0、3位进行清0，其他位不变 */ *reg_temp \u0026= ( ~( (1 \u003c\u003c 3) | (1 \u003c\u003c 0) ) ); /* 读寄存器 */ volatile unsigned int val = *reg_temp; 创建内存地址上连续区域的结构体，常用于嵌入式开发。 typedef struct { volatile unsigned int URXD; /**\u003c UART Receiver Register, offset: 0x00 */ volatile unsigned char RESERVED_0[60]; volatile unsigned int UTXD; /**\u003c UART Transmitter Register, offset: 0x40 */ volatile unsigned int UCR1; /**\u003c UART Transmitter Register, offset: 0x44 */ } Periph_x_Type; /* Periph_x 这个外设的寄存器的基地址为 0x2020000 */ #define Periph_x_BASE (0x2020000u) /* 设置结构体 Periph_x 的地址为 Periph_x_BASE */ #define Periph_x ((Periph_x_Type *)Periph_x_BASE) /* 读取和设置寄存器（这里以置位举例） */ Periph_x-\u003eUCR1 |= (1 \u003c\u003c 2); 关于连接符 “#” 和 “##” 的使用说明，这两个都是预处理命令。 /* ## 左右语句原样连接符（concatenator） hello##world 就是 helloworld，直接原样拼接，这并不是字符串，而是预编译时候的字符的替换和拼接 */ /* 例1： */ #define A(x) T_##x int A(1) = 10; /* 等效于int T_1 = 10; */ /* # 转字符串符，字符串化操作（Stringfication） */ /* 例2： */ #define WARN_IF(EXP) \\ do{ \\ printf(\"Waring:\"#EXP\"\\n\"); \\ }while(0) WARN_IF(int devide = 0;); /* 会打印：Waring:int devide = 0; */ /* 例3： */ #define paster( n ) printf( \"token\" #n \" = %d\", token##n ) paster( 9 ) /* 即 printf( \"token\" \"9\" \" = %d\", token9 ); */ /* 字符串连接，多个双引号的字符串放在一块就是了 */ printf( \"token\" \"9\" \" = %d\", token9 ); fd = open( PATH \"/file\",flags ); 变长参数函数定义的使用说明。变长参数函数性能比较低而且难维护，非必要不建议使用。 /* 参考 https://blog.csdn.net/ericbar/article/details/79558827 */ #include \u003cstdarg.h\u003e /* 用于支持变长参数函数 */#include \u003cstdio.h\u003e /* 定义的函数必须至少有一个固定参数。这个函数包含了两个固定参数，和指示变长参数开始的省略号 */ void variable_argument(int fix_argument1, int fix_argument2, ...) { /* 先定义一个 va_list 类型的变量，比如 ptr，它指向参数列表的首地址； */ va_list va_ptr; /* 用 va_start() 宏初始化ptr，va_start()的第二个参数是variable_argument()的第一个可变参数的前一个参数，其实就是最后一个固定参数； */ va_start(va_ptr, fix_argument2); /* 用 va_arg() 依次地 返回可变的参数，它的第二个参数是指定要获取的变参类型； */ int first = va_arg(va_ptr, int); int second = va_arg(va_ptr, int); int third = va_arg(va_ptr, int); char* four = va_arg(va_ptr, char*); float five = va_arg(va_ptr, double); /* 对于浮点数类型这里必须是 double 类型，否则编译器警告 */ /* 最后用 va_end() 宏结束可变参数的获取，便可以在下面使用获取到的各个参数； */ va_end(va_ptr); printf(\"first is %d, second is %d, third is %d, four is %s, five is %f\\n\", first, second, third, four, five); return; } int main(int argc, char** argv[]) { variable_argument(1, 2, 5, 2, -5, \"Hello\", 3.14159); return 0; } /* 会打印：first is 5, second is 2, third is -5, four is Hello, five is 3.141590 */ /* C99 以及之后可以在宏定义中使用变长参数 */ #define debug(...) printf(__VA_ARGS__) #define debug(format, ...) fprintf(stdout, format, __VA_ARGS__) #define debug(format, args...) fprintf(stdout, format, args) 若要修改函数的形参的值那么请用一级指针，若要修改形参一级指针的值那么用二级指针，以此类推。 /* 引用自：https://blog.csdn.net/c243311364/article/details/109619361 */ /* 正确的 */ void GetMemery(int **p) { /*申请1024个int大小*/ *p = malloc(sizeof(int)*1024); if(NULL == *p) { printf(\"malloc failed\\n\"); *p = NULL; } } int main(void) { int *p = NULL; GetMemery(\u0026p); printf(\"address of p is %p\\n\",p); free(p); p = NULL; return 0; } /* 错误的 */ #define SIZE 10 void EncryptUpdata(int *ctx) { ctx = (int *)malloc(sizeof(int) * SIZE); return; } int main() { int *ctx = NULL; EncryptUpdata(ctx); UseCTX(ctx); return 0; } C 有一个鲜为人知的运算符叫 ”趋向于”（ “–\u003e” ）。 /* 引自 https://www.zhihu.com/question/27417946/answer/36591120 */ #include \u003cstdio.h\u003eint main(int argc, char** argv) { int x = 10; while (x --\u003e 0) { printf(\"%d \", x); } return 0; } /* 会打印出：9 8 7 6 5 4 3 2 1 0 */ /* while (x --\u003e 0) 可以理解为 while (x-- \u003e 0) */ /* 或者这样写更快速递减，两个自减符号 \"--\"，即每次减 2，下面语句会打印出：8 6 4 2 */ int x = 10; while( 0 \u003c---- x ) { printf(\"%d \", x); } /* stackoverflow 上面对这个操作符的讨论： https://stackoverflow.com/questions/1642028/what-is-the-operator-in-c-c/1642035#1642035 */ 快速范围判断：再来一种新写法 - 知乎 (zhihu.com)。 scanf 的正则表达式用法举例。 scanf(“%[^,]”, a); // This doesn’t scrap the ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:6","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"6 常用宏定义 p.s 以下有一些在 C 标准库里有实现，资源紧张可以用下面的宏定义，不紧张推荐全部使用标准库 /* 宏定义的形式规范 宏定义使用全大写（尽量），并遵循 \"属什么 _ 是什么 _ 做什么\" 的命名形式； 尽量把常数数字用宏定义代替； 对宏定义中的所有输入和输出（整个结果语句）用括号保护起来，长句用 do{ }while(0); */ /* 打印一个变量名及其值 */ #define PRINT_HEX_VAR(var) printf(\"%s: 0x%08X\\n\", #var, var); unsigned int program_flag = 0xAABBCCDD; PRINT_HEX_VAR(program_flag); /* 打印一个数组 */ #define ARR_SIZE(arr) (sizeof(arr)/sizeof(*arr)) // 返回数组元素的个数 #define PRINT_DIGIT_ARR(arr) do{\\ printf(\"%s: \", #arr); \\ for(int i=0; i \u003c ARR_SIZE(arr); i++) \\ printf(\"%d \", arr[i]);\\ printf(\"\\n\");\\ }while(0) int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; PRINT_DIGIT_ARR(arr); /* 定义变量。__typeof__(x) 用于获取变量 x 的类型 */ #define var(left, right) __typeof__(right) left = (right) var(s, 1LL); /* 用法举例，这里相当于 long long s = 1LL; */ /* 获取大于 a 的最近的 2^n 倍的且是 size 的整数倍的值，可计算申请内存时要对齐的某字节数 */ #define ROUNDUP(a, size) (((a) \u0026 ((size)-1)) ? (1+((a) | ((size)-1))) : (a)) /* 获取大于 size 的最近的且是 val_size 倍数的值，可用于 Flas h的 page 大小对齐的时候 */ #define VAL_ROUNDUP(size, val_size) (((size)+val_size-1)/val_size*val_size) /* 得到指定地址上的一个字节或字 */ #define MEM_B( x ) ( *( (unsigned char*) (x) ) ) #define MEM_W( x ) ( *( (unsigned short*) (x) ) ) /* 求最大值和最小值 */ #define MAX( x, y ) ( ((x) \u003e (y)) ? (x) : (y) ) #define MIN( x, y ) ( ((x) \u003c (y)) ? (x) : (y) ) /* 但是上句还是有可能报错，比如： double xx = 1.0; double yy = MIN(xx++, 1.5); printf(\"xx=%f, yy=%f\\n\",xx,yy); 以下放大招了，看看 GNU 的实现...用下面这句就不会出错，那当然了... #define MIN(A,B) ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a \u003c __b ? __a : __b; }) */ /* 得到一个field在结构体(struct)中的偏移量 */ #define FPOS( type, field ) ( (unsigned long) \u0026(( type *) 0)-\u003e field ) /* 得到一个结构体中field所占用的字节数 */ #define FSIZ( type, field ) sizeof( ((type *) 0)-\u003efield ) /* 按照LSB格式把两个字节转化为一个 unsigned short */ #define FLIPW( ray ) ( (((unsigned short) (ray)[0]) * 256) + (ray)[1] ) /* 按照LSB格式把一个 unsigned short 的 val 转化为两个字节 ray[0] 和 ray[1] */ #define FLOPW( ray, val ) \\ (ray)[0] = ((val) / 256); \\ (ray)[1] = ((val) \u0026 0xFF) /* 得到一个字的高位和低位字节 */ #define WORD_LO(xxx) ((unsigned char) ((unsigned short)(xxx) \u0026 255)) #define WORD_HI(xxx) ((unsigned char) ((unsigned short)(xxx) \u003e\u003e 8)) /* 返回一个比X大的最接近8的倍数的数 */ #define RND8( x ) ((((x) + 7) / 8 ) * 8 ) /* 将一个字母转换为大写 */ #define UPCASE( c ) ( ((c) \u003e= 'a' \u0026\u0026 (c) \u003c= 'z') ? ((c) - 0x20) : (c) ) /* 判断一个字符是不是10进制的数字 */ #define DECCHK( c ) ((c) \u003e= '0' \u0026\u0026 (c) \u003c= '9') /* 判断一个字符是不是16进制的数字 */ #define HEXCHK( c ) ( ((c) \u003e= '0' \u0026\u0026 (c) \u003c= '9') ||\\ ((c) \u003e= 'A' \u0026\u0026 (c) \u003c= 'F') ||\\ ((c) \u003e= 'a' \u0026\u0026 (c) \u003c= 'f') ) /* 带防止溢出数据类型最大值的自加一 */ #define INC_SAT( val ) (val = ((val)+1 \u003e (val)) ? (val)+1 : (val)) /* 圆周率 */ #define M_PI 3.14159265358979323846f /* 在编译时就能够进行条件检查的断言，而不是在运行时进行。下面是个Linux Kernel的例子 */ #define BUILD_BUG_ON_ZERO(e) (sizeof(struct{int : -!!(e);})) #define BUILD_BUG_ON_NULL(e) ((void*)sizeof(struct{int : -!!(e);})) /* Force a compilation error if condition is true */ #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2 * !!(condition)])) /* 检测a和b是不是同一类型，不是同一类型编译不过 */ (void) (\u0026a == \u0026b) /*Author: MaxwellXyao*/ #define BIT(n) (1 \u003c\u003c (n)) //位mask #define bit_SetTrue(x,mask) ((x) |= (mask)) //该位设置为真 #define bit_SetFalse(x,mask) ((x) \u0026= ~(mask)) //该位设置为假 #define bit_Toggle(x,mask) ((x) ^= (mask)) //位切换 #define bit_IsTrue(x,mask) (((x) \u0026 (mask)) != 0) //该位是否真 #define bit_IsFalse(x,mask) (((x) \u0026 (mask)) == 0) //该位是否假 /* 编译时一些信息的字符串，用内建宏调试 __FILE__ 表示当前所在文件名的字符串 __LINE__ 表示当前所在行的整形数字 __FUNCTION__ 表当前所在函数的函数名字字符串 __DATE__ 表示编译时的 月/日/年 字符串信息 __TIME__ 表示编译时的 时:分:秒 字符串信息 __STDC__ 如果实现是标准的，则是十进制常量1，否则为其他 如下面，Debug 时输出文件名、行号、函数名等 */ #define DEBUG_INFO() fprintf(stderr,\"[DEBUG]%s:%d %s\\n\", __FILE__, __LINE__, __FUNCTION__) /* 参考 https://blog.csdn.net/cleverhorse/article/details/84655543 将编译时间转换为int类型作为时间戳 __DATE__ __TIME__ 转INT类型 */ #define YEAR ((((__DATE__[7]-'0')*10+(__DATE__[8]-'0'))*10+ \\ (__DATE__[9]-'0'))*10+(__DATE__[10]-'0')) #define MONTH (__DATE__[2]=='n'?1 \\ :__DATE__[2]=='b'?2 \\ :__DATE__[2]=='r'?(__DATE__[0]=='M'?3:4) \\ :__DATE__[2]=='y'?5 \\ :__DATE__[2]=='n'?6 \\ :__DATE__[2]=='l'?7 \\ :__DATE__[2]=='g'?8 \\ :__DATE__","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:8:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"7 C 标准库的使用 p.s 资源不紧张推荐全部使用标准库（除了 malloc 和 free） 最常用的： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cctype.h\u003e #include \u003cstring.h\u003e #include \u003cmath.h\u003e 参考这几个地方齐活了： C标准库函数新编手册: C语言标准库函数API使用手册中文版 (gitee.com)。 上面的 gitee 仓库很优秀，已经离线到了本地./额外文档/zhaixuebuluo-glibc_man_cn-master.zip中。 C语言常用标准库解读_张巧龙的博客-CSDN博客。 C 标准库 – 参考手册 | 菜鸟教程 (runoob.com)。 可能会用到的： #include \u003ctime.h\u003e // 提供储存时间的结构体和计算时间差等函数；\r#include \u003climits.h\u003e // 这两个库包含了各种变量类型的最大、最小值等信息；\r#include \u003cfloat.h\u003e 不常用的： #include \u003cstdarg.h\u003e // 用于函数定义变长形参； #include \u003cassert.h\u003e // 提供了一个名为 assert 的宏，仅在 debug 模式有效，判断一个表达式是否为 FALSE(即 0)，如果是则报告错误并终止程序； #include \u003cerrno.h\u003e // 被其他库文件调用，提供一些返回值定义； #include \u003clocale.h\u003e // 定义了特定地域的设置，比如日期格式和货币符号； #include \u003csetjmp.h\u003e #include \u003csignal.h\u003e #include \u003cstddef.h\u003e ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"8 ST HAL 的编写形式 相关文章： STM32 注释风格参考：STM32注释风格参考_wanshiyingg的专栏-CSDN博客。 ST HAL 的各个文件编写风格非常一致，下面以 F4 SPI 为例： .h文件： ——————————————————————————开头—————————————————————————— /** ****************************************************************************** * @file stm32f4xx_hal_spi.h * @author MCD Application Team * @brief Header file of SPI HAL module. ****************************************************************************** * @attention ...一大段版权说明和开源协议说明 * ****************************************************************************** */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef STM32F4xx_HAL_SPI_H #define STM32F4xx_HAL_SPI_H #ifdef __cplusplus extern \"C\" { #endif ——————————————————————————中间部分，挑重点—————————————————————————— /* Includes ------------------------------------------------------------------*/ #include \"stm32f4xx_hal_def.h\"这添加各种 Includes 这里所有 @addtogroup 的部分省略，这是添加分组，为了 Doxygen 组织文档层级结构 其格式： /** @addtogroup STM32F2xx_StdPeriph_Driver * @{ */ ... /** * @} */ /* Exported types ------------------------------------------------------------*/ 这定义各种结构体、枚举和数据类型定义，都符合 Doxygen 形式，定义开头注释，每一个成员注释 /* Exported constants --------------------------------------------------------*/ 这添加各种常量，宏定义 #define 以上结构体应填入的选项名 /* Exported macros -----------------------------------------------------------*/ 这添加个各种宏定义，控制模块和各个子模块启停、 得到标志置位和清除标志位等等的宏定义等等，启动和停止成对出现 /* Exported variables --------------------------------------------------------*/ 共有变量 /* Exported functions --------------------------------------------------------*/ 这添加给其他文件和用户调用的API声明 /* Private types -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ /* Private constants ---------------------------------------------------------*/ /* Private macros ------------------------------------------------------------*/ 这添加.c文件的API内部使用的私有宏定义，其他文件和用户不得调用 /* Private functions ---------------------------------------------------------*/ ——————————————————————————结尾—————————————————————————— #ifdef __cplusplus } #endif #endif /* STM32F4xx_HAL_SPI_H *//************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 最后加一个 COPYRIGHT .c文件： ——————————————————————————开头—————————————————————————— /** ****************************************************************************** * @file stm32f4xx_hal_spi.c * @author MCD Application Team * @brief SPI HAL module driver. ...一大段本文件简述 * @verbatim ============================================================================== ##### How to use this driver ##### ============================================================================== ...很长的一段使用说明 @endverbatim ...很长的一段附录表格和几个@note ****************************************************************************** * @attention ...一大段版权说明和开源协议说明 * ****************************************************************************** */ ——————————————————————————中间部分，挑重点—————————————————————————— /* Includes ------------------------------------------------------------------*/ 这里所有 @addtogroup 的部分省略，这是添加分组，为了 Doxygen 组织文档层级结构 #ifdef HAL_SPI_MODULE_ENABLED 模块预编译控制，方便工程剪裁 /* Private typedef -----------------------------------------------------------*/ 私有类型定义 /* Private defines -----------------------------------------------------------*/ 私有常数宏定义 /* Private macros ------------------------------------------------------------*/ 私有宏定义 /* Private variables ---------------------------------------------------------*/ 私有变量 /* Private function prototypes -----------------------------------------------*/ /* Private functions ---------------------------------------------------------*/ 私有API，仅本文件内部调用，外部文件和用户不可调用 /* Exported functions --------------------------------------------------------*/ 共有API，供外部文件和用户调用 #endif /* HAL_SPI_MODULE_ENABLED */ ——————————————————————————结尾—————————————————————————— /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 最后加一个 COPYRIGHT ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:10:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"9 本文参考源 c-code-style； 20个成熟软件中常用的宏定义； ST HAL； 知乎问题页：程序员们有什么好的编程习惯？； 【正点原子】嵌入式Linux C代码规范化V1.0； 本人长时摸索的经验。 其他。 p.s 本 C 规范系广泛约取而成，参考并非照搬。 p.s 此文件系业余整理而成，远不及\"Google C/C++编程规范”、“华为编程规范\"等文件的专业程度。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:11:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"10 大厂规范和名设计模式 以下强烈建议空闲时认真学一学。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"大厂规范 Google C++风格指南； 华为 C语言编程规范 华为C语言编程规范（精华总结）； C语言编程规范（一）（华为标准要求）； C语言编程规范（二）（华为标准要求）； MISRA C Coding Standard； [CodingStyle] Linux 内核源代码目录下的 Documentation/CodingStyle 文件。中文：Linux 内核代码风格 — The Linux Kernel documentation。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"设计定律、原则和模式 比较优雅地编码（良好的命名，清晰的结构和不差的算法）； nusr/hacker-laws-zh 对开发人员有用的定律、理论、原则和模式； 如何正确地使用设计模式？ - 知乎 (zhihu.com)； C语言和设计模式（总结篇）_平凡的程序员-CSDN博客_c设计模式； 23种设计模式全解析_CodeAllen的博客-CSDN博客； 架构与设计 之一 C 嵌入式设计模式（Design Patterns for Embedded Systems in C）的学习记录_itexp-CSDN博客； 书籍推荐《调试九法-软硬件错误的排查之道》 - lumang - 博客园 (cnblogs.com)； etc。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"提高代码运行效率 提高代码运行效率； etc。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:3","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"11 尾记 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:13:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"开光保护 佛祖保佑永无BUG 神兽护体 代码注释(各种版本) 厉害了word程序猿，进寺庙给服务器开光保永不宕机 以下是效果图。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:13:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"署名 编辑整理：Github 页，知乎页 发表时间：始于 2021.2 且无终稿 首发平台：https://zhuanlan.zhihu.com/p/350839857 and https://github.com/Qitas/coding-style-and-more 遵循协议：CC-BY-NC-SA 4.0 其他说明： 本文件是“折耳根”计划的一部分，尽量遵循 “二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明（这中二魂…）！ 本文系广泛撷取、借鉴和整理，侵删。本文适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！ 转载请注明作者及出处。整理不易，请多支持。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:14:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和其他","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["其它"],"content":"科幻小说《请留在未来》的注解篇","date":"2020-06-17","objectID":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/","tags":["科幻小说"],"title":"科幻小说《请留在未来》注解篇","uri":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/"},{"categories":["其它"],"content":"1、 冰冻三尺，非一蹴而就。既然要写，就写好，计划中，首先设计世界观和大背景，围绕我要表达的思想构思故事内核和主线，再填充对话和动作，最后在写的时候，站在第三视角叙事，站在第二视角交互，站在第一视角思考。 2、 关于文章的标题，在成文期间左右不能确定，可选择的有《未来往事》、《对话》、《灿烂的曙光》、《我和黄昏喝醉之前的故事》和最后想的《请留在未来（中标）》，每一个都有自己的视角和立意，经历这次，深知一千个读者有一千个读法。第一个标题让文章偏向科幻，发生在未来的往事？有点意思，另外也是在致敬《回到未来》；第二个标题重点表明此文包含大量对话，情节都在对话中展开；第三个标题表达一种期许，未来不一定都是灾难与不安，它也很可能是“灿烂的曙光”，文章写的也正是如此；第四个标题偏向两个人的感情，夏叶走之后，大潭看着金色的黄昏发呆，喝醉后打开记录仪开始记录这个黄昏之前所发生的种种事情，让这篇洒洒两万字的文章最后就变成一狗粮？第五个标题最后想出，也是中标的，也是很想表达的一种“正道的光”，就是心要有远景，年轻人，要看得长远，要留在未来！ 3、 我的创新观。很多人都说过到底何为创新，怎么做就算创新了，我就说点不一样的，具体的，可操作的，个人愚见。那就是贯穿全文的“二项玻”定则，你可以按照这个定则来想新的事物，比“TRIZ理论”简明，即“组合有意义的组合”和“简化能够之简化”。 4、 “一天晚上，夏叶吃过晚饭，戴上耳机听几首歌，一首流行英文乐，一首中文情歌，再出去压马路转一转，到公园稍微活动一下，同时还听着一首摇滚，一首民谣，一首说唱，一首future bass风格的电音，一首Vocaloid，一首日系轻音乐和一首交响乐，回到家，刷了几下朋友圈，聊一聊，对明天的日程做一个规划，查一下长期任务的完成情况，再洗漱完毕，便关灯睡去”，这一段明显罗列了好多种音乐，暗示之后出现的大潭的好友华和洁的多元身份“搞科研和私家侦探”，以及玻柏的“认知学家、计算机学者和DJ”，即有更多的“斜杠青年”，文中也有对这一现象的描述“现在又好像一千年前达芬奇时代那样，一些人掌握学科的门类相当广泛”，这也是因为文章的大背景，AI辅助学习和认知，几乎绝大部分知识的学习没有了壁垒，教育不均甚至学校教育都将消失，知识能力不再是造成人之间鸿沟的主要原因，在这种状况下自然推演，科研变成了文中所描述的“才艺”，一人能够感兴趣和深耕的领域变得多元。 5、 文中开头夏叶读的书，关于“圆周率包含了所有可能的数字排列”这一论点是本科幻小说的假设，因为目前尚未证明。 6、 文中的“精句”，已作标出。 7、 文中的注释符号如“①”等，均出自一本叫《平行地球漫游指南》的书，它描述了关于在平行地球漫游你想知道的一切，你买不到因为这本书只在平行地球发售。这个设置是致敬《银河系漫游指南》中的《指南》，其背后因写着大大的“Don’t panic！”而非常畅销，本文多处出现的“42”也在致敬于此。 8、 对于大潭弄来42克钯元素过程的详细描述，在真实世界也可能发生。 9、 “电脑AI温馨的提醒着“一会要有光，小心眩光”，在机器的容器内渐渐有了光”，这里是在模仿“上帝说，要有光，于是，就有了光”，有从无到有的意味，但是万物的原理还是要相信科学，一个高科技的高阶AI智慧说出这种话，也在反讽过度解读圣经的愚昧吧。 10、 “天呐，我是在科幻小说里吗？”夏叶惊呼。“不，因为这里没有宇宙飞船、全息投影和机器人！呃…科幻作品里面不都得有宇宙飞船、全息投影和机器人这‘老三样’吗”，这一段啊，这一段是在一个科幻作品里把其他科幻作品的套路揭底，本文虽然描述未来世界，但确实没有出现这三样。还有后面的大潭对夏叶解构科幻作品，同理。 11、 文中仿写了一段SCP故事，是一个永远也不会让人通过的面试官。这篇文章中某些内容写的很早，SCP这一段就是2019年面试被拒后写的，在这之前所有人都说我的能力足够通过那个面试，当时真的真的很难。 12、 文中“施教授与一位国外科学家聊天”这一片段的前两段出自施一公演讲，第三段为本文增加的后续对话。 13、 “国外的杂志《竹叶刀》”，对标真实世界的《柳叶刀》。 14、 “有的人讲人机共处的社会没有民主和自由”，“研发出了一种化学试剂，当作疫苗一样注射，可以消除人们的种族主义心理”，“他们强烈反对与AI人共同生活的人机共处，却用着AI发明的科技悠哉生活”，结合魔幻现实，你细品。 15、 文章最后以AI为主要视角续想第四次工业革命之后的两次科技革命的形态，一般来说，第四次工业革命的突破口在哪里，是什么形态都很难想象，更不要说其后的两次科技革命是什么样子，但想象嘛，可以讲出来。内容不一定准确，但提出一个观点，不论科技再怎么先进，人认知的方式和深度决定着发展的上限，如果这个上限突破了，科技发展等就像文中描述的一样潜力无穷了。就控制科学的角度说，控制算法再先进也是无限逼近被控对象的能力上限，想办法改进被控对象自身才会提升这个上限。 16、 文章故事发生在第六次科技革命伊始，夏叶走后，大潭进入休眠等待夏叶回来。但是（转折），文章注释⑧中说，由于那时的科技进步飞快，就是上面所说的“上限”被突破，使得历史进程急速加快，平行地球随即进入隐匿状态，外人无法观测、无法理解和无法叙述，也即是说，大潭和他所在的平行地球“消失”了，夏叶应该永远回不来了，对于他们二人，这真是个悲伤的故事。 2021.1更新 17、 我后来注意到，关于核聚变实现后现实世界的改变的一些想象在《三体2》中有竟大部分雷同，以及x米公司实现了与大刘描述的很像的初步的“隔空充电”；我得在这澄清一下，在行文期间我还没读到《三体2》；我一贯主张行走在想新的事物这条路上，平时连重复的“梗”都很少玩（但是一玩大家就欢快起来，就像触发器一样）；与大刘在“核聚变实现后的世界”这方面的想象有所重合我又惊又喜。 “别担心，我们地球的光会到达遥远的星系，在每个太阳系中，我们都重生，所以我们会永远在一起。”————格卢什科夫 ","date":"2020-06-17","objectID":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/:0:0","tags":["科幻小说"],"title":"科幻小说《请留在未来》注解篇","uri":"/%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/"},{"categories":["主线剧情"],"content":"介绍 ARM 内核的主要芯片大厂的各个 SoC 系列","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["主线剧情"],"content":"ARM \u0026 SOC 系列快速鸟瞰 编辑整理 By Qitas，如有错误恭谢指出，侵删。CC-BY-NC-SA 4.0。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:0:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["主线剧情"],"content":"零 鸟瞰 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:1:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["主线剧情"],"content":"ARM Cortex 系列框图 图中包含现今主流处理器架构和内核层，ARM架构处理器的架构层、内核层和具体芯片（举例）三个维度的进化/迭代示意。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:1:1","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["主线剧情"],"content":"ARM 体系结构的几大分类 ARM7 处理器； ARM9、ARM9E 处理器； ARM10E 处理器； SecurCore 处理器； StrongARM 处理器； ARM11 处理器； Cortex 系列处理器。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:1:2","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["主线剧情"],"content":"一 定位 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:2:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["主线剧情"],"content":"ARM Cortex-A 系列对比 更详细的介绍参看： ARM Cortex-A系列处理器性能分类比较ARM处理器排名_ZNDS资讯 ARM版本系列及家族成员梳理_ 韦东山嵌入式专栏-CSDN博客 _arm系列 哪种ARM Cortex内核更适合我的应用：A系列、R系列、还是M系列？_water1730的博客-CSDN博客 ARMCortex各系列处理器分类比较 - 百度文库 (baidu.com) 引用： 如图所示，绿色的部分都是v7-A的架构，蓝色的是v8-A架构，基本上绿色都是可以支持到32和64位的，除了A32，只支持到32位。在右边的每个部分，比如说需要高效能的最上面的A15-A73这个部分是最高效的，接下来就是比较注重整个效率的部分了，中间那个部分是比较高效率的，最下面那栏的是效率最好的，在电池的效能方面达到了最好的标准。 如果非要给他们一个排序的话，从高到低大体上可排序为：Cortex-A73处理器、Cortex-A72处理器、Cortex-A57处理器、Cortex-A53处理器、Cortex-A35处理器、Cortex-A32处理器、Cortex-A17处理器、Cortex-A15处理器、Cortex-A7处理器、Cortex-A9处理器、Cortex-A8处理器、Cortex-A5处理器。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:2:1","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["主线剧情"],"content":"二 展望 基于 Linux 系统方案的优势： 更高性能，可以运行复杂的算法； 高效开发，专注于梳理任务，应用以 APP 形式编写和更新； 智能终端，可以外接触摸屏，运行 Qt 上位机做人机界面； 协议丰富，使高级接口如网络、USB 等更易于开发； 平台通用，开发形式更加固定。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:3:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["规范"],"content":"比较详细的介绍了 HDL \u0026 FPGA 学习和规范","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":" 本文源文在Qitas/HDL-FPGA-study-and-norms: HDL \u0026 FPGA 学习和规范。CC-BY-NC-SA 4.0。 (github.com)。今后只在上面的链接里，这里不会跟进。 编辑整理 by Qitas，始于 2021.2 且无终稿。转载请注明作者及出处。 本文件是“折耳根”计划的一部分，尽量遵循“二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明！ 本文系广泛撷取、借鉴和整理，适合刚入门的人阅读和遵守，已经有较多经验的人看一看图个乐，如有错误恭谢指出！ ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:0:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"O 目录 [TOC] ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:1:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"1 HDL \u0026 FPGA 值得注意的 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:2:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"FPGA基本概念 p.s 过于基础的概念不提，这不是入门帖。入门可以跳到 “4 值得跟着的学习网站” 章节进行摄入。 FPGA固有灵活性和并行性。FPGA应用领域列举：逻辑粘合，实时控制，高速信号采集和处理，协议实现，仿真验证系统，片上系统SoC。 FPGA基础资源选择：逻辑单元（LE）数量，内嵌存储器（M9K）数量（总RAM Bits数），乘法器数量，PLL数量，I/O数量，全局时钟网络数量等。 板级电路组成：电源，时钟，复位，JTAG，固化配置信息FLASH，外设。具体连接形式参考一些开发板和开源板子的原理图和PCB。 电源：核心电源（标识 VCCINT，低压版本 1.0V，非低压 1.2V），IO BANK（标识 VCCIOx（x = 1到8），电压 1.2V到3.3V），PLL（模拟PLL标识 VCCAx（x = 1、2或4），其地标识 GNDAx（x同前），电压 2.5V；数字PLL标识 VCCD_PLLx（x = 1、2或4），电压1.2V），外设供电。 全局时钟网络：专用时钟网络走线，同一时钟到达不同寄存器的时间差可以被控制到很小的范围内。外部输入时钟信号要连接到“全局时钟专用引脚”上。FPGA的综合工具会自动识别和分配。 复位：上电后，FPGA器件开始加载外部FLASH芯片的固化信息，加载完毕之后（最多0.3s）再进行复位（低电平有效），阻容RC复位电路可选：R=47kΩ，C=10uF，3.3V的IO标准下，充电到1.7V时间为340ms。 I/O：输入和输出时钟信号尽量分配到专用引脚上。差分信号对儿必须分配到支持差分的专用引脚上。高速信号分配到支持高速传输的专用引脚上（如DDR的专用IO接口）。一些硬核使用的引脚可能是固定的要注意。总线信号尽量分配到同一个BANK。一些产生噪声干扰的信号（如时钟信号）尽量远离器件的配置喜欢和其它敏感的信号。 调试和固化： 更多详细参考： FPGA配置方式 FPGA的各种功能管脚 Altera特殊管脚的使用 具体看官网手册“Cyclone IV Device Handbook Volume 1”的“Configuration Process”章节和“Configuring Altera FPGAs.pdf”手册。 调试为通过 JTAG 接口用 Blaster 下载器把编译生成的.sof文件下载到FPGA内掉电易失的SRAM中。 固化是通过 JTAG 接口用 Blaster 下载器把编译并转化生成的.jic文件下载到FPGA对于的外部FLASH器件中。FPGA上电从FLASH中获取配置信息，分为几种不同的配置模式，根据 [3:0]MSEL 四个引脚上电时的电平状态确定，而具体的 [3:0]MSEL 与 启动方式的关系 看对应FPGA芯片系列型号的手册。配置模式分为以下几种： AS（主动串行），适用于小容量。由FPGA器件引导配置过程，EPCS系列FLASH专供AS模式。一般用此模式。 AP（主动并行），速度快，占I/O更多，适用于大容量FPGA器件。EPC系列FLASH用于此。 PS（被动串行），需要外部MCU或CPLD（如MAX II系列）控制FLASH的数据打入FPGA，此方式最灵活，对于多个FPGA或者要自动更换固件用此模式。 等其他。 板级PCB走线遵循“PCB走线规范”。 开发流程： 推荐多去读读FPGA原厂（Altera 或 Xilinx）的官方文档，在它们的一些文档手册中有各种常见的电路的参考实现实例和代码风格。 三种优化模式（IDE 软件里可选）：针对速度的优化；针对面积的优化；针对功耗的优化。 处理器和FPGA分工：MCU、MPU适合做管理、协调，FPGA的数字逻辑适合做专用的、复杂的、结构和功能固定下来的算法实现。 … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:2:1","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"操作和编写规范 这里的规范仅为初级，另有“HuaWei Verilog 规范”等规范可供参考。 Verilog HDL No.1，层次化设计，IP化设计。自写小IP尽量参数化、可重用，方便日后搭建数字积木。 顶层文件名与顶层模块名一致。 模块的定义名加尾缀\"_ module\"，输入输出的信号名各加后缀\"_ in\"和\"_ out\"，低电平有效的信号加尾缀\"_ n\"。 定义模块的时候，定义输入输出信号时就带好\"input\" 、 “output” 和 “reg\"的类型修饰。 一个 tab 四个空格。 用 tab 划分清晰的语句层次，用 tab 对齐多排赋值操作等。 begin 和 end 语句块修饰词在竖方向对齐。 操作符等前后用一个空格做间隔。 注释齐全，对别人负责。 以时钟信号同步的时序逻辑编写时尽量只用非阻塞赋值”\u003c=\"，用阻塞赋值\"=“可能会产生bug，后者一般用于组合逻辑设计。尽量避免使用异步信号（比如异步复位等），即慎用或少用 assign 语句连接逻辑，而尽量把所有逻辑在 always @(*) begin … end 中实现；如果传入一个异步信号，尽量加寄存器（D触发器）用时钟进行锁存。 逻辑表达式不要写的太长，可以简化逻辑（卡诺图法或者公式法，或者 multisim 里面的逻辑分析仪简化逻辑表达式）或者分多行去写，即不要让RTL图中某一段逻辑链过于长；长逻辑表达式用括号划分清关系减少歧义。 为避免组合逻辑的输出出现“毛刺”，即冒险或竞争的发生，可以在输出加一个寄存器（D触发器），即让输出与时钟同步，当所有信号都到达寄存器（D触发器）的输入后，时钟再“打一拍”才能输出，这样避免最后的输出有“毛刺”；避免锁存器，使用触发器。 case 语句必须带 default 分支，照顾到 case 的所有情况。 移位操作直接用位拼接。 同一个信号在很多地方使用，比如参数和时钟等等，应该在每一个用到的地方加一个寄存器（D触发器）用于中继缓冲，避免一个信号扇出信号数量过多。 对于有选择和加法、比较等逻辑块，编写时应让信号先经过选择器，再送入乘法器、加法器或比较器等，即“先选后比，先选后加，先选后乘”。面积：乘法器 \u003e 加法器 \u003e 比较器 \u003e 选择器。 尽量不要用减法和除法（一个考虑多，一个面积大）；乘以常数直接用“*”，编译器会优化；两变量乘法用硬件乘法器IP。 使用 function 函数语句对复杂运算打包，由 task 或其他语句调用；使用 task 函数语句写可重用的、固定下来的组合逻辑（不能有时序逻辑 always，这就是和 module 的区别，并且 task 只能在语句块中被调用）。 /*____________________________________________ * 模块简述：... ____________________________________________*/ module example_module ( /*输入信号*/ input clk_in, /*时钟输入*/ input rst_n_in, /*复位（低有效）信号输入*/ /*输出信号*/ output reg [7:0]q_out, /*q 左移位输出*/ output reg [7:0]p_out /*p 右移位输出*/ ); /*对 q 左移位输出*/ always @(posedge clk_in or negedge rst_n_in) begin if(!rst_n_in) begin q_out \u003c= 8`b0000_0001; end else begin q_out \u003c= { q_out[6:0] , q_out[7] }; end end /*对 p 右移位输出*/ always @(posedge clk_in or negedge rst_n_in) begin if(!rst_n_in) begin p_out \u003c= 8`b1000_0000; end else begin p_out \u003c= { p_out[0] , p_out[7:1] }; end end endmodule 工程搭建与仿真 工程路径不能包含中文和空格！ 自动补全代码的功能 ，在[Tools] -\u003e [Options] -\u003e [Text Editor] -\u003e Autocomplete Text 里面选择启用。 工程文件夹划分规范：prj 为工程文件存放目录； rtl 为 verilog 可综合代码存放目录； testbench 为测试文件存放目录； img 为设计相关图片存放目录； doc 为设计相关文档存放目录； prj 文件夹下还建立了子文件夹 ip，用于存放 Quartus Prime 中生成的 IP 核文件。 仿真文件 testbench 均由IDE软件产生（当引脚很多时节省手写时间）。先做一次全编译，然后 Quartus II 软件里面 Processing-\u003eStart-\u003eStart Test Bench Template Writer，生成 .vt 格式的 testbench 文件后，修改这个文件名与里面顶层模块名一致。 仿真文件常用语句： 产生时钟： `define clock_period 20 //周期20ns，50Mhz always #(`clock_period/2) CLK_in = ~CLK_in; //周期20ns，50Mhz 暂停仿真，在需要仿真结束的地方加：$stop;。 打印调试信息： $display(\"%d\",value); //与 printf 类似，但这个会自动换行 $wirte(\"%d\\r\\n\",value); //与 printf 一样 // %od,%oh ：以最少位输出，自适应 // $time 为执行到当前位置的以 `timescale 为单位的时间计数整数； // $realtime 为以小数显示的执行到当前位置的以 timescale 为单位的时间。 注意：设计仿真文件 testbench 的激励源的时候，对于边沿触发的信号其激励源要设计带有沿变化，否则不会生效。 设计逻辑尽量避免不定态 x 或者高阻态 z 进入参与关键逻辑区域，仿真时就注意。 在“Device and Pin Options”里面“Dual-Purpose Pins”里面把所有复用功能的引脚都设置为“Use as regular I/O”，即在复位并配置完之后作为程序用引脚。 对于 Pin Planner，引脚的某一个属性可以复制，然后多选其他 I/O 对应属性的位置，再粘贴实现批量配置。 可以用 generate for 写 同结构不同参数 的 always@(*) 等代码，用 generate if/case 写一些随着需求可变的代码或 IP 核。 generate 语句属于预编译语句。 关于时序约束，必须要做，最基本要做的是使用 “TimeQuest timing Analyzer” 把设计内的所有时钟信号（包括晶振输入的时钟和PLL时钟）都约束一下。关于其他输入输出引脚的约束以及外接器件的 Timing 约束非常深，有待看小梅哥关于时序约束章节的视频学习。 在 quartus 工程中添加自己生成的sdc文件：点击 Assignments \\ Settings\\TimeQuest Timing Analyzer，在这个对话框中，将生成的 .sdc 文件添加到自己的工程里。 针对硬件引脚固定的项目，先在 Pin Planner 写好所有引脚定义，然后导出，在 Pin Planner 界面里面点 左上角的 File 然后 Export即可。以后在相同硬件平台创建新工程时可以直接导入这个引脚配置，在 Assignments 里面的 Import Assignments… 导入即可 。 Nios II 相关 关于 SOPC，Nios II Eclipse 里面的 BSP 包里的 drives 文件夹里面的 _reg 后缀 的 .h 文件里面为自加的 Nios II 外设的可调用的 API。 Nios II 默认禁止中断嵌套。 关于 Nios II software build tool for eclipse 这个 IDE 的设置 和 程序固化： file-\u003enew-\u003eNios II …Template 从 .sopcinfo 文件获取信息新建 hello world 模板项目，工程名暂定为 Temp。 把 需要 include 放入编译路径的其他程序文件分好文件夹，都放入 工程文件夹 Temp 里面，并把含有主函数 main() 的 .c 文件替换默认生成的 Hello World.c 文件。 在 IDE 中，右击工程名 Temp，Nios II-\u003eBSP Editor，选择里面 enable_reduced… 和 enable_small_c 这两个选项，再点右下角的 Generate，并关闭。 在 IDE 中，右击工程名 Temp，选 Properties，在 Nios II App.. Path 里面的 App include directories 里面添加需要 include 的其他程序文件夹。 在 IDE 中，右击工程名 Temp，选 New-\u003eSource Folder，把同上一步的文件夹添加进来；然后右击工程名 Temp，选 Refresh。 开始编译，在 IDE 中，右击工程名 Temp，选 Build Project，成功后再 Make Targets-\u003eBuild，里面选 mem_init_generate ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:2:2","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"其他小技巧 关于Quartus II工程综合时间过长问题的解决 四步搞定NiosII工程路径改变 PIO时序混乱问题解决（遇到再看） NIOS知识 和 各种错误解决 你问我FIFO有多深？ 结论：在SDRAM的应用中，我们通常使用的读写FIFO是突发长度的2倍，比如突发长度为256，那FIFO的深度设置为512，使得FIFO始终保持半满的状态。可以保证数据的传输。 【小梅哥FPGA进阶教程】MC8051软核在FPGA上的使用 （教程基于小梅哥）FPGA配置MC8051IP软核 … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:2:3","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"1.1 Avlon 总线 Intel FPGA Avalon 总线，其灵活特点有： 时钟同步的；分主、从信号线和时序，主外设能发起传输；多主多从； 主、从时钟频率可不同，位宽可不同； 专用的地址总线、数据总线和控制总线，支持高达 1024 位的数据宽度、不是 2 的偶数幂的数据宽度； 高性能，易实现，占用资源少，开放使用。 多种模式，时延和时序可调整，定制外设 IP 核超级灵活。 若只使用 Quartus II 的 Qsys 自带的定制的 Avalon 总线外设构建SOPC系统，不需了解 Avalon 总线，因为这些自带外设的接口都已经写好了 Avalon 总线，在图形化连接总线时，就是在把各个外设的从 Avalon 接口挂载到 Nios II 的主 Avalon 总线上；若采用用户定制外设构建SOPC系统，所开发外设必须符合 Avalon总线规范，需要熟悉 Avalon 总线。下图为典型 Avalon 架构。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:3:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"定制 外设 IP 核的框架 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:3:1","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"从端口信号类型 *p.s 其中前九个最常用；不带 “_ n” 后缀的都是高电平有效；还有流水线信号、突发信号、三态信号和流控信号等，没有列出。* p.s 不带任何读写的最基本信号：clk、reset、chipselect、address 四个。 p.s address 地址的信号宽度最好都设置为 32 位宽，地址对齐的时候一一对应，最简便。 信号类型 信号宽度 方向 功能和使用描述 clk 1 IN Avalon从端口的同步时钟，所有信号必须与clk同步，异步外设可以忽略clk信号。 reset_n 1 IN 从外设复位信号。该信号有效时，从外设进入确定的复位状态。 chipselect 1 IN Avalon从端口的片选信号。 address 1~32 IN Avalon从端口的地址线，指定了从外设地址空间的字的地址偏移,要访问外设寄存器的地址，从0x00开始。 read 1 IN 读从端口的请求信号。若使用了该信号，则必须使用readdata或data信号。 readdata 1~1024 OUT 读传输时，输出到Avalon总线的数据线。若使用了该信号，则data信号不能使用。 write 1 IN 写从端口的请求信号。若使用了该信号，必须使用writedata或data信号，writebyteenable信号不能使用。 writedata 1~1024 IN 写传输时，来自Avalon总线的数据线。若使用了该信号，data信号不能使用。 waitrequest 1 OUT 若从端口不能立即响应Avalon总线，用该信号来暂停Avalon总线。用于可变等待周期模式。 irq_n 1 OUT 中断请求信号。从外设的中断请求信号。 byteenable 2, 4, 6, 8,16,32,64,128 IN 按字节寻址访问使能信号。在对宽度大于8位的存储器进行写传输时，该信号用于选择特定的字节段。若使用了该信号，writedata信号必须使用，writebyteenable信号不能使用。 writebyteenable 2, 4, 6, 8,16,32,64,128 IN 相当于byteenable信号和write信号的逻辑与操作。write和byteenable信号不能使用。 32位从端口的 byteenable 信号功能定义表如下。 byteenable[3..0] 写操作 1111 全 32 位写操作 0011 2 个低字节的写操作 1100 2 个高字节的写操作 0001 字节 0 的写操作 0010 字节 1 的写操作 0100 字节 2 的写操作 1000 字节 3 的写操作 主端口信号类型表略。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:3:2","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"从端口传输 基本单周期读写时序传输； 流水线时序传输； 固定等待周期的读写传输； 可变等待周期的读写传输；（个人推荐常用） 具有建立时间和保持时间的固定等待周期的读写传输。（用于异步外设，了解） 流控制时序传输； 三态时序传输； 突发时序传输。 基本单周期读写传输 读时序： A 沿为主端口发起 读传输，E 沿 为主端口取走要读的数据；在 E 沿之前从端口的外设必须提前在 readdata 数据线上准备好数据。 基本读传输适用于异步从外设，只要外设被选中或地址发生变化，外设就立刻返回数据。readdata须在下一个时钟上升沿之前保持稳定。 从端口通常在 检测到 clk 上升沿后，再检测 chipselect 和 read 两个信号同时为高时，就认为一次读传输。 写时序： A 沿为主端口发起 写传输，E 沿为主端口准备好要写的数据，在此沿从端口外设要取走数据。基本写传输适用于片内同步外设。 从端口通常在 检测到 clk 上升沿后，再检测 chipselect 和 write 两个信号同时为高时，就认为一次读传输。 固定等待周期的读写传输 读传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和/或返回有效readdata，等待周期会影响从端口的吞吐量。 写传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和writedata，等待周期会影响从端口的吞吐量。 用于同步外设访问，读传输等待周期是必须的，写传输非必须。 在 Qsys 中导入定制 IP 核时，可设要等待的固定周期，读和写时序的等待周期是一样的。 读时序： 写时序： 固定等待周期写传输的一个例子： OLED 定制外设 IP 的部分源码，从端口的写传输实现，VHDL；第二个图是软件设置固定等待周期数，要与源码中的一致。 可变等待周期的读写传输（推荐） 读传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和/或返回有效readdata，等待周期会影响从端口的吞吐量。 写传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和writedata，等待周期会影响从端口的吞吐量。 可变等待周期采用 waitrequest 信号实现，看时序图就容易明白。 读时序： 写时序： 可变等待周期写传输的一个例子： OLED 定制外设 IP 的部分源码，从端口的写传输实现，VHDL。 具有建立时间和保持时间读写传输 具有建立时间和保持时间的固定等待周期的读写传输，用于异步外设，了解。 具有建立时间和固定等待周期的从端口读传输，对于片外从端口异步外设，在主端口发出 read 有效信号之前，需要地址和 chipselect 等信号先稳定一段时间，这样异步外设可以在 read 上升沿开始根据其他信号做出反应，而不会引起冒险竞争，因为在 read 上升沿时其他信号均已稳定； 具有建立时间和保持时间的从端口写传输，对于片外从端口异步外设，在主端口发出 write 有效信号之前，需要 address、byteenable、writedata 和 chipselect 信号保持几个周期的稳定时间。 对于一些 ram 等芯片的时序，设置的当可以把 Avalon 总线直连 此类芯片的总线接口。 “建立时间、固定等待周期和保持时间” 属性在 Qsys 中设置；端口读传输和写传输的建立时间必须相同；建立时间和可变等待周期不能同时采用。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:3:3","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"2 模块收集（不定期更新） p.s 以下为列举日常项目中用到的可以开源的部分模块源码（Verilog or VHDL）或者实现思想（就是留个坑，但还没写）。 Github 上有哪些优秀的 Verilog/FPGA 项目？ Alex Forencich 的 GitHub 主页 pConst / basic_verilog 的常用代码 文件位置：./pConst 的 basic_verilog-master.zip Analog Devices, Inc OpenCores 李锐博恩 Verilog编程实例 NingHeChuan 的 ip_lib ——构建自己的IP库，搭建起你的数字积木 文件位置：./FPGA学习和规范 的参考源码/NingHeChuan 的 ip_lib/ Qsys 中的 SDRAM 使用：IP介绍和使用 软核中的使用例程：（默认16位数据位） /* 写 *(ram_base) = i; 读 *(ram_base)*/ unsigned short * ram_base = (unsigned short *)(SDRAM_0_BASE+0x10000); 类MCU的时间片轮询实现，晶振时钟通过PLL IP得到准确时钟，每个PLL有五个输出，分别分频得到运行周期为 10MHz、5MHz、1MHz、1KHz、100Hz的程序的入口，把不同功能的程序直接放在想要按照某个周期运行的程序入口即可。这个直接写到模板的Top文件即可，不用作为一个模块。 根据寄存器或者外部引脚的电平组合等信息，可以在运行时任设或者有限改动FPGA内部逻辑的输出引脚，就像STM32的外设引脚切换或者K10的FPIOA一样允许用户将255个内部功能映射到芯片外围的48个自由IO上。 按键消抖 思想：当“按键可以检测标志位”有效时，按下的边沿触发启动一计数器，同时标记“按键可以检测标志位”失效，当计数器计数到一定值后，再检测按键是否处于按下状态，如果是则标记“按键有效”标志位做输出，如果不是则停止计数，同时标记“按键可以检测标志位”有效，同时清空计数值。 sopc 读取外部按键设计思路，硬件上先实现一个去抖，然后把无毛刺的稳定的信号传给 nios ii 输入脚，然后 nios ii 里面实现一个外部引脚沿中断。 文件位置：./FPGA学习和规范 的参考源码/按键消抖/ 特定序列检测与发送 思想：用 case 语句实现简单的一段状态机即可。 PWM信号产生 思想：占空比值与一个向上计数器计数值比较，当占空比值比计数值大时输出高电平，小时输出低电平。 参考“小梅哥 AC620V2开发板配套资料”的无源蜂鸣器章节和例程。 I2C模块 小梅哥 FPGA进阶 第十六章 IIC协议详解+UART串口读写EEPROM SPI模块 UART模块 看《FPGA设计-实战演练（逻辑篇）》 吴厚航 的随书源码。（@TODO 不过这个程序的最外层还不够明朗，需要再整理简化使用） 状态机 注意点： 关键是画好状态图； 状态完备； 组合逻辑条件完备； 不能进入死循环； 不能进入非预知状态。 需要穷举所有状态对应的输出动作，或者使用 default 来定义未定义状态动作。 推荐都使用三段式状态机。 参考： 文件位置：./FPGA学习和规范 的参考源码/fsm/ 三种状态机 基于FPGA的有限状态机浅析 三段式状态机 万物基于状态机——状态机大法好 三段式状态机 【BUG记录】三段式状态机编写问题及三段式状态机各部分功能分析 … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:4:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"3 时序分析和约束 参考源： FPGA 高级设计：时序分析和收敛 小梅哥概述时序约束和分析相关知识 小梅哥FPGA时序分析和约束实例演练课程 《深入浅出玩转FPGA第三版》 时序分析章节 《通向FPGA之路—七天玩转Altera之时序篇V1.0》 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:5:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"4 值得跟着的学习网站 SOC FPGA 和 FPGA 等各种开发板开源资料（网上可以找到全套资料）：如 正点原子、野火、黑金、Allegro等开发板（考验资料搜集能力的时候到了）。 小梅哥 B站视频（Verilog \u0026 FPGA基础，SOPC，SOC以及其他常用协议 缺点：视频太~长了。 LeiWang1999/FPGA: 帮助大家进行FPGA的入门，分享FPGA相关的优秀文章，优秀项目 (github.com) 记录比较全面 文档形式的教程： Quartus II的奇幻漂流V1.0——手把手教你使用Quartus II Nios II的奇幻漂流V2.0——基于Qsys的Nios II设计教程 Nios II入门实验 小梅哥 FPGA资料专区 小梅哥 - 博客园 HDL \u0026 FPGA 学习和规范（HDL-\u0026-FPGA- study） FPGA的时序分析和时序约束的资料参考： FPGA 高级设计：时序分析和收敛 小梅哥概述时序约束和分析相关知识 小梅哥FPGA时序分析和约束实例演练课程 《深入浅出玩转FPGA第三版》 时序分析章节 《通向FPGA之路—七天玩转Altera之时序篇V1.0》 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:6:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["规范"],"content":"5 参考 p.s 本文一部分来自自己总结的经验，一部分来自参考。参考不是照搬，是选择我认为的精髓，每个人不同，所以推荐看一下这些参考，TA们都提供了很好的技巧。当然也许还有很多更好的资料，可以留言推荐。 《FPGA设计-实战演练（逻辑篇）》 吴厚航 在“资源下载”栏可下载随书课件和源码 知乎 硅农 Verilog设计的原则和技巧和IP核的使用 还可以参考但还没看的： 《FPGA设计-实战演练（高级技巧篇）》王敏志 … … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:7:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习和规范","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["其它"],"content":"考研个人经验汇总","date":"2020-10-01","objectID":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/","tags":["考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["其它"],"content":"纯干货，不上升到哲学，提个醒，实际安排可调整。 安静，是好环境。 我默认你心理素质强大，所以下面不讲心态的事情。 ","date":"2020-10-01","objectID":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:0:0","tags":["考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["其它"],"content":"选学校 即给多个意向学校的难度做个排列。 首先搜索意向专业的全国高校排名（即搜XX专业大学排名），然后在专业排名名单里逐个查看以下四个内容，形成难易程度可以对比的一个自己的名单。 难度主要看： 对于学校的初试专业课自己是否熟练或者能够熟练； 往年复试分数线； 往年报录比（最好是报的人可以，而且录的人还挺多），看专业统考招生人数和录取名单，以及录取名单上面有多少人和其分数； 复试科目（笔试+面试，初试以前不很重要）。 最后在名单中的前三个，看城市、学校综合排名、牌子等要素确定一个学校。 ","date":"2020-10-01","objectID":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:1:0","tags":["考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["其它"],"content":"备考 专业课往年真题（要烂熟于心）。 英语：先背单词，往年20年真题中所有不会的单词尽量全背，我使用“文本处理工具Replace Pioneer”把20年真题全文粘到这个软件里面，然后给所有单词按照出现次数排序（没错，word 没有这个功能），这样列出所有真题的不重复的单词列表，然后过一遍，着重所有一开始不认识的生词；因为我是稍微有点语感的，所以只要单词认识然后长难句顺口翻译，所以先全背一遍单词；做真题的阅读，读多了慢慢就快了，先看问题，然后去文章中找答案；作文，就准备自己独特的模板，从多个模板各摘一点； 数学：过1、2遍所有课本（数一：高数上下册、线代和概率论），认真总结所有知识到笔记本，要有框架的概念，日后查和背很好用；过1、2遍名家全知识点解析书（毛纲源的（推）、张宇的或者课本配套的解析书（同济绿皮的）等）；烂熟地做真题（近20年）；多关注张宇和李林的微博，不但有测试题，临考还有画重点，准确性值得去会；不要只看重点，全面的看；最后认真做李林（推）、张宇等的预测卷； 政治：看网课（徐涛的），有个印象；过1遍知识解析书（徐涛的或肖秀荣的）；最后必背肖八、肖四（推，感觉太多就只背肖四）；并多关注徐和肖的微博或者公众号，不但有每日测试，临近考试还有画重点，如果肖画了肖四的重点题，那么就只背重点题，其他不管，成功写上也就有60分左右了；背的技巧：编短语，比如最后画了重点题，这几个题可以归纳出八个大段的话需要背，每一段摘一个字或者两个字，然后组合编成8个字或者16个字的类似“顺口类”的短语，做到把其中的字对应一大段话，做到只要一说这个短语就能全部说出来，就都能记。 下面是一张“泛泛经验”的图。 如下图，这是把大概五本书的内容总结成一个小册子。 精简，找到规律，形成框图和节点的连接关系，也好理解也好记，每天看一些，记一点，慢慢就看完了。 ","date":"2020-10-01","objectID":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:2:0","tags":["考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["其它"],"content":"复试 复试是竞争，要先回想和归纳一下本科所有有价值的经历（认真的，不开玩笑），列出来，并形成一个简历（成就罗列）。 复试看能力，除了学业就是相关领域的竞赛奖项、经手的项目、论文等，还有毕设的完成情况和含金量，这些要尽量主动多说，问一句要回答的多而全，言之有物，尽量表达自己的亮点（经历的难点或与众不同的点）。 如果相关竞赛等成就囊中羞涩，老师会多问学业、专业课上的细节问题，不但书本上大部分概念要记全面而清楚（尽力），还要有一个总体认知（总体认识也便于对一个学科记忆和应用）。 即便是人生困难时期，到坎上了，也会默默持续去做，让自己忙起来，就像独自一人穿过森林（日后虽然不想回忆，但也是人生组成部分）。 耐下性子，多想一想做一做，然后过去就好了。 希望我们稍后在森林另一头见到。 ","date":"2020-10-01","objectID":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:3:0","tags":["考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["其它"],"content":"一个名叫“巧克力板”的开源电源介绍","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"一个实现大功率可调的开关电源，附带多路多种输出和实用功能；本项目是“折耳根”计划的一部分。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:0:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"本项目的 GitHub仓库 Qitas/PowerBar: 一个实现大功率可调的开关电源，附带多路多种输出和实用功能 (github.com). 该项目早在2020.7开始在github上更新了，中间停隔了半年多，又于近日开始完成了 V2 版。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:1:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"开源内容 设计规划文件； 原理图pdf文件； 被选型的芯片包； multisim 模拟文件，包含CC-CV、恒流源、基准和过压保护； 渲染效果图原图。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:2:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"输入规格 3S航模锂电池直接供电，或者12V\\24V开关电源模块供电。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:3:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"主输出规格 主输出：DCDC升降压BUCK，外置MOS，至少10A，20A以上最好，最大可以30V左右(由电阻限制)，恒流、恒压分别可调。 主输出可借鉴的芯片列表：LTC3789（外置MOS）；CSD18540Q5B（100V 70A），贴片的占地小。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:4:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"副输出规格 固定5V（5A BUCK）; 3.3V（0.5A LDO）; 一路5A BUCK可调等； 可调负电压； TL431+三极管做的一路可调恒流源。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:5:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"其他模块 SG3525提供一组带死区的互补输出的高性能的PWM输出； 提供一路硬件正交波形解码； 提供一组 XKT412 方案无线输电； 提供一组 IP5306 方案的备份电源； 提供一组 TL431 方案的可调基准源。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:6:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"其他要求 原理图和PCB尽量遵循 SCH \u0026 PCB 设计规范 ； 滤波、地划分隔离、保护措施等尽量遵循 Qitas/protection-circuits； 输出接口丰富多样； 等等。 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:7:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"电源路径 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:8:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["其它"],"content":"渲染效果图 ","date":"2020-07-01","objectID":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:9:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["主线剧情"],"content":"介绍 uboot 的基本概念、源码分析和移植步骤","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 移植基础详解 本文系广泛撷取、借鉴和整理（相关的内容在网络上有很多，但很多相互抄，或者是版本太老，或者就是不通用的非常有平台针对性的步骤，碎片化泛滥，甚至就是有待分拣的垃圾厂，当然也有一些好的文章，都会看），经过了细心、耐心、小心、佛心乃至贤者模式、莫生气、开始怀疑、愁然、不畏怯、再到渐入佳境、逐渐明朗的学习过程，再经过了广泛翻阅和对比，边做边写，对主要内容进行了精髓提取。 过于基础的内容不会在此提及，比如 SoC 芯片的启动流程、什么是 bootloader 等等内容，此类背景知识在几乎每一本嵌入式 Linux 书籍都会提及，在此不会赘述；本文专注具体 u-boot 的启动流程、移植和编译等（以百问网的 imx6ull 和 米尔、NXP 的 imx8mm 这两种平台为例），为了区分于网络上碎片碎末、残缺不全、缺斤少两、半斤八两、一个巴掌拍不响的各种文章，本文尽量做到通用化的、全面化的学习记录，并且会说明我是看的什么资料，目的就是在面对新平台时候，可以自主移植、编译和跑起来，融会贯通，而不是把人当作定制化的没有主观能动性的机器。 参考大量文章和教程以及触(连)类(猜)旁(带)通(蒙)的反复测试，记录成功的步骤，而成此文，如有错误恭谢指出！侵删。作者见 “署名” 一节。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:0:0","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 篇 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:0","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"成熟的 bootloader 先说思想，bootloader 是很有用、很方便的一种发明，作为一个 bootloader，本质是一个在 MCU 或者 MPU 首先运行的裸机程序，通过通讯接口（UART、EtherNet、CAN、USB、SD 卡 等等）把编译好的 APP 程序的二进制文件或者镜像首先下载到内存中，或者是从 FLASH 中读取 APP 程序数据放到内存中，并跳转到 APP 程序处开始执行，在内存中跑的程序对于取指等 CPU 操作等待的时间比在 FLASH 中跑的程序快得多；或者通过把从一个接口接收的 APP 程序数据存储到 自己的 FLASH 中，实现自己给自己烧录（自举， IAP），比如把 SD 卡里面的 程序数据读出然后烧入 自己的 FLASH 里面，或者从 USB 接收程序，这些方法方便板子的批量烧录；还可以预先在自己的 FLASH 中存入多个 APP 程序，根据外部指令选择运行哪一个，不用反复烧写便可实现更换程序；说到这里，给 MCU/MPU 加一个 bootloader 后，其灵活性、可操作性就提升了维度。bootloader 要实现这些功能，就当然需要先初始化这些通讯接口和储存设备（DDR / FLASH），还要提供一个人机交互界面（一般为命令行）并实现一些命令，搬运应用程序到内存，准备要跳入操作系统内核的环境并跳转启动该内核，这些即是一个 bootloader 的最小实现。 关于 MCU 的 IAP 更多内容可见我的另一个开源项目 Qitas/u-iap: 一个志在实现适用于 MCU 的通用 IAP 程序框架，可以从串口、外部 SPI FLASH、外部 SDIO SD 卡、USB Device MSC 或者 USB HOST MSC等等途径更新 MCU 固件。 (github.com)。 以上说的都是最最基本的，更多 bootloader 的更专业（更官话）的介绍文章如下： 搞嵌入式的，为啥要有uboot？ (qq.com)； 嵌入式系统 Boot Loader 技术内幕_业精于勤,荒于嬉;行成于思,毁于随-CSDN博客； ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:1","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 启动流程 不但知其然，还要知其所以然。如果熟悉《【主线剧情01】ARM IMX6ULL 基础学习记录》里面的内容，那么作为 bootloader 一种的 u-boot 的启动过程，就相当于扩充了、丰富了和复杂了 的那篇文章里所介绍的启动文件 start.s 的过程，主要步骤可以一一对应上。u-boot 启动流程仅作知道一下有这回事，不必深究。 不同版本的 u-boot 以及不同的板子的文件位置和初始化流程会有偏差。以下启动流程为笔者主要用 grep 和 find 命令一点一点看源码梳理出来。 以 i.mx6 为例 以下基于 u-boot 2017.03 的 100ask i.mx6ull 平台： 上电运行 arch/arm/cpu/armv7/start.S，在这里面执行以下： CPU 设为 SVC 模式，关中断（IRQ 和 FIR），关 MMU，关看门狗等； 执行 bl cpu_init_crit，跳到同目录下的lowlevel_init.S，再跳到 同目录/mx6/soc.c的s_init()进行时钟等检查和设置； 执行 bl _main，跳到 arch/arm/lib/crt0.S的_main。 在arch/arm/lib/crt0.S，_main里面执行以下： 设置栈 stack_setup；为 C 环境做准备；清除 BSS 段； 执行 board_init_f，（第一次初始化）基本硬件初始化，如时钟、内存和串口等，这个函数可能位于 board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c 文件里或者位于common/board_f.c文件里，其里面的宏定义在其对应的头文件里 include/configs/\u003c板子名\u003e.h； 调用重定位 relocate_code，源码位于arch/arm/cpu/armv7/start.S，（第一次搬移）u-boot 自搬到内存 ； 执行 board_init_r，（第二次初始化）对外设的初始化，位于 common/board_r.c，初始化 init_sequence_r 列表中的初始化函数，最后调用run_main_loop()，其再调用 common/main.c里的main_loop()。 进入 common/main.c，main_loop()，延迟bootdelay_process()，若无输入则进入自启动 autoboot_command()，若有输入则进入交互模式 cli_secure_boot_cmd()； 根据命令或自启动流程，若要 boot 进入系统，跳到 cmd/bootm.c 的 do_bootm()，再调用同文件的 do_bootm_subcommand()，调用 common/bootm.c 里的 do_bootm_states()，在这里面检测是否有 OS，是什么 OS，如果有 Linux 系统，则下一步； （第二次搬移）搬运 Linux 内核到内存； 然后调用 common/bootm_os.c 里的 boot_selected_os()，其调用 arch/arm/lib/bootm.c 里的 do_bootm_linux()，再调用同文件里的 boot_jump_linux()，跳到内核的起始地址，进入 \u0026 运行内核。 更详细的启动流程介绍可以参看《【正点原子】I.MX6U嵌入式Linux驱动开发指南》的第三十二章节，目前发现的最全面的。 以 i.mx8 为例 以下基于 u-boot 2019.04 的 uboot-imx 中的 imx8mm 平台，这里主要描述各种初始化函数的跳转关系和逻辑： 上电执行arch/arm/cpu/armv8/start.S 后跳转到arch/arm/lib/crt0_64.S的_main里： 首先调用common/board_f.c里面的board_init_f()（第一次初始化），其调用init_sequence_f[]数组里的各个初始化函数，数组中有 board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c中的board_early_init_f()； 然后调用relocate_code（第一次搬运）uboot自搬运到内存； 调用common/board_r.c里面的board_init_r()（第二次初始化），其调用init_sequence_r[]数组里的各个初始化函数，数组中有： board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c中的board_init()； board_early_init_r()，在 imx8 的文件中没有用到； board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c中的board_late_init()； run_main_loop()； 跳入 uboot 的主循环 run_main_loop()之后，等待外部输入命令或超时等待自启动； 进行启动，找到 Linux kernel 镜像，搬运其到内存（第二次搬运），跳转启动。 更多 u-boot 启动过程介绍文章： 更详细的引导内核过程。 u-boot分析 - 蜗窝科技 (wowotech.net)。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:2","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 命令 若设置了 u-boot 启动时等待任意键输入几秒，若有输入，则退出自启动模式而进入命令行模式。 help：显示所有命令及其说明； help 命令：显示命令详细的使用说明； pri：查看所有环境变量，包括开机等待任意输入的时延（秒）、串口波特率（baudrate）、本地 IP 地址（ipaddr）、tftp 服务器端的 IP 地址（serverip）、自启动命令字符串（bootcmd，一般不用动）等等； setenv \u003c环境变量\u003e \u003c要设置的值\u003e：修改某一个环境变量为要设置的值，要设置的值 若是字符串则要加双引号； saveenv：将当前所有设置过的环境变量保存，掉电不丢失； reset：复位； dhcp：执行 DHCP 服务，获取 IP 地址，验证网络功能； setenv my：恢复系统的所有环境变量为默认，即使之前用户重设的环境变量都恢复默认； protext on/off 0~10000：对 Nor Flash 区域 [0x0 ~ 0x10000] 设置为写保护或取消写保护； movi：对 EMMC 进行操作； run bootcmd：，执行 bootcmd ，其是一个环境变量，为一段字符串形式的命令；上电后 u-boot 若处于自启动模式最后执行则执行的多条命令，默认为 下载内核、设备树和运行内核的多个命令，可以根据需要增加命令，以分号分隔。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:3","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 移植要点 要点： 一般厂家直接提供 u-boot 源码，做查看、修改(增加新功能) 或 u-boot 版本升级这三大块的用处；后两种都需要对新板子做适配/移植。 如果没有提供 u-boot 源码，那么就从 u-boot 官方版本中找到一个最相近的板子配置进行移植，这个需要水平较高。 一般把 u-boot 做成对应平台通用的和最小化的，即只保留必要的板级外设初始化代码（如串口、网口和 FLASH 等需要主要做适配，都尽量找能现成使用的），其他更多板级外设初始化在 Linux 移植部分中完成。 如果要深入学习，有以下要点可以参考： 如果芯片公司或者单位提供了移植好的 u-boot，可以用 beyong 软件把移植好的 u-boot 文件夹与 官方原版（版本要一致）进行对比，看一看改动了哪些文件夹和哪些文件，帮助学习。 uboot移植新手入门实践_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili。版本比较新。 正点原子【第三期】手把手教你学Linux之系统移植和跟文件系统构建篇_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 韦东山 _ 嵌入式Linux _ 第1期与2期间的衔接课程 _ u-boot编译体验和源码深度分析 _哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 老版本。 【韦东山 】移植U-boot 2012 04 01 到JZ2440_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 老版本。 linux—–uboot和kernel移植 - 灰信网（软件开发博客聚合） (freesion.com)。 芯片公司、开发板厂家和用户三者之间的联系： 芯片公司移植的 u-boot 从一开始是基于官方的 u-boot 拿来修改，添加/修改自家的 EVK 评估版的板子型号、相关外设初始化文件，并修改 u-boot 的 Makefile 配置，然后把自家芯片的 EVK 评估版的硬件原理图、u-boot、Linux 和 根文件系统以及使用说明文档等等全部开源，以供下游做应用的公司/厂家和做开发板的公司拿来做修改或直接应用； 做开发板的厂家在拿到了芯片公司提供的芯片评估版 EVK 板子的原理图后，与 SoC 直接相关的比如 PMIC、DDR、FLASH、以太网 PHY 芯片等等不会做大改，一般直接照搬过来画自己的开发板。因为在移植 u-boot 的时候就不用再为新选型的芯片做代码适配，一般没必要做这种费力但效果不大的事情，能直接用的就尽量直接用，能不用改的就尽量不改。然后再拿到芯片公司提供的芯片评估版 EVK 板子对应的 u-boot 源码之后，同样的再添加/修改为自家开发板的型号、添加一点点自己板子的外设初始化代码（这个要求比较高）并修改 Makefile，便得到自家开发板适配的又一个 u-boot； 当用户（比如现在的我）拿到了开发板厂家 或者 芯片公司提供的 u-boot 源码，即所有相关文件和初始化代码都写好了，便可以直接编译进而使用，或者自己再进一步定制化，那么此时此刻间，具体的移植步骤介绍在以下： ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:4","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 配置/移植并编译 注意，网上很多 u-boot 移植教程都是三星的 2440 或者 4412 在 古董级别的 u-boot 上面的移植，不是说不好，而是现在的 u-boot（2019 以后的版本）的 Makefile 结构等等都已变化太大了。 平台相关的目录：arch、board、include 等，平台无关的目录：common、net、fs、drivers 等等。 环境构建 不同的 SoC 需要准备不同的交叉编译器，对于 i.mx 系列，参考其官网手册通过一系列 NXP 提供的自动化脚本生成，以及配置好环境变量，即可使用此专用的交叉编译器编译 u-boot、Linux kernel 和 Linux 驱动/应用。 现以 i.mx8mm 为例，参考从其官网网址下载的嵌入式 Linux 手册包 imx-yocto-L5.4.70_2.3.0.zip 里面的手册来准备编译环境，提前说明，这个步骤是对于 NXP i.mx 系列的独家方法，其中一些编译步骤要花费巨长的时间，读到此的游客了解即可，除非要用，否则可以不用实践一遍。对于买 i.mx 系列开发板的，如果不愿从头做一遍，可以直接使用开发板公司提供的资料里面的环境配置脚本和交叉编译器，就直接跳过这一小节。 以下步骤都在 Linux 主机上进行。 参考 “i.MX_Yocto_Project_User’s_Guide.pdf” 手册： Linux Ubuntu 18.04 主机安装必要包： sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm 新建存放资源的文件夹，这里取名 “nxp_imx”，在里面再建立一个放 bsp 的文件夹取名 “imx-yocto-bsp”； 配置 git 信息： git config --global user.name \"\u003cYour Name\u003e\" git config --global user.email \"\u003cYour Email\u003e\" git config --list 先下载 repo 程序：sudo apt-get install repo ；然后在 imx-yocto-bsp 文件夹下面执行： repo init -u https://source.codeaurora.org/external/imx/imx-manifest -b imx-linux-zeus -m imx-5.4.70-2.3.0.xml repo sync 如果上一条命令执行不成功，先删除目录中的 .repo 文件夹，再试；若还不成功，参考关于使用repo时repo init和repo sync失败的一个解决方案 - 代码的搬运工 - 博客园 (cnblogs.com)，参考这个文章的方法，若遇到 repo 超时错误，尝试用方法2： # 先手动下载 repo git 仓库 git clone https://gerrit-googlesource.lug.ustc.edu.cn/git-repo # 然后用以下命令替代上面第一条不成功的 repo 命令试试，这一句大概率会成功 ./git-repo/repo init -u https://source.codeaurora.org/external/imx/imx-manifest -b imx-linux-zeus -m imx-5.4.70-2.3.0.xml 上一个步骤执行成功结束后，会得到 imx-yocto-bsp/sources 文件夹和其他文件，You can perform repo synchronization, with the command repo sync, periodically to update to the latest code。源文说明：The “sources” directory which contains the recipes used to build one or more build directories, and a set of scripts used to set up the environment.The recipes used to build the project come from both the community and i.MX. The Yocto Project layers are downloaded to thesources directory. This sets up the recipes that are used to build the project. 构建针对 i.mx8mm 的配置，i.MX provides a script, imx-setup-release.sh, that simplifies the setup for i.MX machines. The script sets up a directory andthe configuration files for the specified machine and backend。在imx-yocto-bsp目录需要执行的命令模板： DISTRO=\u003cdistro name\u003e MACHINE=\u003cmachine name\u003e source imx-setup-release.sh -b \u003cbuild dir\u003e 以上命令需要填的空： DISTRO=is the distro, which configures the build environment and it is stored in meta-imx/meta-sdk/conf/distro. 可选：fsl-imx-wayland - Wayland weston graphics 和 fsl-imx-xwayland - Wayland graphics and X11. X11 applications using EGL are not supported，一般就都选这个吧； MACHINE=is the machine name which points to the configuration file in conf/machine in meta-freescale and meta-imx. 要选 meta-imx/meta-bsp/conf/machine/ 目录下的文件名，具体的板级配置文件，这里选 imx8mmddr4evk； -b specifies the name of the build directory created by the imx-setup-release.sh script.这里选-b imx8mmddr4evk_sh； 最终实际执行的命令： DISTRO=fsl-imx-xwayland MACHINE=imx8mmddr4evk source imx-setup-release.sh -b imx8mmddr4evk_sh 上一句完成后会自动进入 ./imx8mmddr4evk_sh 目录，并且执行信息最后面部分有提示，翻译过来就是可以执行 bitbake 命令了。 参考 “i.MX_Porting_Guide.pdf” 手册： 先说，这一步是构建交叉编译工具链，可以参考 “工具链构建的更多方法” 小节的方法构建，基于 yocto 的方法在个人 PC 上所需的时间太漫长了，除非有高性能的服务器。 Generate a development SDK, which includes the tools, toolchain, and small rootfs to compile against to put on the host machine. The same SDK can be used to build a standalone kernel. 在./imx8mmddr4evk_sh 目录要执行的命令模板： DISTRO=Target-Distro MACHINE=Target-Machine bitbake core-image-minimal -c populate_sdk 还是需要填空，实际执行的命令为： DISTRO=fsl-imx-xwayland MACHINE=imx8mmddr4evk bitbake core-image-minimal -c populate_sdk -c populate_sdk选项表示构建应⽤层⼯具链； The populate_sdk generates a script file that sets up a standalone environment without Yocto Project.这一步需要 Linux 主机有至少 150G 的空间，这一步要花很长很长时间，第一次执行 5 ~ 10 个小时是有的…也可能是从外网下载包慢，总之做好准备。 如果这一步漫长的过程中间被中断或者有下载包失败，那么可以在上一级目录中重新执行DI","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:5","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 编译流程 首先编译/$(CPU)/start.S，对于不同的 CPU，还编译cpu/$(CPU)下的其他文件； 然后，对于平台/开发板相关的每个目录、每个通用目录都使用它们各自的 Makefile 生成相应的库； 将前两部分产生的 .o .a 文件根据 u-boot.lds 进行链接；得到最终文件。 更多 u-boot 源码分析等内容看上面 “u-boot 启动流程”、“u-boot 移植要点” 章节内容。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:6","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"u-boot 图形化配置 在 uboot 目录里面先执行make \u003c板名\u003e_defconfig，再执行make menuconfig。方向键移动光标，enter 进入子菜单，空格键打开/关闭一个选项，双击 tab 键返回上一个目录。 执行make \u003c板名\u003e_defconfig之后会把配置信息写入 .config 文件，再执行make menuconfig，menuconfig 通过读取 .config 文件来显示，经过 menuconfig 配置并保存，实际是修改了.config文件，此时执行 make 命令进行编译会用.config文件（在make \u003c板名\u003e_defconfig的基础上再经过 menuconfig 修改之后的最终的配置文件）的配置信息进行编译；如果执行 make distclean 会删除.config文件；所以通过 menuconfig 配置的是临时的，经过清理后就不存在了。 目标 menuconfig 依赖 scripts/kconfig/mconf，后者会调用 uboot 根目录下的 Kconfig 文件开始构建图形化配置界面，此 Kconfig 里面的 mainmenu 就是主菜单，有关此菜单的 Kconfig 语法可以参考《【正点原子】I.MX6U嵌入式Linux驱动开发指南》的 34.2.2 Kconfig 语法简介 一节以及 34.3 添加自定义菜单 一节。 构建图形化配置界面更多参考： Linux内核编译——Uboot_笑傲江湖-CSDN博客； uboot图形化配置浅析 - lzd626 - 博客园 (cnblogs.com)； .. ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:7","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"添加自定初始化代码 以下还是根据 imx8mm_evk 板子而言，不同板子函数的位置会有变动。 接着前文的工作，只需修改board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c文件及其对应的 .h 文件，在其中的 board_early_init_f()、 board_init() 或者 board_late_init() 函数中添加自己要加的驱动代码。尽量只改这两个函数即可，其他初始化函数不用多动。 各个初始化函数的说明（以下是按照执行顺序排列，以下函数都在board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c文件里面）： The board_early_init_f() function is called at the very early phase if you define CONFIG_BOARD_EARLY_INIT_F. You can put the UART/SPI-NOR/NAND IOMUX setup function, which requires to be set up at the very early phase；这个函数被调用在第一次初始化阶段，初始化看门狗、串口时钟等。 The board_init() function is called between board_early_init_f and board_late_init. You can do some general board-level setup here. If you do not define CONFIG_BOARD_EARLY_INIT_F, do not call printf before the UART setup is finished. Otherwise, the system may be down；第二次初始化阶，段推荐在这里改； The board_late_init() function is called later. To debug the initialization code, put the initialization function into it；第二次初始化阶，推荐在这里改。 改变打印板子名： u-boot logo：打开 uboot-imx/tools/Makefile，执行:/LOGO_BMP搜索 “LOGO_BMP”，分析 Makefile 可知 默认使用$(srctree)/$(src)/logos/denx.bmp的图片，如果存在 logos/$(BOARD).bmp 或者 logos/$(VENDOR).bmp 就使用，可以直接在此按需替换。具体的显示 logo 的函数在uboot /board/esd/common/目录下的 lcd.c 文件中，大约在 81 行左右。屏幕的初始化配置在官方源码的\u003cboard name\u003e.c文件里面。因为 uboot 启动的时间很短，一般都使用 Linux 的 logo，所以 uboot 中可以将 logo 图片删掉，或者在\u003cboard name\u003e.c里面将显示有关的代码屏蔽掉。 增加 uboot 额外的版本信息，在 uboot 目录里面先执行make \u003c板名\u003e_defconfig，再执行make menuconfig，在 Console 里面的 Board specific string ... version string里面填入板子名和版本字符串。 对于 imx8mm： 在 arch/arm/dts/imx8mm-ddr4-evk.dts 里面的 model 改板名，板子上电后 uboot 的 Model: 会显示这里的信息；board/board-info.c 里面的show_board_info()会调用读取这个 model； 在 \u003c板名\u003e.c 里的 board_late_init()，有一个设置 uboot 的 board_name 环境变量； 对于其他 imx8 系列： 在 \u003c板子名\u003e.c 中，board_early_init_f()的init_sequence_f[]里面有一个checkboard()函数； 直接一点的方法：delete identify_board_id() inside checkboard() and replace printf(\"Board: \"); with printf(\"Board: i.MX on \u003ccustom board\u003e\\n\");； 间接方法，The identification can be detected and printed by implementing the __print_board_info() function according to the identification method on the custom board，查看一下identify_board_id()和 __print_board_info()这两个函数的内容，进行修改。 调试：在串口初始化之后的程序中可以添加printf()函数打印调试信息，初始化串口函数默认在board_early_init_f()里面。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:8","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"添加自定义命令 u-boot 添加自定义命令。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:9","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"添加命令行菜单界面 UBOOT通用菜单menu的实现_leochen_career的专栏-CSDN博客； uboot中的快捷菜单的制作说明-小超hide-ChinaUnix博客； 如何在U-Boot中添加自定义命令_HowieXue 薛永浩的博客-CSDN博客； … ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:10","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"合成最后的二进制文件 这里还是针对 nxp i.mx8mm 而言，armv8 的 SoC 应该都大同小异。 看 i.MX_Linux_Users_Guide.pdf 手册的 4.1.1 Bootloader 章节：On i.MX 8M SoC, the second program loader (SPL) is enabled in U-Boot. SPL is implemented as the first-level bootloader running on TCML (For i.MX 8M Nano and i.MX 8M Plus, the first-level bootloader runs in OCRAM). It is used to initialize DDR and load U-Boot, U-Boot DTB, Arm trusted firmware, and TEE OS (optional) from the boot device into the memory. After SPL completes loading the images, it jumps to the Arm trusted firmware BL31 directly. The BL31 starts the optional BL32 (TEE OS) and BL33 (U-Boot) for continue booting kernel. In imx-boot, the SPL is packed with DDR Firmware together, so that ROM can load them into Arm Cortex-M4 TCML or OCRAM (only for i.MX 8M Nano and i.MX 8M Plus). The U-Boot, U-Boot DTB, Arm Trusted firmware, and TEE OS (optional) are packed into a FIT image, which is finally built into imx-boot. 看 i.MX_Porting_Guide.pdf 手册 5.3 OP-TEE booting flow 章节：On Arm V8, Arm has a specified preferred way to boot Secure Component with the Arm Trusted Firmware (ATF). The ATF first loads the OP-TEE OS. The OP-TEE OS initializes the secure world. Then, the ATF loads U-Boot that modifies the DTB on the fly to add a specific node to load Linux TEE drivers. Then, the Linux OS is booted. 需要的组件：(U-Boot, Arm Trusted Firmware, DDR firmware) imx-atf（Arm trusted firmware）：ATF 主要负责 Non-secure 环境和 secure 环境的切换（编译后产生所需的一个 bl31.bin 文件）。 imx-uboot： nxp 提供的 适合 imx 系列的 u-boot（编译之后产生 u-boot-nodtb.bin、u-boot-spl.bin 和 设备树 .dtb 三个所需文件）。 system controller firmware：直接提供的一个二进制文件，启动时由 spl 或者 uboot 调用，用以初始化 DDR。 imx-mkimage：生成目标镜像的工具。 简短的说： 编译 u-boot，产生 u-boot-nodtb.bin、spl/u-boot-spl.bin、arch/arm/dts/xxx-imx8mm-base.dtb 文件后，再编译 imx-atf，再利用 imx-mkimage 镜像合成工具把所有编译好的文件连接整合成最后适合 imx8mm 的 u-boot 的二进制文件 flash.bin。然后可在 linux 主机 上使用 dd 命令烧入 sd 卡的存放 u-boot 的分区里面。或者使用根文件生成软件如 buildroot 或 yocto 合成最后的 sd/emmc 镜像文件。 具体步骤：参考 “环境构建” 小节 的第 4 ~ 6 步 “使用 imx-mkimage 链接合成所有文件生成最后二进制文件”。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:11","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"其他补充说明 比较两个文件的异同，可用 diff -yB 文件1 文件2 命令，以显示全部源文和标出不同之处显示。 Makefile 中，obj-y += xx.o xx.o 在编译时，只编译带有 obj-y的；比如 obj-$(CONFIG_MX6) += mx6/，若 CONFIG_MX6 为 y，则会编译 mx6/ 目录下的内容，否则不会。 在哪个目录添加了文件，若想其被编译，就在其所在目录的 Makefile 文件中添加 obj-y += \u003c文件名\u003e.o；COBJS-$(CONFIG_CMD_MMC) += cmd_mmc.o，这种是用变量控制的，若 CONFIG_CMD_MMC 变量为 y，则会添加编译，否则不会。 添加初始化代码： 在 include/configs/\u003c板子名\u003e.h 里面添加初始化代码相关的宏定义； 在 board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c 里，在 board_xxx_init() 函数里面添加对应的初始化函数，比如 board_eth_init() 里面添加 dm9000_initialize() 初始化函数。 增加个串口输出特定内容： 在 /common/board_f.c 中加：\\#include \u003cdebug_uart.h\u003e； 在 void board_init_f(ulong boot_flags) 中加一句 printascii(\"uboot runnig.\\r\\n\");。 不同家的 SoC 和同一家但不同系列的 SoC 的启动流程会不同，有的 SoC 的 DDR 等初始化在 DCD 段，有的在 SPL 段，在用芯片公司提供的 u-boot 编译的时候 会用 mkimage 根据已经提供的默认的 .cfg 文件进行正确的连接组合产生 uboot 镜像/二进制文件，具体还是要多看官方手册，和理解性的看《【主线剧情01】ARM IMX6ULL 基础学习记录》，只看这里是容易迷糊的。 i.mx8m 系列启动 Linux 所需的要素： imx-boot (built by imx-mkimage), which includes SPL, U-Boot, Arm Trusted Firmware, DDR firmware； HDMI firmware (only supported by i.MX 8M Quad)； Linux kernel image； A device tree file (.dtb) for the board being used； A root file system (rootfs) for the particular Linux image。 如何理解曾博所说的“看国外数学教材提高智商”？ - 知乎 (zhihu.com)，其中说到 “国内大学很多教材简直魔幻，是“你只有学会了才看得懂”，然后学生是“需要看教材才学得会”，反复套娃死循环。 “； 写一个操作系统内核有多难？大概的内容、步骤是什么？ - 知乎 (zhihu.com)，其中说到 “人家通俗易懂，很有诚意，比起那些复制粘贴强行装B的书不知道要强多少倍。。。 “； NXP i.MX 8M Mini平台Linux系统启动时间优化 | i2SOM湃兔核； … ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:12","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"署名 编辑整理：Github 页，知乎页 发表时间：始于 2021.5 且无终稿 首发平台：知乎 \u0026 Github 遵循协议：CC-BY-NC-SA 4.0 其他说明： 本文件是“折耳根”计划的一部分，尽量遵循 “二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明（这中二魂…）！ 本文系广泛撷取、借鉴和整理，适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！ 转载请注明作者及出处。整理不易，请多支持。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:13","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["规范"],"content":"软硬件规范化的伟大意义和远景","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":" 本文源地址Qitas/norm-of-software-and-hardware: 目录贴，个人软硬件规范的索引总贴。以及本科阶段触及的大部分领域及其顺延的小总结。CC-BY-NC-SA 4.0。 (github.com)。今后的更新只在上面的连接里，这里不会跟进。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:0:0","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"意义 不多言语，直接引用观视频工作室视频【大师计划·林宝军03】北斗三号总师：我来跟你说说，…里面总师受访时所说的话： 5:48：“…所以我经常讲，要把一个产品做好，其实有三方面，一个是技术，一个是质量，一个是管理，这三方面；技术水平，质量保障能力和管理能力，三条腿哪个都少不了，少一个，这个东西（航天）也做不上去，其实技术只是一方面，…” 6:44：“…光是技术上去了，不见得能做出一个系统。对我们工程来讲，就是（需要）规范的文化，什么意思呢，比如我们几十年的航天经验，我把这个经验总结成文字，总结成规范，不管是谁做，只要有一定的经验，按这个规范做出来，做得卫星出来，打到天上去就能好用，这就是规范文化。包括匠人文化和规范文化，最后都是按规矩去做，它强调的是解决了怎么做的问题，但它有一个缺点，没强调为什么，其实我认为在做的过程中，加个为什么可能更好。” 规范在实用层面的意义： 编程框架固定； 标准组件重用； 注重应用开发； 快速且不易出错； 易于问题定位； 快速提高项目组水平。 在网上规范文章随处有的情况下，我为什么还要自己总结规范？因为每一个文章都不会是全的，就这么简单，我吸收、整理和合并它们，成为更全的，并在我以后自己的项目中遵守这些规范，实现更好的阅读性、操作性、解耦性、分层次性、模块化等，集百家之长，此乃折耳根之精髓之一。 还有一件事，根据脑科学的一些研究结果，大脑中的记忆，尤其是以前发生的事情的细节，是会发生改动的，而细节的偏差会影响大局的择决；就从日常生活经验也能感觉出，这个结论有一定真实性，所以，把几乎所有的细节都放到大脑里是非常不靠谱的事。 有的人因为看见所以相信，而有的人，因为相信所以看见，我想，后者更具有价值和希望。 “我一直认为，人类历史上最伟大最美妙的故事是通过科学讲出来的。科学所讲的故事，其宏伟壮丽、曲折幽深、惊悚诡异、恐怖神秘，甚全多愁善感，都远远超出文学故事。” 若将才华待年华，匆匆岁月不足惜。愿与君共寻人世间意义。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:1:0","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"内容 以下链接中，括号内的为知乎文章地址，其他链接为 GitHub 仓库地址。 软件框架，规范化。 关于 C \u0026 MCU 的规范（C \u0026 MCU编写规范和其他）（“低耦合，可重用，参数化，注释全”） 关于 HDL \u0026 FPGA 的学习和规范（FPGA \u0026 HDL 学习和规范） MCU Framework 项目 IMU 选型和算法 Awesome-K210 开源协议汇总和选择 Awesome-Embeded-AI ARM-Linux-Study 硬件模块，规范化。 硬件规范（SCH \u0026 PCB 设计规范和 AD 的使用） 开源开关电源项目 （【开源电源】巧克力板） 开源 BLDC FOC 项目（更新会超级慢） 硬件保护项和措施 硬件测试的指标条目、每个项目的测试步骤和测试报告，规范化。请戳这里（暂无）。 这些是我本科阶段触及的一部分（不是所有，本科玩的东西真多…字面意义的玩，不深入）领域及其顺延的小总结。下一篇就是硕士阶段的触及领域及其顺延的大总结了，内容定将极其多。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:2:0","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"实践 经验之谈。 开拓一个新领域，在找资料的阶段，可以去淘宝、咸鱼和拼多多等寻找资料，有时会碰到很全的，甚至瞬间解决大部分问题。 进军一个新领域，先找相关行业的\"行业分析报告\"。在哪里能找到各行业的分析研究报告？ 项目组在开始一个全新的项目时，应尽量由经验多、规范意识好、能力最强的一些人谋划和开篇这个新项目，做的尽量高内聚、低耦合、可重用、注解全，并且日后易于维护和增改，如果能配上详细的手册就太好了，大家都喜闻乐见。相反的情况就是让初入茅庐的人建立地基，结果就是一地鸡毛、一团乱麻，搞的大家都不舒畅。 开始一个全新的项目时，应首先 全！网！ 收集相关资料、文献和参考设计；例如笔者在筹备 BLDC 原理图时，就全网收集了数十张原理图方案；经过交叉横向对比后，快速形成考虑比较多的、功能齐全的和子系统优选的更新进的方案出来。 许多问题应在设计时避免，除了吃头各种官方文档，还要多找一些相同任务的设计进行横向对比，找它们的不同之处并搞清原因；还要考虑增加安全性的设计（防错、纠错和相应的处理，对用户的 傻瓜化操作设计 和 防傻防呆设计（防止乱用错用））、冗余性设计（多路冗余）和可调试性设计（留有可以调试和改动的余地）。 关于软、硬件的模块化，在上面《规范》文章中说到了一些，除了 “增加通用性” 并且使方案可模块化的 “拆解” 和 “拼装”，在此基础上还应考虑 “故障点隔离”，故障的节点（软件或者硬件）做相应处理，失效的节点做隔离/孤立处理，这个往往需要软硬件协调的设计。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:3:0","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"远景 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:4:0","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"关于软硬件标准化 这是 ZLG致远电子 在2018年的一篇肺腑文章。 开发者的最大问题是核心域和非核心域不分，大部分时间都在编写不可重用的非核心域的代码。没有聚焦提升产品竞争力的核心域知识，比如，需求、算法、用户体验和软件工程方法等方面，从而导致代码维护的成本远远大于初期的开发投入。 事实上，那些做出优秀产品的团队，不仅员工队伍非常稳定，而且收入也很高，甚至连精神面貌都不一样。因为他们使用了正确的开发策略和方法，而且短时间内掌握的技术远胜于那些所谓的“老程序员”。虽然每个企业都有拿高薪的员工，但为何不是你？别人开发的产品大卖，而你开发的产品却卖不掉？不仅浪费了来之不易的资金，而且导致我们失去了更多的创造更大价值的机会。 十几年前，作者也面临同样的问题，于是毫不犹豫地投身于软硬件标准化平台技术的开发，因为只有方法的突破才能开创未来。AWorks就是在这样的背景下诞生的，定义了外围器件的软件接口标准，“按需定制”为用户提供有价值的服务也就成为了现实。 基于此，ZLG为用户提供了大量标准的外设驱动与相关的协议组件，意在建立完整的生态系统。无论你选择什么MCU，只要支持AWorks，都可实现“一次编程、终生使用”，其好处是你再也不要重新发明轮子。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:4:1","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"框图\u003c—\u003e仿真\u003c—\u003e实物 规范化的下一步，是包括软硬件的模块固定化，标准化设计资料（模块、内部结构和接口等标准化），往后的开发专注于框图设计和模块连接，用软件工具从框图直接生成代码，部署到硬件，这是早就开始的（2、30年前）时代趋势。所以巩固基础，按照规范，多做原创性设计，或者就个人而言，整条链路上下打通，做各个环节的细节和全环节的掌握。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:4:2","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"设计工具 了解到，遇到新问题或新科研，看最新论文动向、行业报告等，收集需求和思考痛点，先进的科研往往先设计工具，或者备好工具和生产资料，再用工具做应用；而大多的企事业和科研单位，往往是在做应用。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:4:3","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["规范"],"content":"基于模型的设计研发 以下图片的出处 传统研发如下图概括。 新理念（早已经不新了）如下图，基于模型的设计研发（Model-Based Design Process）。 这个基于模型的设计研发根据 “需求 \u0026 设计文件” 构建全模拟系统（包括控制、嵌入式、机械和电力电子等），相当于对未来的实物先构建一个 “数字孪生”，在模拟环境中看现象、定参数和找问题等，在 Matlab 中可以更多的做到 从模型生成设计文件、从设计文件生成模型、生成 C 代码，可视化物理仿真等等。 启发： 一个被控对象的非线性模型，先线性化得到一个 LTI 线性时不变模型（状态方程或传递函数），用传统控制理论中的方法（根轨迹、伯德图校正等）得到一组控制器的具体参数（如 PID），并留有较多的相位、幅度裕量，然后再把这些参数带入到非线性模块所在环路的控制器里面再仿真模拟；若裕度不够，则在非线性模型的仿真中会性能显著降低甚至不稳定。 控制系统仿真模拟时： 要么模型建的非常精准； 要么控制器的兼容性、容错性、鲁棒性等很强。 自动生成报表，自动测试。可以自己写一些自动化工具软件替代重复性工作，多做通用性工作。 ","date":"2021-03-26","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/:4:4","tags":["规范"],"title":"【目录贴】软硬件规范化","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["主线剧情"],"content":"介绍设备树","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"设备树详解 本文 续接 《【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解》 一文中移植过程小节中有关设备树的内容。 编辑整理 By Qitas，如有错误恭谢指出，侵删。CC-BY-NC-SA 4.0。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:0:0","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"零 参考 工欲善其事，必先利其器。 比较全面的文章： devicetree-org-devicetree-specification-github.com 官方语法描述； Specifications - DeviceTree 设备树组织官网发布的设备树标准； Device Tree What It Is - eLinux.org eLinux 网站的设备树介绍； Device Tree Usage - eLinux.org eLinux 网站的设备树使用，循序渐进，推荐看； 设备树_To_run_away的博客-CSDN博客 比较全面，共 30 篇文章； 网友总结的零散文章： Linux设备树语法详解 - Abnor - 博客园 (cnblogs.com)，部分细节介绍比较详细； Linux 设备树详解 - 程序员大本营 (pianshen.com)，该文介绍 Linux 内核解析 .dtb 文件，本文不涉及此内容； 【Linux笔记】设备树基础知识 - 知乎 (zhihu.com)，部分细节介绍比较详细； 统一设备模型 - 蜗窝科技 (wowotech.net)，很强但文章写不通顺，得读好几遍； Device Tree（一）：背景介绍 (wowotech.net)； Device Tree（二）：基本概念 (wowotech.net)； Device Tree（三）：代码分析 (wowotech.net)，该文介绍 Linux 内核解析 .dtb 文件，本文不涉及此内容； Device Tree（四）：文件结构解析 (wowotech.net)，设备树经过编译后的二进制文件的结构，以及 Linux 如何解析，本文不涉及此内容； 【Linux驱动开发】Linux设备树 - 程序员大本营 (pianshen.com)； 致驱动工程师的一封信 (wowotech.net)，扩展阅读； u-boot FIT image介绍 (wowotech.net)，扩展阅读； 【野火】《i.MX Linux开发实战指南》； 【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.5.1。 本文部分内容引自上述链接。上述有些文章的描述不清等问题，本文形成时梳理了一下；有些文章中英文混写的问题，在引用的基础上简单的修一下格式，并补充中文说明。上述有些文章还会在结尾突然说“点到为止，不多讲”，嗯，你很强，同时我也可以理解为不会简练表达，或者吝惜自己宝贵的时间不愿多敲几个字，但是那篇中有一句话说得很对“我只是给你指条明路，剩下的就需要自己去走。最后说一句，代码不会骗你，还会告诉你别人不能告诉你的”。 又要批判一番了，总感觉概念一大堆： 为了描述编译行为，另造一套 Makefile 语法； 为了描述让命令行适应编程行为，另造一套 Shell 语法； 为了描述编译后的各个文件如何链接起来，另造一套链接文件 .lds 语法； 为了描述 SoC 上电自己初始化的行为，另造一套行为描述语法，比如 DCD 段； 为了描述 SoC 硬件外设，另造一套设备树语法，我觉得这语法和 json 差不多。等等等等。 为什么光另造规则，不多想一些可重用的方法；正如英文单词，数量已经超过 100 万个了，恨不得给宇宙中所有事物都单独取名？ 也许原因之一是以上概念出现的很早，在那个混元初开的年代，还没有形成业内比较统一的、惯例的数据结构存储方法，所以百花齐放自造语法盛行。现在趋向于归一了，数据存储常用 json 或者 xml 语法，命令行编程常常趋近于兼容 shell 语法。挺好，越来越规范、归一，都这样的话不但提高来者的学习效率，也适合让机器去识别，早日实现全流程高度自动化。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:1:0","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"一 记录 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:0","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"设备树基本概念 Device Tree 是一种 适合人类阅读的（或者叫适合有智能的生物阅读的） 描述 SoC 硬件外设的数据结构（以文本的形式），硬件的细节可以直接通过它传递给 Linux（Bootloader 会将这棵树传递给内核，然后内核可以识别这棵树），内核会将这些硬件资源和自己的相应的设备原型绑定，进而可以控制实际的硬件外设，实现 板级信息 和 内核 的分离；Device Tree 由一系列被命名的 结点（node）（结点本身可包含子结点，即 总分 的结构）和 属性（property）（成对出现的 name 和 value ）组成。 通常由 .dts 文件以文本方式对系统设备树进行描述，经过 Device Tree Compiler (dtc) 将 .dts 文件转换成二进制文件 binary device tree blob (dtb)，.dtb 文件可由 Linux 内核解析（ .dtb 文件是一种可以被 kernel 和 uboot 识别的二进制文件），Linux 解析后把设备节点信息存储在 device_node 结构体里面，然后与 Linux 内核中的设备原型结构体 platform_device 进行绑定，即注册设备信息，Linux 系统下的设备大多都是挂载在平台总线下的，所有的子节点将被作为设备注册到该设备总线上。 除了描述设备，还可以描述 IO 动作用于外设的必要初始化，例如一个设备树的节点设备的 IO 描述为如下： device { rst-gpio = \u003c\u0026gpioc_ctl 10 OF_GPIO_ACTIVE_LOW\u003e; irq-gpio = \u003c\u0026gpioc_ctl 11 0\u003e; interrupts-extended = \u003c\u0026vic 11 IRQF_TRIGGER_RISING\u003e; }; 然后在 Linux 内核或者 uboot 中会解析这个结构并根据其中的设定进行动作，如下示例解析和动作： int device_probe(struct platform_device *pdev) { rst_gpio = of_get_named_gpio_flags(np, \"rst-gpio\", 0, \u0026flags); if (flags \u0026 OF_GPIO_ACTIVE_LOW) { struct gpio_desc *desc; desc = gpio_to_desc(rst_gpio); set_bit(FLAG_ACTIVE_LOW, \u0026desc-\u003eflags); } irq = of_irq_get(np, 0); trigger_type = irq_get_trigger_type(irq); request_threaded_irq(irq, NULL, irq_handler, trigger_type, \"irq\", NULL); } 所以，如果修改中断触发类型或者电平有效状态只需要修改 .dts 文件，再编译重新装载即可。 有了device tree 就可以在不改动 Linux 内核的情况下，对不同的平台实现无差异的支持，只需更换相应的 .dts 文件即可，硬件有变动时不需要重新编译内核或驱动程序，只需要提供不一样的 .dtb 文件。 Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler 安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。 在描述Device Tree的结构之前，我们先问一个基础问题：是否Device Tree要描述系统中的所有硬件信息？答案是否定的。基本上，那些可以动态探测到的设备是不需要描述的，例如USB device。不过对于SOC上的usb host controller，它是无法动态识别的，需要在device tree中描述。同样的道理，在computer system中，PCI device可以被动态探测到，不需要在device tree中描述，但是PCI bridge如果不能被探测，那么就需要描述之。 我们可以将公共部分抽取出来，一般为一个系列的 SoC 共有的硬件外设，写成 \u003cSoC\u003e.dtsi（i 表示 include ），方便大家在 具体的板级的 .dts 文件中 include。这样每个 .dts 就只有自己差异的部分，公有的部分只需要 include 相应的 .dtsi 文件, 这样就使整个设备树的管理更加有序。 在 Device Tree 中，可描述的信息包括（CPU、GPIO、时钟、中断、内存等）： CPU 的数量和类别； 内存基地址和大小； 总线和桥； 外设连接； 中断控制器和中断使用情况； GPIO 控制器和 GPIO 使用情况； Clock 控制器和 Clock 使用情况。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:1","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"设备树基本语法 设备树 .dts 文件描述硬件的基本结构，在 .dts 文件中，一个 node 被定义成： [label:] node-name[@unit-address] { [properties definitions] [child nodes] } 方括号 [] 里面的为可选项 Device Tree 中的节点信息 示意图： 上图细说如下： device tree 的基本单元是 node。这些 node 被组织成树状结构，除了root node，每个 node 都只有一个 parent，即父级节点。一个 device tree 文件中只能有一个 root node，即根节点，必须是/。 root 结点下面含一系列子结点，本例中为 “node@0” 和 “node@1” ；结点 “node@0” 下又含有一系列子结点，本例中为 “child-node@0”； 各结点都有一系列属性。属性（property）值标识了设备的特性，它的值（value）是多种多样的： 可能是空，也就是没有值的定义。例如上图中的 an-cmpty-property ，这个属性没有赋值； 可能是一个 u32、u64 的数值，用尖括号表示（值得一提的是 cell 这个术语，在 Device Tree 表示有几个 32bit 的信息，一个 cell 就是一个u32）。例如#address-cells = \u003c1\u003e 。当然，可能是一个数组。例如\u003c0x00000000 0x00000000 0x00000000 0x20000000\u003e，“#”是number的意思； 属性值是 binary data，用方括号表示。例如 binary-property = [0x01 0x23 0x45 0x67]； 可能是一个字符串，用双引号表示。例如device_type = \"memory\" ，当然也可能是一个 string list。例如\"PowerPC,970\"。 节点名字的格式是 node-name@unit-address，其中 node-name 就是设备名，最长可以是31个字符长度；unit_address 一般是设备地址，用来唯一标识一个节点；如果设备有 reg 属性，则 unit-address 就是寄存器地址，否则是用于区分的 编号。同级别的设备树下（相同级别的子节点）节点名唯一 。 可以通过 \u0026lable 的形式访问一个带 lable 的 node，这种引用是通过 phandle（pointer handle）进行的。例如，上图中的 node1 就是一个 lable，node@0 的子节点 child-node@0 通过 \u0026node1 引用 node@1 节点。经编译后，每一个 phandle 都是一个独一无二的整型值，在后续 kernel 中通过这个特殊的数字间接找到引用的节点。引用节点或者可用使用 full path（绝对路径），但一般不用，例如/node-name-1/node-name-2/node-name-N。 所以，一个设备树的基本框架可以写成下面这个样子。一般来说，/表示板子，它的子节点 node1 表示 SoC 上的某个 硬件外设/控制器，硬件外设/控制器 中的子节点 node2 表示挂接在这个控制器上的设备(们)。注释规则与 c 相同，用 //... 和 /* ... */。 /{ // 根节点 每个设备树文件都有一个根节点，每个设备都是一个节点 node1{ // node1 是节点名，是 / 的子节点 key=value; // node1 的属性 每个设备的属性都用一组 key-value 对(键值对)来描述 // 每个属性的描述用;结束 ... node2{ // node2 是 node1 的子节点 节点间可以嵌套，形成父子关系，这样就可以方便的描述设备间的关系 key=value; // node2 的属性 ... } } // node1 的描述到此为止 node3{ key=value; ... } } Device Tree中的节点信息 实例图： ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:2","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"设备树常用节点 根节点，用 / 标识根节点；CPU节点，一般不需要我们设置，在 .dtsi 文件中都定义好了； aliases 节点的作用就是为其他节点起一个别名。以 can0 = \u0026flexcan1; 为例。“flexcan1”是一个节点的名字，设置别名后我们可以使用“can0”来指代 flexcan1节点，与节点标签类似。 在驱动中如果要查找一个节点，通常情况下我们可以使用“节点路径”一步步找到节点。也可以使用别名“一步到位”找到节点。 memory 节点：芯片厂家不可能事先确定你的板子使用多大的内存，所以 memory 节点需要板厂设置，比如： memory { reg = \u003c0x80000000 0x20000000\u003e; }; chosen 节点：我们可以通过设备树文件给内核传入一些参数，例如下面在chosen节点中设置bootargs属性： chosen { bootargs = \"noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200\"; }; 这个节点用作 uboot 向 linux 内核传递配置参数的“通道”，我们在 Uboot 中设置的参数就是通过这个节点传递到内核的。 节点名、引用、修改和追加： 如果引用节点后编写的属性在之前已经有，则属性值会覆盖之前的，如果没有，则为追加属性。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:3","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"设备树标准属性 标准属性。在设备树中，有一些特定的属性。Linux 设备树语法中定义了一些具有规范意义的属性，包括：compatible, address, interrupt 等，这些信息能够在内核初始化找到节点的时候，自动解析生成相应的设备信息。此外，还有一些Linux内核定义好的，一类设备通用的有默认意义的属性，这些属性一般不能被内核自动解析生成相应的设备信息，但是内核已经编写的相应的解析提取函数，常见的有 “mac_addr”，“gpio”，“clock”，“power”。“regulator” 等等。 compatible：Linux 驱动中可以通过设备节点中的 “compatible” 这个属性查找设备节点，即根据这个属性的字符串描述的芯片的公司和驱动文件的字符串索引到驱动文件。例如系统初始化时会初始化 platform 总线上的设备时，根据设备节点”compatible”属性和驱动中 of_match_table 对应的值，匹配了就加载对应的驱动。 address： #address-cells，用来描述子节点的\"reg\"属性的地址表中用来描述首地址的cell的数量； #size-cells， 用来描述子节点的\"reg\"属性的地址表中用来描述地址长度的cell的数量。 若 reg 中的数值数量多于以上两个属性值的和，那么reg 属性里的数据是“地址”、“长度”交替的。 有了这两个属性，子节点中的 “reg” 就可以描述一块连续的地址区域。下例中，父节点中指定了#address-cells = \u003c2\u003e;#size-cells = \u003c1\u003e;，则子节点 dev-bootscs 中的 reg 中的前两个数表示一个地址，即 MBUS_ID(0xf0, 0x01) 和 0x1045C，然后有一个数表示从首地址开始要访问到的寄存器的长度，即 0x4 ，单位为 cell。 soc { #address-cel1s = \u003c2\u003e; #size-cells = \u003c1\u003e; controller = \u003c\u0026mbusc\u003e; devbus_bootcs:devbus-bootcs { compatible = \"marvell,orion-devbus\"; reg = \u003cMBUS_ID(OxfO,0x01) 0X1046C 0x4\u003e; ranges = \u003c0 MBUS_ID(0x01,0x0f) 0 Oxffffffff\u003e; #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; clocks = \u003c\u0026core_clk 0\u003e; status = \"disabled\"; }; ... }; gpio：gpio也是最常见的IO口，常用的属性有 “gpio-controller”，用来说明该节点描述的是一个gpio控制器； “#gpio-cells”，用来描述gpio使用节点的属性一个cell的内容； 描述 IO 行为，IO名 = \u003c\u0026引用GPIO节点别名 GPIO标号 工作模式\u003e。 interrupts：引自Linux设备树语法详解 - Abnor - 博客园 (cnblogs.com)。 标准属性 描述 compatible 属性 compatible 属性也叫做“兼容性”属性。用于将设备和驱动绑定起来。值是一个字符串列表，用于选择设备所要使用的驱动程序。 model 属性 值是字符串，一般描述设备模块信息，例如名字。 status 属性 值是字符串，设备的状态信息。 #address-cells #size-cells 属性 值是无符号 32 位整形。可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)，#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。 reg 属性 值一般是(address，length)对。用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息 ranges 属性 ranges 是一个地址映射/转换表，ranges 属性每个项目由子地址、父地址和地址空间长度 这三部分组成。如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。该属性提供了子节点地址空间和父地址空间的映射（转换）方法，常见格式是 ranges = \u003c 子地址, 父地址, 转\u003cbr/\u003e换长度 \u003e。 比如对于 #address-cells 和 #size-cells 都为 1 的话，以 ranges=\u003c0x0 0x10 0x20\u003e 为例，表示将子地址的从 0x0~(0x0+ 0x20) 的地址空间映射到父地址的 0x10~(0x10 + 0x20)。 name 属性 值是字符串，name 属性用于记录节点名字。name 属性已经被弃用，不推荐使用 name 属性，一些老的设备树文件可能会使用此属性。 device_type 属性 值是字符串，IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设 备树没有 FCode，所以此属性也被抛弃了。此属性只能用于 cpu 节点或者 memory 节点。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:4","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"设备树加深理解 看这里加深一下理解，Device Tree 中的节点信息 实例图：引自Linux dts 设备树详解(二) 动手编写设备树dts_GREYWALL-CSDN博客_设备树编写。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:5","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"二 其他 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:0","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"Uboot 中有关 dtb 的内容 uboot] （番外篇）uboot之fdt介绍_ooonebook的博客-CSDN博客； uboot 使用fdt命令查看设备树_兔兔里个花兔的博客-CSDN博客； u-boot中fdt命令的使用_voice_shen的专栏-CSDN博客_fdt命令； uboot处理dtb - zongzi10010 - 博客园 (cnblogs.com)； 一下有关 linxu 的小节会在以后放到【07-08】 linux 驱动/应用 的文章里面。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:1","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"Linux 中设备树操作函数 Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”（“open firmware”即开放固件。 ），所以在很多资料里面也被叫做 OF 函数。 device_node 结构体，它保存着设备节点的信息 其内容简述： name： 节点中属性为 name 的值； type： 节点中属性为 device_type 的值； full_name： 节点的名字，在 device_node 结构体后面放一个字符串， full_name 指向它； properties： 链表，连接该节点的所有属性； parent： 指向父节点； child： 指向子节点； sibling： 指向兄弟节点。 得到 device_node 结构体之后我们就可以使用其他 of 函数获取节点的详细信息。 of 函数更多内容可参：（网上很多，以后用的时候整理补充在这里） 【Linux笔记】设备树基础知识 - 知乎 (zhihu.com)。 【野火】《i.MX Linux开发实战指南》的 103.3 如何获取设备树节点信息 一节，讲了节点寻找、属性值获取和内存映射三大块 API。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:2","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["主线剧情"],"content":"用设备树建立和控制设备实例 从设备树拿信息控制 IO 和 使用 platform_device 控制 IO 的介绍和对比：【Linux笔记】设备树实例分析 - 知乎 (zhihu.com)。 linux 驱动开发之平台设备驱动设备树 led字符驱动的开发(详细注释)_myz348的博客-CSDN博客。 【野火】《i.MX Linux开发实战指南》的103.4 向设备树中添加设备节点实验一节。 【野火】《i.MX Linux开发实战指南》的 104 章节 使用设备树实现 RGB 灯驱动。 【野火】《i.MX Linux开发实战指南》的 105 章节 使用设备树插件实现 RGB 灯驱动。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:3","tags":["ARM","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"💥此网页采用 HUGO 静态博客生成工具 + LoveIt 主题完成，后托管于 Gitee。😘 ","date":"2021-07-03","objectID":"/about/:0:0","tags":null,"title":"关于本小站","uri":"/about/"},{"categories":null,"content":"HUGO 文档 Docs - Hugo中文文档 (gohugo.org)，官方，详细。 Hugo中文文档 (gohugo.org)，快速开始。 Hugo 自动化部署脚本 deploy.py - Hugo中文文档 (gohugo.org)。 ","date":"2021-07-03","objectID":"/about/:1:0","tags":null,"title":"关于本小站","uri":"/about/"},{"categories":null,"content":"HUGO 主题 Complete List | Hugo Themes (gohugo.io)。 皮肤列表 - Hugo中文文档 (gohugo.org)。 Hugo Themes Free。 ","date":"2021-07-03","objectID":"/about/:2:0","tags":null,"title":"关于本小站","uri":"/about/"},{"categories":null,"content":"LoveIt 主题详细使用说明 https://github.com/dillonzq/LoveIt/blob/master/README.zh-cn.md。 主题文档 - 基本概念 - LoveIt (hugoloveit.com)。 主题文档 - 内容 - LoveIt (hugoloveit.com)。 Emoji 支持 - LoveIt (hugoloveit.com)。 ","date":"2021-07-03","objectID":"/about/:3:0","tags":null,"title":"关于本小站","uri":"/about/"},{"categories":null,"content":"关机/重启/注销 常用命令 作用 shutdown -h now 即刻关机 shutdown -h 10 10分钟后关机 shutdown -h 11:00 11：00关机 shutdown -h +10 预定时间关机（10分钟后） shutdown -c 取消指定时间关机 shutdown -r now 重启 shutdown -r 10 10分钟之后重启 shutdown -r 11:00 定时重启 reboot 重启 init 6 重启 init 0 ⽴刻关机 telinit 0 关机 poweroff ⽴刻关机 halt 关机 sync buff数据同步到磁盘 logout 退出登录Shell 系统信息和性能查看 常用命令 作用 uname -a 查看内核/OS/CPU信息 uname -r 查看内核版本 uname -m 查看处理器架构 arch 查看处理器架构 hostname 查看计算机名 who 显示当前登录系统的⽤户 who am i 显示登录时的⽤户名 whoami 显示当前⽤户名 cat /proc/version 查看linux版本信息 cat /proc/cpuinfo 查看CPU信息 cat /proc/interrupts 查看中断 cat /proc/loadavg 查看系统负载 uptime 查看系统运⾏时间、⽤户数、负载 env 查看系统的环境变量 lsusb -tv 查看系统USB设备信息 lspci -tv 查看系统PCI设备信息 lsmod 查看已加载的系统模块 grep MemTotal /proc/meminfo 查看内存总量 grep MemFree /proc/meminfo 查看空闲内存量 free -m 查看内存⽤量和交换区⽤量 date 显示系统⽇期时间 cal 2021 显示2021⽇历表 top 动态显示cpu/内存/进程等情况 vmstat 1 20 每1秒采⼀次系统状态，采20次 iostat 查看io读写/cpu使⽤情况 查看io读写/cpu使⽤情况 查询cpu使⽤情况（1秒⼀次，共10次） sar -d 1 10 查询磁盘性能 磁盘和分区 常用命令 作用 fdisk -l 查看所有磁盘分区 swapon -s 查看所有交换分区 df -h 查看磁盘使⽤情况及挂载点 df -hl 同上 du -sh /dir 查看指定某个⽬录的⼤⼩ du -sk * | sort -rn 从⾼到低依次显示⽂件和⽬录⼤⼩ mount /dev/hda2 /mnt/hda2 挂载hda2盘 mount -t ntfs /dev/sdc1 /mnt/usbhd1 指定⽂件系统类型挂载（如ntfs） mount -o loop xxx.iso /mnt/cdrom 挂 载 iso ⽂ 件 umount -v /dev/sda1 通过设备名卸载 umount -v /mnt/mymnt 通过挂载点卸载 fuser -km /mnt/hda1 强制卸载(慎⽤) ⽤户和⽤户组 常用命令 作用 useradd codesheep 创建⽤户 userdel -r codesheep 删除⽤户 usermod -g group_name user_name 修改⽤户的组 usermod -aG group_name user_name 将⽤户添加到组 usermod -s /bin/ksh -d /home/codepig –g dev codesheep 修改⽤户codesheep的登录Shell、主⽬录以及⽤户组 groups test 查看test⽤户所在的组 groupadd group_name 创建⽤户组 groupdel group_name 删除⽤户组 groupmod -n new_name old_name 重命名⽤户组 su - user_name su - user_name passwd 修改⼝令 passwd codesheep 修改某⽤户的⼝令 w 查看活动⽤户 id codesheep 查看指定⽤户codesheep信息 last 查看⽤户登录⽇志 crontab -l 查看当前⽤户的计划任务 cut -d: -f1 /etc/passwd 查看系统所有⽤户 cut -d: -f1 /etc/group 查看系统所有组 ⽹络和进程管理 常用命令 作用 ifconfig 查看⽹络接⼝属性 ifconfig eth0 查看某⽹卡的配置 route -n 查看路由表 netstat -lntp 查看所有监听端⼝ netstat -antp 查看已经建⽴的TCP连接 netstat -lutp 查看TCP/UDP的状态信息 ifup eth0 启⽤eth0⽹络设备 ifdown eth0 禁⽤eth0⽹络设备 iptables -L 查看iptables规则 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 配置ip地址 dhclient eth0 以dhcp模式启⽤eth0 route add -net 0/0 gw Gateway_IP 配置默认⽹关 route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 配置静态路由到达⽹络'192.168.0.0/16' route del 0/0 gw Gateway_IP 删除静态路由 hostname 查看主机名 host www.baidu.com 解析主机名 nslookup www.baidu.com 查询DNS记录，查看域名解析是否正常 ps -ef 查看所有进程 ps -ef | grep codesheep 过滤出你需要的进程 kill -s name kill指定名称的进程 kill -s pid kill指定pid的进程 top 实时显示进程状态 vmstat 1 20 每1秒采⼀次系统状态，采20次 iostat iostat sar -u 1 10 查询cpu使⽤情况（1秒⼀次，共10次） sar -d 1 10 查询磁盘性能 常⻅系统服务命令 常用命令 作用 chkconfig –list 列出系统服务 service \u003c服务名\u003e status 查看某个服务 service \u003c服务名\u003e start 启动某个服务 service \u003c服务名\u003e stop 终⽌某个服务 service \u003c服务名\u003e restart 重启某个服务 systemctl status \u003c服务名\u003e 查看某个服务 systemctl start \u003c服务名\u003e 启动某个服务 systemctl stop \u003c服务名\u003e 终⽌某个服务 systemctl restart \u003c服务名\u003e 重启某个服务 systemctl enable \u003c服务名\u003e 关闭⾃启动 systemctl disable \u003c服务名\u003e 关闭⾃启动 ⽂件和⽬录操作 常用命令 作用 cd \u003c⽬录名\u003e 进⼊某个⽬录 cd .. 回上级⽬录 cd ../.. 回上两级⽬录 cd 进个⼈主⽬录 cd - 回上⼀步所在⽬录 pwd 显示当前路径 ls 查看⽂件⽬录列表 ls -F 查看⽬录中内容（显示是⽂件还是⽬录） ls -l 查看⽂件和⽬录的详情列表 ls -a 查看隐藏⽂件 ls -lh 查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性） ls -lSr 查看⽂件和⽬录列表（以⽂件⼤⼩升序查看） tree 查看⽂件和⽬录的树形结构 mkdir \u003c⽬录名\u003e 创建⽬录 mkdir dir1 dir2 同时创建两个⽬录 mkdir -p /tmp/dir1/dir2 创建⽬录树 rm -f file1 删除’file1'⽂件 rmdir dir1 删除’dir1'⽬录 rm -rf dir1 删除’dir1'⽬录和其内容 rm -rf dir1 dir2 同时删除两个⽬录及其内容 mv old_dir new_dir 重命名/移动⽬录 cp file1 file2 复制⽂件 cp dir/* . 复制某⽬录下的所有⽂件⾄当前⽬录 cp -a dir1 dir2 复制⽬录 cp -a /tmp/dir1 . 复制⼀个⽬录⾄当前⽬录 ln -s file1 link1 创建指向⽂件/⽬录的软链接 ln file1 lnk1 创建指向⽂件/⽬录的物理链接 find / -name file1 从跟⽬录开始搜索⽂件/⽬录 find / -user user1 搜索⽤户user1的⽂件/⽬录 find /dir -name *.bin 在⽬录/dir中搜带有.bin后缀的⽂件 locate \u003c关键词\u003e 快速定位⽂件 locate *.mp4 寻找.mp4结尾的⽂件 whereis \u003c关键词\u003e 显示某⼆进制⽂件/可执⾏⽂件的路径 which \u003c关键词\u003e 查找系统⽬录下某的⼆进制⽂件 chmod ugo+rwx dir1 设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限 chmod go-rwx dir1 移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限 chown user1 file1 改变⽂件的所有者属性 chown -R user1 dir1 改变⽬录的所有者属性 chgrp group1 file1 改变⽂件群组 chown user1:group1 file1 改变⽂件的所有⼈和群组 ⽂件查看和处理 常用命令 作用 cat file1 查看⽂件内容 cat -n file1 查看内容","date":"0001-01-01","objectID":"/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/:0:0","tags":null,"title":"","uri":"/linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"}]
